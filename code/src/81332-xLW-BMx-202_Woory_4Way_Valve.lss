mlx16-gcc (Melexis Mlx16-GCC v3.1.115.11) 7.5.0
Copyright (C) 2017 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


81332-xLW-BMx-202_Woory_4Way_Valve.elf:     file format elf32-mlx16-fx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .fw_vectors   00000240  00005800  00005800  00000194  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .mlx4_cst_tables_ram 0000005e  00000e80  00005a40  000003d4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .mlx4_par_tables_ram 00000088  00000f00  00005a9e  00000432  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .lin_ram_flash 00000012  00001000  00001000  00000194  2**0
                  ALLOC
  4 .dp.data      00000008  00001012  00005b26  000004ba  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000090  0000101a  00005b2e  000004c2  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000384  000010aa  00005bbe  00000552  2**1
                  ALLOC
  7 .flash_data   0000477a  00005bbe  00005bbe  00000552  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .flash_fill   000034ac  0000a338  0000a338  00004ccc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .fw_product_id 00000008  0000d7e4  0000d7e4  00008178  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 10 .fw_app_version 00000004  0000d7ec  0000d7ec  00008180  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 11 .fw_pltf_version 00000004  0000d7f0  0000d7f0  00008184  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 12 .fw_prot_key  00000008  0000d7f4  0000d7f4  00008188  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 13 .flash_crc    00000004  0000d7fc  0000d7fc  00008190  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 14 .debug_frame  000021c4  00000000  00000000  00008194  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_info   0007c959  00000000  00000000  0000a358  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_abbrev 00006513  00000000  00000000  00086cb1  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    000053cb  00000000  00000000  0008d1c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_aranges 00000d80  00000000  00000000  0009258f  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_line   0000d4cc  00000000  00000000  0009330f  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_str    0000f345  00000000  00000000  000a07db  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .comment      00000055  00000000  00000000  000afb20  2**0
                  CONTENTS, READONLY

Disassembly of section .fw_vectors:

00005800 <__fw_vectors>:
 * @return  void
 */
void l_ifc_wake_up_sl1 (void)
{
    (void)ml_WakeUp();
}
    5800:	54f0      	mov	UPr, #0
 */
void protection_Start(void)
{
    g_e8ShortOcc = C_ERR_SHORT_NO;
    diagnostic_Start();
}
    5802:	76da 4608 	jmpf	0x8c10 <_fw_start>
    5806:	a255      	add	A, [S-86]
    5808:	54f8      	mov	UPr, #8
    580a:	76da 1b23 	jmpf	0x3646 <__fatal>
    580e:	0000      	nop
    5810:	54f8      	mov	UPr, #8
    5812:	76da 1b23 	jmpf	0x3646 <__fatal>
    5816:	0000      	nop
    5818:	54f8      	mov	UPr, #8
    581a:	76da 1b23 	jmpf	0x3646 <__fatal>
    581e:	0000      	nop
    5820:	54f8      	mov	UPr, #8
    5822:	76da 1b23 	jmpf	0x3646 <__fatal>
    5826:	0100      	jmp	0x5a28 <.LASF15+0x5>
    5828:	54f8      	mov	UPr, #8
    582a:	76da 1b23 	jmpf	0x3646 <__fatal>
    582e:	0000      	nop
    5830:	54f0      	mov	UPr, #0
    5832:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    5836:	0000      	nop
    5838:	54f0      	mov	UPr, #0
    583a:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    583e:	0000      	nop
    5840:	54f0      	mov	UPr, #0
    5842:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    5846:	0000      	nop
    5848:	54f0      	mov	UPr, #0
    584a:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    584e:	0000      	nop
    5850:	54f0      	mov	UPr, #0
    5852:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    5856:	0000      	nop
    5858:	54f0      	mov	UPr, #0
    585a:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    585e:	0000      	nop
    5860:	54f0      	mov	UPr, #0
    5862:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    5866:	0000      	nop
    5868:	54f0      	mov	UPr, #0
    586a:	76da 42f7 	jmpf	0x85ee <__UV_VS_INT>
    586e:	0000      	nop
    5870:	54f0      	mov	UPr, #0
    5872:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    5876:	0000      	nop
    5878:	54f1      	mov	UPr, #1
    587a:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    587e:	0000      	nop
    5880:	54f1      	mov	UPr, #1
    5882:	76da 4311 	jmpf	0x8622 <__OVT_INT>
    5886:	0000      	nop
    5888:	54f1      	mov	UPr, #1
    588a:	76da 431a 	jmpf	0x8634 <__OVC_INT>
    588e:	0000      	nop
    5890:	54f1      	mov	UPr, #1
    5892:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    5896:	0000      	nop
    5898:	54f1      	mov	UPr, #1
    589a:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    589e:	0000      	nop
    58a0:	54f1      	mov	UPr, #1
    58a2:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    58a6:	0000      	nop
    58a8:	54f1      	mov	UPr, #1
    58aa:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    58ae:	0000      	nop
    58b0:	54f1      	mov	UPr, #1
    58b2:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    58b6:	0000      	nop
    58b8:	54f1      	mov	UPr, #1
    58ba:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    58be:	0000      	nop
    58c0:	54f1      	mov	UPr, #1
    58c2:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    58c6:	0000      	nop
    58c8:	54f1      	mov	UPr, #1
    58ca:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    58ce:	0000      	nop
    58d0:	54f5      	mov	UPr, #5
    58d2:	76da 4e41 	jmpf	0x9c82 <__STIMER_INT>
    58d6:	0000      	nop
    58d8:	54f2      	mov	UPr, #2
    58da:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    58de:	0000      	nop
    58e0:	54f2      	mov	UPr, #2
    58e2:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    58e6:	0000      	nop
    58e8:	54f2      	mov	UPr, #2
    58ea:	76da 4e87 	jmpf	0x9d0e <__CTIMER0_3_INT>
    58ee:	0000      	nop
    58f0:	54f2      	mov	UPr, #2
    58f2:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    58f6:	0000      	nop
    58f8:	54f2      	mov	UPr, #2
    58fa:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    58fe:	0000      	nop
    5900:	54f2      	mov	UPr, #2
    5902:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    5906:	0000      	nop
    5908:	54f2      	mov	UPr, #2
    590a:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    590e:	0000      	nop
    5910:	54f2      	mov	UPr, #2
    5912:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    5916:	0000      	nop
    5918:	54f2      	mov	UPr, #2
    591a:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    591e:	0000      	nop
    5920:	54f2      	mov	UPr, #2
    5922:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    5926:	0000      	nop
    5928:	54f2      	mov	UPr, #2
    592a:	76da 4da0 	jmpf	0x9b40 <__PWM_MASTER1_END_INT>
    592e:	0000      	nop
    5930:	54f2      	mov	UPr, #2
    5932:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    5936:	0000      	nop
    5938:	54f2      	mov	UPr, #2
    593a:	76da 4db6 	jmpf	0x9b6c <__PWM_SLAVE2_CMP_INT>
    593e:	0000      	nop
    5940:	54f2      	mov	UPr, #2
    5942:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    5946:	0000      	nop
    5948:	54f2      	mov	UPr, #2
    594a:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    594e:	0000      	nop
    5950:	54f2      	mov	UPr, #2
    5952:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    5956:	0000      	nop
    5958:	54f3      	mov	UPr, #3
    595a:	76da 3b90 	jmpf	0x7720 <__ADC_SAR_INT>
    595e:	0000      	nop
    5960:	54f2      	mov	UPr, #2
    5962:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    5966:	0000      	nop
    5968:	54f2      	mov	UPr, #2
    596a:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    596e:	0000      	nop
    5970:	54f2      	mov	UPr, #2
    5972:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    5976:	0000      	nop
    5978:	54f4      	mov	UPr, #4
    597a:	76da 447c 	jmpf	0x88f8 <__COLIN_LIN_INT>
    597e:	0000      	nop
    5980:	54f2      	mov	UPr, #2
    5982:	76da 4308 	jmpf	0x8610 <__OV_VS_INT>
    5986:	0000      	nop
    5988:	54f2      	mov	UPr, #2
    598a:	76da 4db8 	jmpf	0x9b70 <__DIAG_INT>
    598e:	0000      	nop
    5990:	54f2      	mov	UPr, #2
    5992:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    5996:	0000      	nop
    5998:	54f2      	mov	UPr, #2
    599a:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    599e:	0000      	nop
    59a0:	54f2      	mov	UPr, #2
    59a2:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    59a6:	0000      	nop
    59a8:	54f2      	mov	UPr, #2
    59aa:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    59ae:	0000      	nop
    59b0:	54f2      	mov	UPr, #2
    59b2:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    59b6:	0000      	nop
    59b8:	54f2      	mov	UPr, #2
    59ba:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    59be:	0000      	nop
    59c0:	54f2      	mov	UPr, #2
    59c2:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    59c6:	0000      	nop
    59c8:	54f2      	mov	UPr, #2
    59ca:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    59ce:	0000      	nop
    59d0:	54f2      	mov	UPr, #2
    59d2:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    59d6:	0000      	nop
    59d8:	54f2      	mov	UPr, #2
    59da:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    59de:	0000      	nop
    59e0:	54f2      	mov	UPr, #2
    59e2:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    59e6:	0000      	nop
    59e8:	54f2      	mov	UPr, #2
    59ea:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    59ee:	0000      	nop
    59f0:	54f2      	mov	UPr, #2
    59f2:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    59f6:	0000      	nop
    59f8:	54f2      	mov	UPr, #2
    59fa:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    59fe:	0000      	nop
    5a00:	54f2      	mov	UPr, #2
    5a02:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    5a06:	0000      	nop
    5a08:	54f2      	mov	UPr, #2
    5a0a:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    5a0e:	0000      	nop
    5a10:	54f2      	mov	UPr, #2
    5a12:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    5a16:	0000      	nop
    5a18:	54f2      	mov	UPr, #2
    5a1a:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    5a1e:	0000      	nop
    5a20:	54f4      	mov	UPr, #4
    5a22:	76da 4ece 	jmpf	0x9d9c <__UDFR_INT>
    5a26:	0000      	nop
    5a28:	54f4      	mov	UPr, #4
    5a2a:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    5a2e:	0000      	nop
    5a30:	54f2      	mov	UPr, #2
    5a32:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    5a36:	0000      	nop
    5a38:	54f6      	mov	UPr, #6
    5a3a:	76da 4404 	jmpf	0x8808 <_Generic_INT>
    5a3e:	0000      	nop

Disassembly of section .mlx4_cst_tables_ram:

00000e80 <__mlx4_cst_tables_ram_start>:
 e80:	a55a      	or	A, dp:0x5a <.Lframe0+0x6>
 e82:	5aa5      	mov	io:0x25 <.LLST1+0x7>, Y
 e84:	0000      	nop
 e86:	0000      	nop
 e88:	0000      	nop
 e8a:	0000      	nop
 e8c:	0000      	nop
 e8e:	0000      	nop
 e90:	0000      	nop
 e92:	0000      	nop
 e94:	0000      	nop
 e96:	0000      	nop
 e98:	4104      	mov	dp:0x4 <_RST_CTRL+0x2>, AL
 e9a:	2000      	add	X, #0
 e9c:	0000      	nop
 e9e:	0000      	nop
 ea0:	01e0      	jmp	0x1262 <.LLST6+0x10>
 ea2:	0003      	jmp	0xeaa <.LLST10+0x6>
 ea4:	0005      	jmp	0xeb0 <.LLST10+0xc>
 ea6:	0000      	nop
 ea8:	4233      	mov	[S-52], AL
 eaa:	5f50      	mov	ep:0x50 <.LASF1528+0x3>, X
 eac:	7c6d      	lod	X, #109
 eae:	998a      	subc	AL, dp:0x8a <__mlx4_flash_table_size+0x2>
 eb0:	140e      	call	0x6ce <.LLST20+0x3>
 eb2:	201a      	add	X, #26
 eb4:	2c26      	cmp	X, #38
 eb6:	3832      	subc	X, #50
 eb8:	0248      	jmp	0x134a <.LLST2+0x3>
 eba:	c852      	sub	AH, #82
 ebc:	6f03      	lod	YH, ep:0x3 <_RST_CTRL+0x1>
 ebe:	ff05      	xor	Y, ep:0x5 <_RST_CTRL+0x3>
 ec0:	0000      	nop
 ec2:	e0ac      	add	Y, #-84
 ec4:	0001      	jmp	0xec8 <.LASF1536+0x5>
 ec6:	0200      	jmp	0x12c8 <_dBase+0x4>
 ec8:	7da0      	lod	X, dp:0xa0 <.LASF1559>
 eca:	d70a      	and	AH, ep:0xa <_MUPET>
 ecc:	39e4      	subc	X, dp:0xe4 <.LASF2089+0x3>
 ece:	934e      	adc	AL, ep:0x4e <.LASF1528+0x1>
 ed0:	d3e0      	adc	AH, ep:0xe0 <.LLST13>
 ed2:	a497      	or	A, #-105
 ed4:	2c1f      	cmp	X, #31
 ed6:	5b68      	mov	ep:0x68 <__mlx4_cst_tables_ram_size+0xa>, Y
 ed8:	a81f      	sub	A, #31
 eda:	b47f      	and	A, #127
 edc:	00b2      	jmp	0x1042 <_l_sAdcAvgObject+0xa>

Disassembly of section .mlx4_par_tables_ram:

00000f00 <_INDXtbl>:
 f00:	4040      	jmp	fp2:0x00
 f02:	4040      	jmp	fp2:0x00
 f04:	4040      	jmp	fp2:0x00
 f06:	4040      	jmp	fp2:0x00
 f08:	4040      	jmp	fp2:0x00
 f0a:	4040      	jmp	fp2:0x00
 f0c:	4040      	jmp	fp2:0x00
 f0e:	4040      	jmp	fp2:0x00
 f10:	4040      	jmp	fp2:0x00
 f12:	4040      	jmp	fp2:0x00
 f14:	4040      	jmp	fp2:0x00
 f16:	4040      	jmp	fp2:0x00
 f18:	4040      	jmp	fp2:0x00
 f1a:	4040      	jmp	fp2:0x00
 f1c:	4040      	jmp	fp2:0x00
 f1e:	4040      	jmp	fp2:0x00
 f20:	4040      	jmp	fp2:0x00
 f22:	4040      	jmp	fp2:0x00
 f24:	4040      	jmp	fp2:0x00
 f26:	4040      	jmp	fp2:0x00
 f28:	4040      	jmp	fp2:0x00
 f2a:	4040      	jmp	fp2:0x00
 f2c:	4040      	jmp	fp2:0x00
 f2e:	4040      	jmp	fp2:0x00
 f30:	4040      	jmp	fp2:0x00
 f32:	4040      	jmp	fp2:0x00
 f34:	4040      	jmp	fp2:0x00
 f36:	4040      	jmp	fp2:0x00
 f38:	4040      	jmp	fp2:0x00
 f3a:	4040      	jmp	fp2:0x00
 f3c:	1110      	call	0x115e <.LLST11+0x1>
 f3e:	c0c0      	add	AH, #-64

00000f40 <_PARAMtbl>:
 f40:	0f2f      	lod	C, io:0x05.7
 f42:	a02f      	add	A, #47
 f44:	a0a0      	add	A, #-96
 f46:	a0a0      	add	A, #-96
 f48:	a0a0      	add	A, #-96
 f4a:	a0a0      	add	A, #-96
 f4c:	a0a0      	add	A, #-96
 f4e:	a0a0      	add	A, #-96
 f50:	2707      	or	X, ep:0x7 <_FUNC_TEST+0x1>
 f52:	a0a0      	add	A, #-96
 f54:	a0a0      	add	A, #-96
 f56:	a0a0      	add	A, #-96
 f58:	a0a0      	add	A, #-96
 f5a:	a0a0      	add	A, #-96
 f5c:	a0a0      	add	A, #-96
 f5e:	a0a0      	add	A, #-96
 f60:	a0a0      	add	A, #-96
 f62:	a0a0      	add	A, #-96
 f64:	a0a0      	add	A, #-96
 f66:	a0a0      	add	A, #-96
 f68:	a0a0      	add	A, #-96
 f6a:	a0a0      	add	A, #-96
 f6c:	a0a0      	add	A, #-96
 f6e:	a0a0      	add	A, #-96
 f70:	a0a0      	add	A, #-96
 f72:	a0a0      	add	A, #-96
 f74:	a0a0      	add	A, #-96
 f76:	a0a0      	add	A, #-96
 f78:	a0a0      	add	A, #-96
 f7a:	a0a0      	add	A, #-96
 f7c:	a0a0      	add	A, #-96
 f7e:	a0a0      	add	A, #-96

00000f80 <_AUTOADDtbl>:
 f80:	2610      	or	X, [S-17]
 f82:	0626      	jmp	0xbd0 <.LASF1796+0x4>
 f84:	0000      	nop
 f86:	0000      	nop

Disassembly of section .flash_data:

00005bbe <.LC0>:
    5bbe:	9201      	adc	AL, [S-2]
    5bc0:	f011      	adc	Y, #17

00005bc2 <___clz_tab>:
    5bc2:	0100 0202 0303 0303 0404 0404 0404 0404     ................
    5bd2:	0505 0505 0505 0505 0505 0505 0505 0505     ................
    5be2:	0606 0606 0606 0606 0606 0606 0606 0606     ................
    5bf2:	0606 0606 0606 0606 0606 0606 0606 0606     ................
    5c02:	0707 0707 0707 0707 0707 0707 0707 0707     ................
    5c12:	0707 0707 0707 0707 0707 0707 0707 0707     ................
    5c22:	0707 0707 0707 0707 0707 0707 0707 0707     ................
    5c32:	0707 0707 0707 0707 0707 0707 0707 0707     ................
    5c42:	0808 0808 0808 0808 0808 0808 0808 0808     ................
    5c52:	0808 0808 0808 0808 0808 0808 0808 0808     ................
    5c62:	0808 0808 0808 0808 0808 0808 0808 0808     ................
    5c72:	0808 0808 0808 0808 0808 0808 0808 0808     ................
    5c82:	0808 0808 0808 0808 0808 0808 0808 0808     ................
    5c92:	0808 0808 0808 0808 0808 0808 0808 0808     ................
    5ca2:	0808 0808 0808 0808 0808 0808 0808 0808     ................
    5cb2:	0808 0808 0808 0808 0808 0808 0808 0808     ................

00005cc2 <.L189>:
    5cc2:	361d      	and	X, [S-30]
    5cc4:	364e      	and	X, [S-79]
    5cc6:	36b1      	and	X, io:0x31 <_STIMER+0x1>
    5cc8:	36bf      	and	X, io:0x3f <.LLST12+0x3>
    5cca:	36f3      	and	X, [Y+3]
    5ccc:	3733      	and	X, ep:0x33 <_STIMER+0x3>
    5cce:	3883      	subc	X, #-125
    5cd0:	38eb      	subc	X, #-21
    5cd2:	3a51      	subc	X, [S-82]
    5cd4:	3a5f      	subc	X, [S-96]
    5cd6:	3a77      	subc	X, [S-120]

00005cd8 <.L227>:
    5cd8:	3759      	and	X, ep:0x59 <.Lframe0+0x5>
    5cda:	3763      	and	X, ep:0x63 <__mlx4_cst_tables_ram_size+0x5>
    5cdc:	3789      	and	X, ep:0x89 <__mlx4_flash_table_size+0x1>
    5cde:	37e7      	and	X, ep:0xe7 <.LASF2089+0x6>
    5ce0:	3642      	and	X, [S-67]
    5ce2:	3830      	subc	X, #48
    5ce4:	3642      	and	X, [S-67]
    5ce6:	385e      	subc	X, #94
    5ce8:	3870      	subc	X, #112
    5cea:	387f      	subc	X, #127

00005cec <.L15>:
    5cec:	3c07      	xor	X, #7
    5cee:	3c0d      	xor	X, #13
    5cf0:	3c1e      	xor	X, #30
    5cf2:	3c24      	xor	X, #36
    5cf4:	3c2a      	xor	X, #42
    5cf6:	3c30      	xor	X, #48
    5cf8:	3c36      	xor	X, #54
    5cfa:	3c3c      	xor	X, #60

00005cfc <_IGNconversionMap>:
    5cfc:	0132 0000 028a 0000 015b 0000 0384 0000     2.......[.......
    5d0c:	0178 0000 04b0 0000 019b 0000 0708 0000     x...............

00005d1c <.L41>:
    5d1c:	3eee      	xor	X, X
    5d1e:	3ef6      	xor	X, [Y+6]
    5d20:	3f84      	xor	X, ep:0x84 <__min_stack_size+0x4>
    5d22:	3fc8      	xor	X, ep:0xc8 <.LASF1348>
    5d24:	3ff2      	xor	X, ep:0xf2 <.LASF779+0xa>
    5d26:	4034      	jmp	fp1:0xA0
    5d28:	4047      	jmp	fp2:0x38
    5d2a:	4057      	jmp	fp2:0xB8

00005d2c <_eeprom_defaults>:
    5d2c:	01ab 1192 00f0 0000 00ff 0000 0000 0000     ................
    5d3c:	00ff 0000 0000 0000                         ........

00005d44 <.L55>:
    5d44:	48ad      	lsr	YA, #14
    5d46:	48cf      	asl	D, #16
    5d48:	48c5      	asl	D, #6
    5d4a:	48d9      	rl	D, #10
    5d4c:	48e1      	asl	YA, #2
    5d4e:	48e6      	asl	YA, #7
    5d50:	48c3      	asl	D, #4

00005d52 <.L31>:
    5d52:	4995      	mov	dp:0x95 <__data_size+0x5>, AH
    5d54:	498c      	mov	dp:0x8c <.LASF1529>, AH
    5d56:	4995      	mov	dp:0x95 <__data_size+0x5>, AH
    5d58:	49a2      	mov	dp:0xa2 <.LASF1559+0x2>, AH
    5d5a:	49a2      	mov	dp:0xa2 <.LASF1559+0x2>, AH
    5d5c:	49a2      	mov	dp:0xa2 <.LASF1559+0x2>, AH
    5d5e:	49a2      	mov	dp:0xa2 <.LASF1559+0x2>, AH
    5d60:	49a2      	mov	dp:0xa2 <.LASF1559+0x2>, AH
    5d62:	4995      	mov	dp:0x95 <__data_size+0x5>, AH
    5d64:	49a2      	mov	dp:0xa2 <.LASF1559+0x2>, AH
    5d66:	49a2      	mov	dp:0xa2 <.LASF1559+0x2>, AH
    5d68:	49a2      	mov	dp:0xa2 <.LASF1559+0x2>, AH
    5d6a:	498c      	mov	dp:0x8c <.LASF1529>, AH

00005d6c <___VPC_Fwv_Resp_flags_mask_3909>:
    5d6c:	ffe0 10ff                                   ....

00005d70 <___VPC_Fwv_Ctrl_flags_mask_3985>:
    5d70:	001f 4000                                   ...@

00005d74 <___Debug_Frame_flags_mask_3952>:
    5d74:	0000 2f00                                   .../

00005d78 <_frameList>:
    5d78:	0000 5d88 0000 5d84 0000 5d86               ...]...]...]

00005d84 <_l_sl1_VPC_Fwv_Ctrl_frame>:
    5d84:	4a03                                        .J

00005d86 <_l_sl1_Debug_Frame_frame>:
    5d86:	49d5                                        .I

00005d88 <_l_sl1_VPC_Fwv_Resp_frame>:
    5d88:	4a32                                        2J

00005d8a <_ml_ProductID>:
    5d8a:	0000 0000 00ff                              ......

00005d90 <_ml_InitialNAD>:
    5d90:	0001                                        ..

00005d92 <_ATAN_LUT>:
    5d92:	0000 00a3 0146 01e9 028c 032f 03d2 0475     ....F...../...u.
    5da2:	0517 05ba 065d 0700 07a2 0845 08e7 098a     ....].....E.....
    5db2:	0a2c 0acf 0b71 0c13 0cb5 0d57 0df9 0e9a     ,...q.....W.....
    5dc2:	0f3c 0fdd 107f 1120 11c1 1262 1303 13a4     <..... ...b.....
    5dd2:	1444 14e5 1585 1625 16c5 1765 1804 18a4     D.....%...e.....
    5de2:	1943 19e2 1a80 1b1f 1bbd 1c5c 1cfa 1d97     C.........\.....
    5df2:	1e35 1ed2 1f6f 200c 20a9 2145 21e1 227d     5...o.. . E!.!}"
    5e02:	2319 23b4 2450 24ea 2585 261f 26ba 2753     .#.#P$.$.%.&.&S'
    5e12:	27ed 2886 291f 29b8 2a50 2ae8 2b80 2c17     .'.(.).)P*.*.+.,
    5e22:	2caf 2d46 2ddc 2e72 2f08 2f9e 3033 30c8     .,F-.-r.././30.0
    5e32:	315d 31f1 3285 3319 33ac 343f 34d2 3564     ]1.1.2.3.3?4.4d5
    5e42:	35f6 3687 3719 37a9 383a 38ca 395a 39e9     .5.6.7.7:8.8Z9.9
    5e52:	3a78 3b07 3b95 3c23 3cb1 3d3e 3dcb 3e58     x:.;.;#<.<>=.=X>
    5e62:	3ee4 3f6f 3ffb 4086 4110 419a 4224 42ad     .>o?.?.@.A.A$B.B
    5e72:	4336 43bf 4447 44cf 4556 45dd 4664 46ea     6C.CGD.DVE.EdF.F
    5e82:	4770 47f5 487a 48ff 4983 4a07 4a8b 4b0d     pG.GzH.H.I.J.J.K
    5e92:	4b90 4c12 4c94 4d15 4d96 4e17 4e97 4f17     .K.L.L.M.M.N.N.O
    5ea2:	4f96 5015 5093 5111 518f 520c 5289 5306     .O.P.P.Q.Q.R.R.S
    5eb2:	5382 53fd 5478 54f3 556e 55e8 5661 56da     .S.SxT.TnU.UaV.V
    5ec2:	5753 57cb 5843 58ba 5932 59a8 5a1e 5a94     SW.WCX.X2Y.Y.Z.Z
    5ed2:	5b0a 5b7f 5bf3 5c67 5cdb 5d4e 5dc1 5e34     .[.[.[g\.\N].]4^
    5ee2:	5ea6 5f18 5f89 5ffa 606a 60db 614a 61b9     .^._._._j`.`Ja.a
    5ef2:	6228 6297 6305 6373 63e0 644d 64b9 6525     (b.b.csc.cMd.d%e
    5f02:	6591 65fc 6667 66d1 673b 67a5 680e 6877     .e.egf.f;g.g.hwh
    5f12:	68e0 6948 69b0 6a17 6a7e 6ae4 6b4b 6bb0     .hHi.i.j~j.jKk.k
    5f22:	6c16 6c7b 6cdf 6d44 6da8 6e0b 6e6e 6ed1     .l{l.lDm.m.nnn.n
    5f32:	6f33 6f95 6ff7 7058 70b9 7119 717a 71d9     3o.o.oXp.p.qzq.q
    5f42:	7239 7298 72f6 7355 73b3 7410 746d 74ca     9r.r.rUs.s.tmt.t
    5f52:	7527 7583 75df 763a 7695 76f0 774a 77a4     'u.u.u:v.v.vJw.w
    5f62:	77fe 7857 78b0 7909 7961 79b9 7a10 7a68     .wWx.x.yay.y.zhz
    5f72:	7abf 7b15 7b6b 7bc1 7c17 7c6c 7cc1 7d16     .z.{k{.{.|l|.|.}
    5f82:	7d6a 7dbe 7e11 7e65 7eb7 7f0a 7f5c 7fae     j}.}.~e~.~..\...
    5f92:	8000 8051                                   ..Q.

00005f96 <___gtsf2>:
    5f96:	581d      	inc	S, #30

00005f98 <.LCFI0>:
    5f98:	58a1      	mov	[S-6], YA

00005f9a <.LM3>:
    5f9a:	7223      	lod	A, [S-36]

00005f9c <.LVL1>:
    5f9c:	5209      	mov	[S-10], A
    5f9e:	7221      	lod	A, [S-34]
    5fa0:	5207      	mov	[S-8], A

00005fa2 <.LM4>:
    5fa2:	7eef      	lod	X, S
    5fa4:	20ec      	add	X, #-20
    5fa6:	5edf      	push	X

00005fa8 <.LCFI1>:
    5fa8:	72ef      	lod	A, S
    5faa:	a0f8      	add	A, #-8
    5fac:	112d      	call	0x6208 <___unpack_f>

00005fae <.LM5>:
    5fae:	7aef      	lod	Y, S
    5fb0:	e0e0      	add	Y, #-32
    5fb2:	5adf      	push	Y

00005fb4 <.LCFI2>:
    5fb4:	72ef      	lod	A, S
    5fb6:	a0f2      	add	A, #-14
    5fb8:	5a05      	mov	[S-6], Y
    5fba:	1126      	call	0x6208 <___unpack_f>

00005fbc <.LM6>:
    5fbc:	7217      	lod	A, [S-24]
    5fbe:	5c03      	dec	S, #4

00005fc0 <.LCFI3>:
    5fc0:	7a01      	lod	Y, [S-2]
    5fc2:	ac01      	cmp	A, #1
    5fc4:	1a08      	jule	0x5fd6 <.L4>

00005fc6 <.LM7>:
    5fc6:	721d      	lod	A, [S-30]
    5fc8:	ac01      	cmp	A, #1
    5fca:	1a05      	jule	0x5fd6 <.L4>

00005fcc <.LM8>:
    5fcc:	5adf      	push	Y

00005fce <.LCFI4>:
    5fce:	72ef      	lod	A, S
    5fd0:	a0ea      	add	A, #-22
    5fd2:	1178      	call	0x62c4 <___fpcmp_parts_f>

00005fd4 <.LCFI5>:
    5fd4:	5421      	ret	#34

00005fd6 <.L4>:
    5fd6:	70ff      	lod	A, #-1

00005fd8 <.LM10>:
    5fd8:	541f      	ret	#32

00005fda <___floatsisf>:
    5fda:	580d      	inc	S, #14

00005fdc <.LCFI0>:
    5fdc:	58a0      	mov	[S-4], YA

00005fde <.LM2>:
    5fde:	7c03      	lod	X, #3
    5fe0:	5e0d      	mov	[S-14], X

00005fe2 <.LM3>:
    5fe2:	7e01      	lod	X, [S-2]
    5fe4:	5c8f      	sn	X
    5fe6:	5e0b      	mov	[S-12], X

00005fe8 <.LM4>:
    5fe8:	4cc0      	mov	D, YA
    5fea:	4caa 0000 	cmpu	D, #0
    5fee:	1d06      	jne	0x5ffc <.L2>

00005ff0 <.LM5>:
    5ff0:	7002      	lod	A, #2

00005ff2 <.LVL1>:
    5ff2:	520d      	mov	[S-14], A

00005ff4 <.L3>:
    5ff4:	72ef      	lod	A, S
    5ff6:	a0f2      	add	A, #-14
    5ff8:	1057      	call	0x60a8 <___pack_f>
    5ffa:	540f      	ret	#16

00005ffc <.L2>:
    5ffc:	7c1e      	lod	X, #30
    5ffe:	5e09      	mov	[S-10], X

00006000 <.LM8>:
    6000:	58c0      	mov	D, [S-4]
    6002:	4caa 0000 	cmpu	D, #0
    6006:	1e87      	jsge	0x6016 <.L6>

00006008 <.LM9>:
    6008:	4c92 0000 	cmp	D, #-2147483648
    600c:	8000 
    600e:	1918      	je	0x6040 <.L8>

00006010 <.LM10>:
    6010:	4c80      	mov	YA, D

00006012 <.LVL5>:
    6012:	4cf0      	neg	YA
    6014:	58a0      	mov	[S-4], YA

00006016 <.L6>:
    6016:	58e0      	mov	YA, [S-4]
    6018:	1017      	call	0x6048 <___clzsi2>

0000601a <.LBE6>:
    601a:	7ee2      	lod	X, A
    601c:	20ff      	add	X, #-1

0000601e <.LVL8>:
    601e:	ac01      	cmp	A, #1
    6020:	1d03      	jne	0x6028 <.L7>

00006022 <.LM13>:
    6022:	58e0      	mov	YA, [S-4]
    6024:	58a2      	mov	[S-8], YA
    6026:	07e6      	jmp	0x5ff4 <.L3>

00006028 <.L7>:
    6028:	58e0      	mov	YA, [S-4]
    602a:	2c00      	cmp	X, #0
    602c:	1b04      	jsle	0x6036 <.L9>
    602e:	5edf      	push	X

00006030 <.L10>:
    6030:	48e0      	asl	YA, #1
    6032:	1bfe      	djnz	X, 0x6030 <.L10>
    6034:	7ecf      	pop	X

00006036 <.L9>:
    6036:	58a2      	mov	[S-8], YA

00006038 <.LM15>:
    6038:	701e      	lod	A, #30
    603a:	aaee      	sub	A, X
    603c:	5209      	mov	[S-10], A
    603e:	07da      	jmp	0x5ff4 <.L3>

00006040 <.L8>:
    6040:	4ce2 0000 	mov	YA, #-822083584
    6044:	cf00 

00006046 <.LBE5>:
    6046:	540f      	ret	#16

00006048 <___clzsi2>:
    6048:	580b      	inc	S, #12

0000604a <.LCFI0>:
    604a:	58a0      	mov	[S-4], YA

0000604c <.LBB2>:
    604c:	4cc0      	mov	D, YA
    604e:	4c92 ffff 	cmp	D, #65535
    6052:	0000 
    6054:	1e1b      	jug	0x608c <.L2>

00006056 <.LM3>:
    6056:	4caa 00ff 	cmpu	D, #255
    605a:	1a20      	jule	0x609c <.L4>

0000605c <.LM4>:
    605c:	4cfa 0008 	movs	YA, #8

00006060 <.L6>:
    6060:	58a2      	mov	[S-8], YA

00006062 <.LVL3>:
    6062:	4cda 0020 	movs	D, #32
    6066:	4c80      	mov	YA, D

00006068 <.LVL4>:
    6068:	aa07      	sub	A, [S-8]
    606a:	fa05      	subc	Y, [S-6]
    606c:	58a4      	mov	[S-12], YA
    606e:	7e07      	lod	X, [S-8]
    6070:	58e0      	mov	YA, [S-4]
    6072:	2c00      	cmp	X, #0
    6074:	1b02      	jsle	0x607a <.L7>

00006076 <.L8>:
    6076:	48a0      	lsr	YA, #1
    6078:	1bfe      	djnz	X, 0x6076 <.L8>

0000607a <.L7>:
    607a:	a2da 5bc2 	add	A, #23490
    607e:	7ae2      	lod	Y, A
    6080:	62f0      	lod	AL, [Y]
    6082:	5cf2      	usex	A

00006084 <.LBE2>:
    6084:	7e0b      	lod	X, [S-12]
    6086:	2ae2      	sub	X, A
    6088:	72ee      	lod	A, X

0000608a <.LM6>:
    608a:	540d      	ret	#14

0000608c <.L2>:
    608c:	58c0      	mov	D, [S-4]
    608e:	4c92 ffff 	cmp	D, #16777215
    6092:	00ff 
    6094:	1a06      	jule	0x60a2 <.L5>

00006096 <.LM8>:
    6096:	4cfa 0018 	movs	YA, #24

0000609a <.LVL6>:
    609a:	07e2      	jmp	0x6060 <.L6>

0000609c <.L4>:
    609c:	4cfa 0000 	movs	YA, #0

000060a0 <.LVL8>:
    60a0:	07df      	jmp	0x6060 <.L6>

000060a2 <.L5>:
    60a2:	4cfa 0010 	movs	YA, #16

000060a6 <.LVL10>:
    60a6:	07dc      	jmp	0x6060 <.L6>

000060a8 <___pack_f>:
    60a8:	580d      	inc	S, #14

000060aa <.LCFI0>:
    60aa:	7ee2      	lod	X, A

000060ac <.LM2>:
    60ac:	7ae2      	lod	Y, A
    60ae:	e006      	add	Y, #6
    60b0:	72f0      	lod	A, [Y]

000060b2 <.LVL1>:
    60b2:	5207      	mov	[S-8], A
    60b4:	72f2      	lod	A, [Y+2]
    60b6:	5205      	mov	[S-6], A

000060b8 <.LM3>:
    60b8:	72fa      	lod	A, [X+2]
    60ba:	520d      	mov	[S-14], A

000060bc <.LM4>:
    60bc:	72f8      	lod	A, [X]

000060be <.LVL4>:
    60be:	ac01      	cmp	A, #1
    60c0:	1e29      	jug	0x6114 <.L2>

000060c2 <.LM5>:
    60c2:	58c2      	mov	D, [S-8]
    60c4:	4886      	lsr	D, #7

000060c6 <.LM6>:
    60c6:	4c80      	mov	YA, D
    60c8:	f43f      	and	Y, #63

000060ca <.LM7>:
    60ca:	e440      	or	Y, #64
    60cc:	58a2      	mov	[S-8], YA

000060ce <.LM8>:
    60ce:	7ada 00ff 	lod	Y, #255
    60d2:	5a0b      	mov	[S-12], Y

000060d4 <.L3>:
    60d4:	4cfa 0000 	movs	YA, #0
    60d8:	58a0      	mov	[S-4], YA
    60da:	7a07      	lod	Y, [S-8]
    60dc:	5a03      	mov	[S-4], Y
    60de:	7205      	lod	A, [S-6]
    60e0:	b47f      	and	A, #127
    60e2:	7e01      	lod	X, [S-2]
    60e4:	3480      	and	X, #-128
    60e6:	a6ee      	or	A, X
    60e8:	5201      	mov	[S-2], A

000060ea <.LM10>:
    60ea:	620b      	lod	AL, [S-12]
    60ec:	5cf2      	usex	A
    60ee:	4862 0080 	mulu	A, A, #128
    60f2:	7ae2      	lod	Y, A
    60f4:	7e01      	lod	X, [S-2]
    60f6:	36da 807f 	and	X, #32895
    60fa:	e6ee      	or	Y, X
    60fc:	5a01      	mov	[S-2], Y

000060fe <.LM11>:
    60fe:	720d      	lod	A, [S-14]
    6100:	b401      	and	A, #1
    6102:	4452      	rr	A
    6104:	7ae2      	lod	Y, A
    6106:	7e01      	lod	X, [S-2]
    6108:	36da 7fff 	and	X, #32767
    610c:	e6ee      	or	Y, X
    610e:	5a01      	mov	[S-2], Y

00006110 <.LM12>:
    6110:	58e0      	mov	YA, [S-4]

00006112 <.LM13>:
    6112:	540f      	ret	#16

00006114 <.L2>:
    6114:	ac04      	cmp	A, #4
    6116:	1d01      	jne	0x611a <.LM15>
    6118:	0073      	jmp	0x6200 <.L16>

0000611a <.LM15>:
    611a:	ac02      	cmp	A, #2
    611c:	1d01      	jne	0x6120 <.LM16>
    611e:	0067      	jmp	0x61ee <.L13>

00006120 <.LM16>:
    6120:	58c2      	mov	D, [S-8]
    6122:	4caa 0000 	cmpu	D, #0
    6126:	1d01      	jne	0x612a <.LM17>
    6128:	0068      	jmp	0x61fa <.L14>

0000612a <.LM17>:
    612a:	7efc      	lod	X, [X+4]

0000612c <.LVL12>:
    612c:	2c82      	cmp	X, #-126
    612e:	1a81      	jsl	0x6132 <.LBB10>
    6130:	0039      	jmp	0x61a4 <.L4>

00006132 <.LBB10>:
    6132:	7082      	lod	A, #-126
    6134:	aaee      	sub	A, X
    6136:	7ee2      	lod	X, A

00006138 <.LM19>:
    6138:	ac19      	cmp	A, #25
    613a:	1f2e      	jsg	0x6198 <.L15>

0000613c <.LBB11>:
    613c:	4c80      	mov	YA, D

0000613e <.LVL15>:
    613e:	2c00      	cmp	X, #0
    6140:	1b04      	jsle	0x614a <.L26>
    6142:	5edf      	push	X

00006144 <.L27>:
    6144:	48a0      	lsr	YA, #1
    6146:	1bfe      	djnz	X, 0x6144 <.L27>
    6148:	7ecf      	pop	X

0000614a <.L26>:
    614a:	58a4      	mov	[S-12], YA

0000614c <.LM21>:
    614c:	4cfa ffff 	movs	YA, #65535
    6150:	2c00      	cmp	X, #0
    6152:	1b02      	jsle	0x6158 <.L28>

00006154 <.L29>:
    6154:	48e0      	asl	YA, #1
    6156:	1bfe      	djnz	X, 0x6154 <.L29>

00006158 <.L28>:
    6158:	bcff      	xor	A, #-1
    615a:	fcff      	xor	Y, #-1
    615c:	b607      	and	A, [S-8]
    615e:	f605      	and	Y, [S-6]
    6160:	a6e6      	or	A, Y
    6162:	5ca2      	sne	A
    6164:	4cc8      	movu	D, A

00006166 <.LM22>:
    6166:	4c80      	mov	YA, D
    6168:	a60b      	or	A, [S-12]
    616a:	e609      	or	Y, [S-10]
    616c:	4cc0      	mov	D, YA

0000616e <.L5>:
    616e:	4c80      	mov	YA, D
    6170:	b47f      	and	A, #127
    6172:	7800      	lod	Y, #0
    6174:	4cb2 0040 	cmp	YA, #64
    6178:	0000 
    617a:	1d11      	jne	0x619e <.L6>

0000617c <.LM24>:
    617c:	4c80      	mov	YA, D
    617e:	9480      	and	AL, #-128
    6180:	1902      	je	0x6186 <.L7>

00006182 <.LM25>:
    6182:	4c0a 0040 	addu	D, #64

00006186 <.L7>:
    6186:	4c92 ffff 	cmp	D, #1073741823
    618a:	3fff 
    618c:	5cb4      	sug	Y
    618e:	5a0b      	mov	[S-12], Y

00006190 <.LM27>:
    6190:	4c80      	mov	YA, D

00006192 <.L25>:
    6192:	48a6      	lsr	YA, #7

00006194 <.LVL25>:
    6194:	58a2      	mov	[S-8], YA

00006196 <.LVL26>:
    6196:	079e      	jmp	0x60d4 <.L3>

00006198 <.L15>:
    6198:	4cda 0000 	movs	D, #0
    619c:	07e8      	jmp	0x616e <.L5>

0000619e <.L6>:
    619e:	4c0a 003f 	addu	D, #63
    61a2:	07f1      	jmp	0x6186 <.L7>

000061a4 <.L4>:
    61a4:	2c7f      	cmp	X, #127
    61a6:	1f2c      	jsg	0x6200 <.L16>

000061a8 <.LM32>:
    61a8:	58e2      	mov	YA, [S-8]
    61aa:	b47f      	and	A, #127
    61ac:	7800      	lod	Y, #0
    61ae:	4cb2 0040 	cmp	YA, #64
    61b2:	0000 
    61b4:	1d10      	jne	0x61d6 <.L8>

000061b6 <.LM33>:
    61b6:	58e2      	mov	YA, [S-8]
    61b8:	9480      	and	AL, #-128
    61ba:	1904      	je	0x61c4 <.L9>

000061bc <.LM34>:
    61bc:	58c2      	mov	D, [S-8]
    61be:	4c0a 0040 	addu	D, #64

000061c2 <.L23>:
    61c2:	5882      	mov	[S-8], D

000061c4 <.L9>:
    61c4:	58c2      	mov	D, [S-8]
    61c6:	4caa 0000 	cmpu	D, #0
    61ca:	1a89      	jsl	0x61de <.L10>

000061cc <.LM37>:
    61cc:	72ee      	lod	A, X
    61ce:	a07f      	add	A, #127
    61d0:	520b      	mov	[S-12], A

000061d2 <.L11>:
    61d2:	58e2      	mov	YA, [S-8]
    61d4:	07de      	jmp	0x6192 <.L25>

000061d6 <.L8>:
    61d6:	58c2      	mov	D, [S-8]
    61d8:	4c0a 003f 	addu	D, #63
    61dc:	07f2      	jmp	0x61c2 <.L23>

000061de <.L10>:
    61de:	58e2      	mov	YA, [S-8]
    61e0:	48a0      	lsr	YA, #1
    61e2:	58a2      	mov	[S-8], YA

000061e4 <.LM41>:
    61e4:	7aee      	lod	Y, X
    61e6:	e2da 0080 	add	Y, #128
    61ea:	5a0b      	mov	[S-12], Y

000061ec <.LVL37>:
    61ec:	07f2      	jmp	0x61d2 <.L11>

000061ee <.L13>:
    61ee:	7000      	lod	A, #0
    61f0:	520b      	mov	[S-12], A

000061f2 <.L24>:
    61f2:	4cda 0000 	movs	D, #0
    61f6:	5882      	mov	[S-8], D

000061f8 <.LVL40>:
    61f8:	076d      	jmp	0x60d4 <.L3>

000061fa <.L14>:
    61fa:	7000      	lod	A, #0
    61fc:	520b      	mov	[S-12], A
    61fe:	076a      	jmp	0x60d4 <.L3>

00006200 <.L16>:
    6200:	7ada 00ff 	lod	Y, #255
    6204:	5a0b      	mov	[S-12], Y
    6206:	07f5      	jmp	0x61f2 <.L24>

00006208 <___unpack_f>:
    6208:	5807      	inc	S, #8

0000620a <.LCFI0>:
    620a:	5201      	mov	[S-2], A

0000620c <.LM2>:
    620c:	7ee2      	lod	X, A
    620e:	72de      	lod	A, [X++]

00006210 <.LVL1>:
    6210:	5207      	mov	[S-8], A
    6212:	66f8      	lod	YL, [X]
    6214:	4603      	mov	[S-4], YL
    6216:	f47f      	and	Y, #127
    6218:	5a05      	mov	[S-6], Y

0000621a <.LM3>:
    621a:	7af8      	lod	Y, [X]

0000621c <.LM4>:
    621c:	7e01      	lod	X, [S-2]
    621e:	62fb      	lod	AL, [X+3]

00006220 <.LM5>:
    6220:	4440      	rl	AL
    6222:	9401      	and	AL, #1
    6224:	5cf2      	usex	A

00006226 <.LM6>:
    6226:	7e0b      	lod	X, [S-12]

00006228 <.LM7>:
    6228:	52fa      	mov	[X+2], A

0000622a <.LM8>:
    622a:	72e6      	lod	A, Y
    622c:	44b2      	lsr	A, #2
    622e:	44b2      	lsr	A, #2
    6230:	44b2      	lsr	A, #2
    6232:	4432      	lsr	A
    6234:	b6da 00ff 	and	A, #255

00006238 <.LVL4>:
    6238:	f6da 7f80 	and	Y, #32640
    623c:	1d19      	jne	0x6270 <.L2>

0000623e <.LM9>:
    623e:	58c2      	mov	D, [S-8]
    6240:	4caa 0000 	cmpu	D, #0
    6244:	1d03      	jne	0x624c <.L3>

00006246 <.LM10>:
    6246:	7002      	lod	A, #2

00006248 <.L12>:
    6248:	52f8      	mov	[X], A
    624a:	5409      	ret	#10

0000624c <.L3>:
    624c:	58c2      	mov	D, [S-8]

0000624e <.LVL7>:
    624e:	48c6      	asl	D, #7

00006250 <.LM13>:
    6250:	7e0b      	lod	X, [S-12]
    6252:	7803      	lod	Y, #3
    6254:	5af8      	mov	[X], Y
    6256:	7c81      	lod	X, #-127

00006258 <.L5>:
    6258:	48c0      	asl	D, #1

0000625a <.LM15>:
    625a:	7aee      	lod	Y, X
    625c:	20ff      	add	X, #-1

0000625e <.LM16>:
    625e:	4c92 ffff 	cmp	D, #1073741823
    6262:	3fff 
    6264:	1a79      	jule	0x6258 <.L5>
    6266:	7e0b      	lod	X, [S-12]
    6268:	5afc      	mov	[X+4], Y

0000626a <.LM17>:
    626a:	2006      	add	X, #6
    626c:	4c87      	mov	[X], D
    626e:	5409      	ret	#10

00006270 <.L2>:
    6270:	aeda 00ff 	cmp	A, #255
    6274:	1d1c      	jne	0x62ae <.L6>

00006276 <.LM19>:
    6276:	58c2      	mov	D, [S-8]
    6278:	4caa 0000 	cmpu	D, #0
    627c:	1d03      	jne	0x6284 <.L7>

0000627e <.LM20>:
    627e:	7e0b      	lod	X, [S-12]
    6280:	7004      	lod	A, #4

00006282 <.LVL11>:
    6282:	07e2      	jmp	0x6248 <.L12>

00006284 <.L7>:
    6284:	58e2      	mov	YA, [S-8]

00006286 <.LVL13>:
    6286:	7000      	lod	A, #0
    6288:	f440      	and	Y, #64

0000628a <.LM22>:
    628a:	7e0b      	lod	X, [S-12]

0000628c <.LM23>:
    628c:	4cb2 0000 	cmp	YA, #0
    6290:	0000 
    6292:	190b      	je	0x62aa <.L8>

00006294 <.LM24>:
    6294:	7001      	lod	A, #1

00006296 <.L11>:
    6296:	52f8      	mov	[X], A

00006298 <.LM26>:
    6298:	7e0b      	lod	X, [S-12]
    629a:	2006      	add	X, #6
    629c:	58e2      	mov	YA, [S-8]
    629e:	48e6      	asl	YA, #7
    62a0:	9480      	and	AL, #-128
    62a2:	f6da dfff 	and	Y, #57343

000062a6 <.L13>:
    62a6:	4ca7      	mov	[X], YA

000062a8 <.LM28>:
    62a8:	5409      	ret	#10

000062aa <.L8>:
    62aa:	7000      	lod	A, #0
    62ac:	07f4      	jmp	0x6296 <.L11>

000062ae <.L6>:
    62ae:	a081      	add	A, #-127

000062b0 <.LVL18>:
    62b0:	7e0b      	lod	X, [S-12]
    62b2:	52fc      	mov	[X+4], A

000062b4 <.LM31>:
    62b4:	7003      	lod	A, #3
    62b6:	52f8      	mov	[X], A

000062b8 <.LM32>:
    62b8:	2006      	add	X, #6
    62ba:	58e2      	mov	YA, [S-8]
    62bc:	48e6      	asl	YA, #7
    62be:	e6da 4000 	or	Y, #16384
    62c2:	07f1      	jmp	0x62a6 <.L13>

000062c4 <___fpcmp_parts_f>:
    62c4:	5803      	inc	S, #4

000062c6 <.LCFI0>:
    62c6:	5201      	mov	[S-2], A

000062c8 <.LM2>:
    62c8:	7ee2      	lod	X, A
    62ca:	72f8      	lod	A, [X]

000062cc <.LVL1>:
    62cc:	ac01      	cmp	A, #1
    62ce:	1a14      	jule	0x62f8 <.L22>

000062d0 <.LM3>:
    62d0:	7e07      	lod	X, [S-8]

000062d2 <.LM4>:
    62d2:	7af8      	lod	Y, [X]
    62d4:	ec01      	cmp	Y, #1
    62d6:	1a10      	jule	0x62f8 <.L22>

000062d8 <.LM5>:
    62d8:	ac04      	cmp	A, #4
    62da:	1d09      	jne	0x62ee <.L3>
    62dc:	7e01      	lod	X, [S-2]
    62de:	72fa      	lod	A, [X+2]

000062e0 <.LM6>:
    62e0:	ec04      	cmp	Y, #4
    62e2:	1d16      	jne	0x6310 <.L33>

000062e4 <.LM7>:
    62e4:	7e07      	lod	X, [S-8]
    62e6:	7efa      	lod	X, [X+2]
    62e8:	2ae2      	sub	X, A
    62ea:	72ee      	lod	A, X
    62ec:	5405      	ret	#6

000062ee <.L3>:
    62ee:	ec04      	cmp	Y, #4
    62f0:	1d05      	jne	0x62fc <.L5>

000062f2 <.L7>:
    62f2:	7e07      	lod	X, [S-8]
    62f4:	72fa      	lod	A, [X+2]
    62f6:	190e      	je	0x6314 <.L24>

000062f8 <.L22>:
    62f8:	7001      	lod	A, #1
    62fa:	5405      	ret	#6

000062fc <.L5>:
    62fc:	ac02      	cmp	A, #2
    62fe:	1d04      	jne	0x6308 <.L6>

00006300 <.LM12>:
    6300:	ec02      	cmp	Y, #2
    6302:	1d77      	jne	0x62f2 <.L7>

00006304 <.L23>:
    6304:	7000      	lod	A, #0
    6306:	5405      	ret	#6

00006308 <.L6>:
    6308:	7e01      	lod	X, [S-2]
    630a:	72fa      	lod	A, [X+2]

0000630c <.LM14>:
    630c:	ec02      	cmp	Y, #2
    630e:	1d04      	jne	0x6318 <.L8>

00006310 <.L33>:
    6310:	ac00      	cmp	A, #0
    6312:	1972      	je	0x62f8 <.L22>

00006314 <.L24>:
    6314:	70ff      	lod	A, #-1

00006316 <.LM17>:
    6316:	5405      	ret	#6

00006318 <.L8>:
    6318:	7e07      	lod	X, [S-8]
    631a:	7efa      	lod	X, [X+2]
    631c:	5e03      	mov	[S-4], X
    631e:	2ee2      	cmp	X, A
    6320:	1d77      	jne	0x6310 <.L33>

00006322 <.LM19>:
    6322:	7e01      	lod	X, [S-2]
    6324:	7afc      	lod	Y, [X+4]
    6326:	7e07      	lod	X, [S-8]
    6328:	72fc      	lod	A, [X+4]
    632a:	eee2      	cmp	Y, A
    632c:	1b02      	jsle	0x6332 <.L10>

0000632e <.L35>:
    632e:	7203      	lod	A, [S-4]
    6330:	07ef      	jmp	0x6310 <.L33>

00006332 <.L10>:
    6332:	eee2      	cmp	Y, A
    6334:	1e83      	jsge	0x633c <.L11>

00006336 <.L27>:
    6336:	7e03      	lod	X, [S-4]
    6338:	1d5f      	jne	0x62f8 <.L22>
    633a:	07ec      	jmp	0x6314 <.L24>

0000633c <.L11>:
    633c:	7e01      	lod	X, [S-2]
    633e:	2006      	add	X, #6
    6340:	4cc7      	mov	D, [X]
    6342:	7e07      	lod	X, [S-8]
    6344:	2006      	add	X, #6
    6346:	4ce7      	mov	YA, [X]
    6348:	4c90      	cmp	D, YA
    634a:	1e71      	jug	0x632e <.L35>

0000634c <.LM24>:
    634c:	1874      	jc	0x6336 <.L27>
    634e:	07da      	jmp	0x6304 <.L23>

00006350 <_AppLinInit>:
    6350:	6000      	lod	AL, #0
    6352:	42d8 10ad 	mov	0x10ad <_Fwv_lin_sleep_enable>, AL

00006356 <.LM3>:
    6356:	42d8 10ac 	mov	0x10ac <_Fwv_lin_frame_Error>, AL

0000635a <.LM4>:
    635a:	5401      	ret

0000635c <_AppLinTask>:
}

void AppLinTask(void)
{

	if (g_u8LinErrorCnt > (uint8_t)3u)
    635c:	62d8 1187 	lod	AL, 0x1187 <_g_u8LinErrorCnt>
    6360:	8c03      	cmp	AL, #3
    6362:	1a03      	jule	0x636a <.L3>

00006364 <.LM7>:
	{
		Fwv_lin_frame_Error = 1;
    6364:	6001      	lod	AL, #1
    6366:	42d8 10ac 	mov	0x10ac <_Fwv_lin_frame_Error>, AL

0000636a <.L3>:
L_FLAGS(l_sl1_flags.mapped, s_d_debug_1, signal, d_debug_1)
L_FLAGS(l_sl1_flags.mapped, s_d_debug_2, signal, d_debug_2)

L_FLAGS(l_sl1_flags.mapped, f_VPC_Fwv_Resp, frame, VPC_Fwv_Resp)
L_FLAGS(l_sl1_flags.mapped, f_Debug_Frame, frame, Debug_Frame)
L_FLAGS(l_sl1_flags.mapped, f_VPC_Fwv_Ctrl, frame, VPC_Fwv_Ctrl)
    636a:	62d8 13d9 	lod	AL, 0x13d9 <_l_sl1_flags+0x3>

0000636e <.LBE14>:
	}

	/* VPC_Fwv_Master Frame handling */
	if (l_flg_tst_f_VPC_Fwv_Ctrl() != 0u)
    636e:	9440      	and	AL, #64
    6370:	1915      	je	0x639c <.L4>

00006372 <.LBB16>:
    6372:	82db 4798 	callf	0x8f30 <_l_sys_irq_disable>
    6376:	7ee2      	lod	X, A

00006378 <.LVL1>:
    6378:	62d8 13d9 	lod	AL, 0x13d9 <_l_sl1_flags+0x3>

0000637c <.LVL2>:
    637c:	94bf      	and	AL, #-65
    637e:	42d8 13d9 	mov	0x13d9 <_l_sl1_flags+0x3>, AL
    6382:	72ee      	lod	A, X
    6384:	82db 47a0 	callf	0x8f40 <_l_sys_irq_restore>

00006388 <.LBE16>:
	{
		l_flg_clr_f_VPC_Fwv_Ctrl();
		ValveLinGetCommand();
    6388:	10a3      	call	0x64d0 <_ValveLinGetCommand>

0000638a <.LM12>:
		Fwv_Request_Event = 1;
    638a:	6001      	lod	AL, #1
    638c:	42d8 10ab 	mov	0x10ab <_Fwv_Request_Event>, AL

00006390 <.LM13>:
		g_u8LinErrorCnt = 0;
    6390:	6000      	lod	AL, #0
    6392:	0ea7      	lod	C, ML.7
    6394:	42d8 1187 	mov	0x1187 <_g_u8LinErrorCnt>, AL

00006398 <.LM14>:
		Fwv_lin_frame_Error = 0;
    6398:	42d8 10ac 	mov	0x10ac <_Fwv_lin_frame_Error>, AL

0000639c <.L4>:
L_FLAGS(l_sl1_flags.mapped, s_d_valve_status, signal, d_valve_status)
L_FLAGS(l_sl1_flags.mapped, s_d_motor_status, signal, d_motor_status)
L_FLAGS(l_sl1_flags.mapped, s_d_debug_1, signal, d_debug_1)
L_FLAGS(l_sl1_flags.mapped, s_d_debug_2, signal, d_debug_2)

L_FLAGS(l_sl1_flags.mapped, f_VPC_Fwv_Resp, frame, VPC_Fwv_Resp)
    639c:	62d8 13d9 	lod	AL, 0x13d9 <_l_sl1_flags+0x3>

000063a0 <.LBE18>:
	}

	/* VPC_Fwv_Slave Frame handling */
	if (l_flg_tst_f_VPC_Fwv_Resp() != 0u)
    63a0:	9410      	and	AL, #16
    63a2:	1915      	je	0x63ce <.L5>

000063a4 <.LBB20>:
    63a4:	82db 4798 	callf	0x8f30 <_l_sys_irq_disable>
    63a8:	7ee2      	lod	X, A

000063aa <.LVL6>:
    63aa:	62d8 13d9 	lod	AL, 0x13d9 <_l_sl1_flags+0x3>

000063ae <.LVL7>:
    63ae:	94ef      	and	AL, #-17
    63b0:	42d8 13d9 	mov	0x13d9 <_l_sl1_flags+0x3>, AL
    63b4:	72ee      	lod	A, X
    63b6:	82db 47a0 	callf	0x8f40 <_l_sys_irq_restore>

000063ba <.LBE20>:
	{
		l_flg_clr_f_VPC_Fwv_Resp();
		ValveLinUpdateSignals();
    63ba:	10b8      	call	0x652c <_ValveLinUpdateSignals>

000063bc <.LM19>:
		Fwv_Response_Event = 1;
    63bc:	6001      	lod	AL, #1
    63be:	42d8 10aa 	mov	0x10aa <__data_end>, AL

000063c2 <.LM20>:
		g_u8LinErrorCnt = 0;
    63c2:	6000      	lod	AL, #0
    63c4:	0ea7      	lod	C, ML.7
    63c6:	42d8 1187 	mov	0x1187 <_g_u8LinErrorCnt>, AL

000063ca <.LM21>:
		Fwv_lin_frame_Error = 0;
    63ca:	42d8 10ac 	mov	0x10ac <_Fwv_lin_frame_Error>, AL

000063ce <.L5>:
		l_u8_wr_DEBUG1_U8_8((uint8_t)(g_u16DebugData[3] >> 8));
		*/
	}
#endif
	/* do lin period (non time critical) stuff */
	lin22_BackgroundHandler();
    63ce:	76da 469b 	jmpf	0x8d36 <_lin22_BackgroundHandler>

000063d2 <_AppLinSleepEnter>:
}

void AppLinSleepEnter(void)
{
	Fwv_lin_sleep_enable = 1;
    63d2:	6001      	lod	AL, #1
    63d4:	42d8 10ad 	mov	0x10ad <_Fwv_lin_sleep_enable>, AL

000063d8 <.LM26>:
	lin22_GotoSleep(); /* switch to sleep mode */
    63d8:	76da 46cd 	jmpf	0x8d9a <_lin22_GotoSleep>

000063dc <_check_protect_mode>:
	return status;
}
static uint16_t check_protect_mode(void)
{
	uint16_t status = 0;
	if ((valve.diag.vs.state == VS_UNDERVOLTAGE) || (valve.diag.vs.state == VS_OVERVOLTAGE) || (valve.diag.temp.state == TEMPERATURE_HIGH))
    63dc:	72d8 1238 	lod	A, 0x1238 <.LLST0+0x6>
    63e0:	a0ff      	add	A, #-1
    63e2:	ac01      	cmp	A, #1
    63e4:	1a1e      	jule	0x6422 <.L8>

000063e6 <.LM3>:
    63e6:	72d8 1244 	lod	A, 0x1244 <.LLST0+0x12>

000063ea <.LM4>:
	}
	return status;
}
static uint16_t check_protect_mode(void)
{
	uint16_t status = 0;
    63ea:	ac02      	cmp	A, #2
    63ec:	5c8e      	se	X

000063ee <.L2>:
	if ((valve.diag.vs.state == VS_UNDERVOLTAGE) || (valve.diag.vs.state == VS_OVERVOLTAGE) || (valve.diag.temp.state == TEMPERATURE_HIGH))
	{
		status = 1;
	}
	if ((valve.diag.stallFault & STALL_MASK_TEMPORARY) != 0)
    63ee:	62d8 1264 	lod	AL, 0x1264 <.LLST6+0x12>
    63f2:	9401      	and	AL, #1
    63f4:	1901      	je	0x63f8 <.L3>

000063f6 <.LM6>:
	{
		status = 1;
    63f6:	7c01      	lod	X, #1

000063f8 <.L3>:
	}
	if ((valve.diag.motorFault & FAULT_MASK_OVER_CURRENT) != 0)
    63f8:	62d8 1263 	lod	AL, 0x1263 <.LLST6+0x11>
    63fc:	9440      	and	AL, #64
    63fe:	1901      	je	0x6402 <.L4>

00006400 <.LM8>:
	{
		status = 1;
    6400:	7c01      	lod	X, #1

00006402 <.L4>:
	}
	if (valve.diag.McuFault != 0)
    6402:	62d8 125c 	lod	AL, 0x125c <.LLST6+0xa>
    6406:	1901      	je	0x640a <.L5>

00006408 <.LM10>:
	{
		status = 1;
    6408:	7c01      	lod	X, #1

0000640a <.L5>:
	}
#if 1
	if ((valve.diag.gmr.state != 0) || (valve.pos.fault != 0))
    640a:	62d8 1252 	lod	AL, 0x1252 <.LLST6>
    640e:	1d0b      	jne	0x6426 <.L10>

00006410 <.LM12>:
    6410:	62d8 120e 	lod	AL, 0x120e <.LLST4+0x6>
    6414:	1d08      	jne	0x6426 <.L10>

00006416 <.L6>:
	{
		status = 1;
	}
#endif
	if (valve.linLiveTimeOut == 0)
    6416:	72d8 11fc 	lod	A, 0x11fc <_valve+0x4>
    641a:	1d01      	jne	0x641e <.L1>

0000641c <.LM14>:
	{
		status = 1;
    641c:	7c01      	lod	X, #1

0000641e <.L1>:
	}
	return status;
}
    641e:	72ee      	lod	A, X
    6420:	5401      	ret

00006422 <.L8>:
static uint16_t check_protect_mode(void)
{
	uint16_t status = 0;
	if ((valve.diag.vs.state == VS_UNDERVOLTAGE) || (valve.diag.vs.state == VS_OVERVOLTAGE) || (valve.diag.temp.state == TEMPERATURE_HIGH))
	{
		status = 1;
    6422:	7c01      	lod	X, #1
    6424:	07e4      	jmp	0x63ee <.L2>

00006426 <.L10>:
		status = 1;
	}
#if 1
	if ((valve.diag.gmr.state != 0) || (valve.pos.fault != 0))
	{
		status = 1;
    6426:	7c01      	lod	X, #1

00006428 <.LVL9>:
    6428:	07f6      	jmp	0x6416 <.L6>

0000642a <_ValveFaultReset>:
	if (valve.state == VALVE_FAULT)
	{
	}
}
static void ValveFaultReset(void)
{
    642a:	5801      	inc	S, #2

0000642c <.LCFI0>:
	u16EventState = NONE_ERROR;
    642c:	7800      	lod	Y, #0
    642e:	5ad8 10b6 	mov	0x10b6 <_u16EventState>, Y

00006432 <.LM20>:
	valve.comm.faultMode = 0;
    6432:	46d8 1227 	mov	0x1227 <.LLST6+0x8>, YL

00006436 <.LM21>:
	MotClearFaultFlag(0);
    6436:	72e6      	lod	A, Y
    6438:	5a01      	mov	[S-2], Y
    643a:	82db 3e48 	callf	0x7c90 <_MotClearFaultFlag>

0000643e <.LM22>:
	MotClearStallFlag(0);
    643e:	7a01      	lod	Y, [S-2]
    6440:	72e6      	lod	A, Y
    6442:	82db 3e39 	callf	0x7c72 <_MotClearStallFlag>

00006446 <.LM23>:
	valve.pos.fault = 0;
	valve.diag.gmr.state = 0;
	valve.diag.McuFault = 0;

	valve.diag.motOcRetryCnt = 0;
    6446:	7a01      	lod	Y, [S-2]
    6448:	46d8 1267 	mov	0x1267 <.LLST6+0x15>, YL

0000644c <.LM24>:
{
	u16EventState = NONE_ERROR;
	valve.comm.faultMode = 0;
	MotClearFaultFlag(0);
	MotClearStallFlag(0);
	valve.pos.fault = 0;
    644c:	5ad8 120e 	mov	0x120e <.LLST4+0x6>, Y

00006450 <.LM25>:
	valve.diag.gmr.state = 0;
    6450:	5ad8 1252 	mov	0x1252 <.LLST6>, Y

00006454 <.LM26>:
	valve.diag.McuFault = 0;
    6454:	0ea7      	lod	C, ML.7
    6456:	5ad8 125c 	mov	0x125c <.LLST6+0xa>, Y

0000645a <.LM27>:

	valve.diag.motOcRetryCnt = 0;
	valve.diag.ObstructionRetryCnt = 0;
	valve.pos.retryCnt = 0;
	valve.diag.gmr.retryCnt = 0;
	valve.diag.mcuRetryCnt = 0;
    645a:	46d8 125e 	mov	0x125e <.LLST6+0xc>, YL

0000645e <.LM28>:
	valve.diag.vs.UVretryCnt = 0;
    645e:	5ad8 1240 	mov	0x1240 <.LLST0+0xe>, Y

00006462 <.LM29>:
	valve.diag.vs.OVretryCnt = 0;
    6462:	0ea7      	lod	C, ML.7
    6464:	5ad8 1242 	mov	0x1242 <.LLST0+0x10>, Y

00006468 <.LM30>:
	valve.diag.temp.retryCnt = 0;
    6468:	5ad8 1246 	mov	0x1246 <.LLST0+0x14>, Y

0000646c <.LM31>:
}
    646c:	5403      	ret	#4

0000646e <_ValveErrorReset>:
	} diag;
} valve;

static void ValveErrorReset(void)
{
	if (valve.state == VALVE_PROTECTION)
    646e:	72d8 11f8 	lod	A, 0x11f8 <_valve>
    6472:	ac07      	cmp	A, #7
    6474:	1d15      	jne	0x64a0 <.L21>

00006476 <.LM34>:
	{

		valve.diag.motOcRetryCnt = 0;
    6476:	6000      	lod	AL, #0
    6478:	42d8 1267 	mov	0x1267 <.LLST6+0x15>, AL

0000647c <.LM35>:
		valve.diag.ObstructionRetryCnt = 0;
    647c:	42d8 125e 	mov	0x125e <.LLST6+0xc>, AL

00006480 <.LM36>:
		valve.pos.retryCnt = 0;
    6480:	0ea7      	lod	C, ML.7
    6482:	42d8 120f 	mov	0x120f <.LLST4+0x7>, AL

00006486 <.LM37>:
		valve.diag.gmr.retryCnt = 0;
    6486:	42d8 1253 	mov	0x1253 <.LLST6+0x1>, AL

0000648a <.LM38>:
		valve.diag.mcuRetryCnt = 0;
    648a:	42d8 125d 	mov	0x125d <.LLST6+0xb>, AL

0000648e <.LM39>:
		valve.diag.vs.UVretryCnt = 0;
    648e:	0ea7      	lod	C, ML.7
    6490:	7000      	lod	A, #0
    6492:	52d8 1240 	mov	0x1240 <.LLST0+0xe>, A

00006496 <.LM40>:
		valve.diag.vs.OVretryCnt = 0;
    6496:	52d8 1242 	mov	0x1242 <.LLST0+0x10>, A

0000649a <.LM41>:
		valve.diag.temp.retryCnt = 0;
    649a:	0ea7      	lod	C, ML.7
    649c:	52d8 1246 	mov	0x1246 <.LLST0+0x14>, A

000064a0 <.L21>:
	}
	if (valve.state == VALVE_FAULT)
	{
	}
}
    64a0:	5401      	ret

000064a2 <_check_fault_mode>:
	return nextState;
}
static uint16_t check_fault_mode(void)
{
	uint16_t status = 0;
	if (valve.motorMotion == MOTION_FAULT)
    64a2:	72d8 1204 	lod	A, 0x1204 <_valve+0xc>
    64a6:	ac07      	cmp	A, #7
    64a8:	1d05      	jne	0x64b4 <.L24>

000064aa <.LM45>:

		if ((valve.diag.motorFault & FAULT_MASK_PHASE_A_OPEN) != 0)
		{
			status = 1;
		}
		else if ((valve.diag.motorFault & FAULT_MASK_PHASE_A_SHORT) != 0)
    64aa:	62d8 1263 	lod	AL, 0x1263 <.LLST6+0x11>
    64ae:	9411      	and	AL, #17

000064b0 <.LM46>:
		{
			status = 1;
    64b0:	5ca2      	sne	A
    64b2:	5401      	ret

000064b4 <.L24>:
		else
		{
			status = 0;
		}
	}
	else if (valve.motorMotion == MOTION_STALL)
    64b4:	ac06      	cmp	A, #6
    64b6:	1d0a      	jne	0x64cc <.L27>

000064b8 <.LM48>:
	{

		if (valve.state != VALVE_CALIBRATION)
    64b8:	72d8 11f8 	lod	A, 0x11f8 <_valve>
    64bc:	ac05      	cmp	A, #5
    64be:	1906      	je	0x64cc <.L27>

000064c0 <.LBB121>:
		{
			if ((valve.diag.stallFault & STALL_MASK_PERMENT) != 0)
    64c0:	62d8 1264 	lod	AL, 0x1264 <.LLST6+0x12>
    64c4:	4430      	lsr	AL
    64c6:	9401      	and	AL, #1
    64c8:	5cf2      	usex	A
    64ca:	5401      	ret

000064cc <.L27>:
			status = 0;
		}
	}
	else
	{
		status = 0;
    64cc:	7000      	lod	A, #0

000064ce <.LM51>:
	}
	return status;
}
    64ce:	5401      	ret

000064d0 <_ValveLinGetCommand>:
}
void ValveLinGetCommand(void)
{
	int16_t pos;

	valve.comm.Enable = l_bool_rd_Fwv_MoveEnable();
    64d0:	62d8 1195 	lod	AL, 0x1195 <_l_signals+0x1>
    64d4:	42d8 1221 	mov	0x1221 <.LLST6+0x2>, AL

000064d8 <.LBB122>:
 * Define API functions using templates
 */

L_SIGNAL(l_u8, Fwv_Target_Mode)
L_SIGNAL(l_bool, Fwv_MoveEnable)
L_SIGNAL(l_bool, Fwv_Initial)
    64d8:	66d8 1196 	lod	YL, 0x1196 <_l_signals+0x2>

000064dc <.LBE122>:

	if (l_bool_rd_Fwv_Initial() != valve.comm.Initial)
    64dc:	0ea7      	lod	C, ML.7
    64de:	62d8 1222 	lod	AL, 0x1222 <.LLST6+0x3>
    64e2:	8ee8      	cmp	AL, YL
    64e4:	1909      	je	0x64f8 <.L30>

000064e6 <.LBB124>:
    64e6:	62d8 1196 	lod	AL, 0x1196 <_l_signals+0x2>

000064ea <.LBE124>:
	{
		valve.comm.Initial = l_bool_rd_Fwv_Initial();
    64ea:	42d8 1222 	mov	0x1222 <.LLST6+0x3>, AL

000064ee <.LM58>:
		if (valve.comm.Initial)
    64ee:	1904      	je	0x64f8 <.L30>

000064f0 <.LM59>:
		{
			valve.calibration.req2Cal = 1;
    64f0:	6001      	lod	AL, #1
    64f2:	42d8 1212 	mov	0x1212 <.LLST4+0xa>, AL

000064f6 <.LM60>:
			ValveFaultReset();
    64f6:	1799      	call	0x642a <_ValveFaultReset>

000064f8 <.L30>:
L_SIGNAL(l_bool, Fwv_ForcedDiag)
    64f8:	62d8 1197 	lod	AL, 0x1197 <_l_signals+0x3>

000064fc <.LBE126>:
		}
	}

	valve.comm.ForcedDiag = l_bool_rd_Fwv_ForcedDiag();
    64fc:	42d8 1223 	mov	0x1223 <.LLST6+0x4>, AL

00006500 <.LM63>:

	if ((valve.comm.ForcedDiag == 0) && (valve.comm.Enable != 0))
    6500:	1d0f      	jne	0x6520 <.L28>

00006502 <.LM64>:
    6502:	62d8 1221 	lod	AL, 0x1221 <.LLST6+0x2>
    6506:	190c      	je	0x6520 <.L28>

00006508 <.LBB128>:

/*
 * Define API functions using templates
 */

L_SIGNAL(l_u8, Fwv_Target_Mode)
    6508:	62d8 1194 	lod	AL, 0x1194 <_l_signals>

0000650c <.LBE128>:
	{

		valve.comm.targetMode = l_u8_rd_Fwv_Target_Mode();
    650c:	42d8 1220 	mov	0x1220 <.LLST6+0x1>, AL

00006510 <.LM67>:
		if (valve.comm.targetMode == C_MODE_A)
    6510:	66e0      	lod	YL, AL
    6512:	5cf6      	usex	Y
    6514:	8c00      	cmp	AL, #0
    6516:	1d05      	jne	0x6522 <.L35>

00006518 <.LBB130>:

#endif
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    6518:	72d8 120a 	lod	A, 0x120a <.LLST4+0x2>

0000651c <.L42>:
    651c:	52d8 1206 	mov	0x1206 <_valve+0xe>, A

00006520 <.L28>:
#endif
	}
	else
	{
	}
}
    6520:	5401      	ret

00006522 <.L35>:
		if (valve.comm.targetMode == C_MODE_A)
		{
			pos = valve.pos.modeAngle[C_MODE_A];
			ValveTargetAngleUpdate(pos);
		}
		else if (valve.comm.targetMode == C_MODE_B)
    6522:	ec01      	cmp	Y, #1
    6524:	1d7d      	jne	0x6520 <.L28>

00006526 <.LM71>:

#endif
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    6526:	72d8 120c 	lod	A, 0x120c <.LLST4+0x4>
    652a:	07f8      	jmp	0x651c <.L42>

0000652c <_ValveLinUpdateSignals>:
	else
	{
	}
}
void ValveLinUpdateSignals(void) /*20250714*/
{
    652c:	5805      	inc	S, #6

0000652e <.LBB136>:
L_SIGNAL(l_bool, Fwv_MoveEnable)
L_SIGNAL(l_bool, Fwv_Initial)
L_SIGNAL(l_bool, Fwv_ForcedDiag)
L_SIGNAL(l_u8, Fwv_Reserved1)
L_SIGNAL(l_u8, Fwv_Actual_Mode)
    652e:	62d8 1225 	lod	AL, 0x1225 <.LLST6+0x6>
    6532:	42d8 1199 	mov	0x1199 <_l_signals+0x5>, AL

00006536 <.LBE136>:
	/* Byte 0 */
	l_u8_wr_Fwv_Actual_Mode(valve.comm.actualMode);

	l_bool_wr_Fwv_Position_Fault(valve.pos.fault);
    6536:	62d8 120e 	lod	AL, 0x120e <.LLST4+0x6>
    653a:	5ca2      	sne	A

0000653c <.LBB138>:
L_SIGNAL(l_bool, Fwv_Position_Fault)
    653c:	42d8 119a 	mov	0x119a <_l_signals+0x6>, AL

00006540 <.LBE138>:
	//	if (valve.state==VALVE_FAULT)
	if (valve.comm.faultMode != 0) /*20250714*/
    6540:	66d8 1227 	lod	YL, 0x1227 <.LLST6+0x8>
    6544:	62e8      	lod	AL, YL
    6546:	5cf2      	usex	A
    6548:	7ee2      	lod	X, A
    654a:	62e8      	lod	AL, YL
    654c:	190f      	je	0x656c <.L44>

0000654e <.LBB140>:
L_SIGNAL(l_bool, Fwv_FaultMode)
    654e:	6001      	lod	AL, #1
    6550:	42d8 119b 	mov	0x119b <_l_signals+0x7>, AL

00006554 <.L45>:
	}
	else
	{
		l_bool_wr_Fwv_FaultMode(0);
	}
	if (valve.state == VALVE_PROTECTION)
    6554:	72d8 11f8 	lod	A, 0x11f8 <_valve>
    6558:	5205      	mov	[S-6], A
    655a:	ac07      	cmp	A, #7
    655c:	1d0c      	jne	0x6576 <.L46>

0000655e <.LM79>:
	{
		if (valve.comm.faultMode == 0) /*20250714*/
    655e:	2c00      	cmp	X, #0
    6560:	1d08      	jne	0x6572 <.L47>

00006562 <.LBB142>:
L_SIGNAL(l_bool, Fwv_ProtectMode)
    6562:	6001      	lod	AL, #1

00006564 <.L91>:
    6564:	42d8 119c 	mov	0x119c <_l_signals+0x8>, AL

00006568 <.L48>:
L_SIGNAL(l_bool, Fwv_InitialSta)
    6568:	6000      	lod	AL, #0
    656a:	000f      	jmp	0x658a <.L92>

0000656c <.L44>:
L_SIGNAL(l_bool, Fwv_Initial)
L_SIGNAL(l_bool, Fwv_ForcedDiag)
L_SIGNAL(l_u8, Fwv_Reserved1)
L_SIGNAL(l_u8, Fwv_Actual_Mode)
L_SIGNAL(l_bool, Fwv_Position_Fault)
L_SIGNAL(l_bool, Fwv_FaultMode)
    656c:	46d8 119b 	mov	0x119b <_l_signals+0x7>, YL
    6570:	07f1      	jmp	0x6554 <.L45>

00006572 <.L47>:
L_SIGNAL(l_bool, Fwv_ProtectMode)
    6572:	6000      	lod	AL, #0
    6574:	07f7      	jmp	0x6564 <.L91>

00006576 <.L46>:
    6576:	6000      	lod	AL, #0
    6578:	42d8 119c 	mov	0x119c <_l_signals+0x8>, AL

0000657c <.LBE153>:
	}
	else
	{
		l_bool_wr_Fwv_ProtectMode(0);
	}
	if ((valve.state == VALVE_CALIBRATION) && (valve.comm.Initial == 1))
    657c:	7205      	lod	A, [S-6]
    657e:	ac05      	cmp	A, #5
    6580:	1d73      	jne	0x6568 <.L48>

00006582 <.LM85>:
    6582:	62d8 1222 	lod	AL, 0x1222 <.LLST6+0x3>
    6586:	8c01      	cmp	AL, #1
    6588:	1d6f      	jne	0x6568 <.L48>

0000658a <.L92>:
L_SIGNAL(l_bool, Fwv_InitialSta)
    658a:	42d8 119d 	mov	0x119d <_l_signals+0x9>, AL

0000658e <.LM87>:
	}
	else
	{
		l_bool_wr_Fwv_InitialSta(0);
	}
	if (valve.comm.faultMode != 0) /*20250714*/
    658e:	2c00      	cmp	X, #0
    6590:	191a      	je	0x65c6 <.L50>

00006592 <.LM88>:
	{
		if (valve.diag.calFault != 0)
    6592:	62d8 1262 	lod	AL, 0x1262 <.LLST6+0x10>
    6596:	1901      	je	0x659a <.L51>

00006598 <.LBB156>:
L_SIGNAL(l_bool, Fwv_Calibration_Fail)
    6598:	6001      	lod	AL, #1

0000659a <.L51>:
    659a:	42d8 119e 	mov	0x119e <_l_signals+0xa>, AL

0000659e <.L52>:
	{
		l_bool_wr_Fwv_Calibration_Fail(0);
	}

	/* Byte 1 */
	l_bool_wr_Fwv_MoveEnable_Status(valve.comm.moving);
    659e:	62d8 1226 	lod	AL, 0x1226 <.LLST6+0x7>
    65a2:	5ca2      	sne	A

000065a4 <.LBB160>:
L_SIGNAL(l_bool, Fwv_MoveEnable_Status)
    65a4:	42d8 119f 	mov	0x119f <_l_signals+0xb>, AL

000065a8 <.LVL35>:
    65a8:	62d8 1264 	lod	AL, 0x1264 <.LLST6+0x12>
    65ac:	66e0      	lod	YL, AL
    65ae:	5cf6      	usex	Y
    65b0:	5a01      	mov	[S-2], Y

000065b2 <.LBE160>:

	if (valve.motorMotion == MOTION_FAULT) /*20250714*/
    65b2:	7ad8 1204 	lod	Y, 0x1204 <_valve+0xc>
    65b6:	ec07      	cmp	Y, #7
    65b8:	1d26      	jne	0x6606 <.L53>

000065ba <.LM93>:
	{
		if ((valve.diag.stallFault != 0) && (valve.comm.faultMode != 0))
    65ba:	7201      	lod	A, [S-2]
    65bc:	1907      	je	0x65cc <.L54>

000065be <.LM94>:
    65be:	2c00      	cmp	X, #0
    65c0:	1905      	je	0x65cc <.L54>

000065c2 <.L100>:
L_SIGNAL(l_bool, Fwv_Motor_Stall)
    65c2:	6001      	lod	AL, #1
    65c4:	0004      	jmp	0x65ce <.L93>

000065c6 <.L50>:
L_SIGNAL(l_u8, Fwv_Actual_Mode)
L_SIGNAL(l_bool, Fwv_Position_Fault)
L_SIGNAL(l_bool, Fwv_FaultMode)
L_SIGNAL(l_bool, Fwv_ProtectMode)
L_SIGNAL(l_bool, Fwv_InitialSta)
L_SIGNAL(l_bool, Fwv_Calibration_Fail)
    65c6:	46d8 119e 	mov	0x119e <_l_signals+0xa>, YL
    65ca:	07e9      	jmp	0x659e <.L52>

000065cc <.L54>:
L_SIGNAL(l_bool, Fwv_MoveEnable_Status)
L_SIGNAL(l_bool, Fwv_Motor_Stall)
    65cc:	6000      	lod	AL, #0

000065ce <.L93>:
    65ce:	42d8 11a0 	mov	0x11a0 <_l_signals+0xc>, AL

000065d2 <.L55>:
		{
			l_bool_wr_Fwv_Motor_Stall(0);
		}
	}

	if (((valve.diag.motorFault & FAULT_MASK_PHASE_A_OPEN) != 0) && (valve.comm.faultMode != 0)) /*20250714*/
    65d2:	62d8 1263 	lod	AL, 0x1263 <.LLST6+0x11>
    65d6:	4203      	mov	[S-4], AL
    65d8:	9401      	and	AL, #1
    65da:	191c      	je	0x6614 <.L57>

000065dc <.LM99>:
    65dc:	2c00      	cmp	X, #0
    65de:	191a      	je	0x6614 <.L57>

000065e0 <.LBB168>:
L_SIGNAL(l_bool, Fwv_Short_Circuit)
L_SIGNAL(l_bool, Fwv_Open_Circuit)
    65e0:	6001      	lod	AL, #1

000065e2 <.L94>:
    65e2:	42d8 11a2 	mov	0x11a2 <.LASF1798+0x1>, AL

000065e6 <.LBE170>:
	}
	else
	{
		l_bool_wr_Fwv_Open_Circuit(0);
	}
	if (((valve.diag.motorFault & FAULT_MASK_PHASE_A_SHORT) != 0) && (valve.comm.faultMode != 0)) /*20250714*/
    65e6:	6203      	lod	AL, [S-4]
    65e8:	9410      	and	AL, #16
    65ea:	1916      	je	0x6618 <.L59>

000065ec <.LM102>:
    65ec:	2c00      	cmp	X, #0
    65ee:	1914      	je	0x6618 <.L59>

000065f0 <.LBB173>:
L_SIGNAL(l_bool, Fwv_ProtectMode)
L_SIGNAL(l_bool, Fwv_InitialSta)
L_SIGNAL(l_bool, Fwv_Calibration_Fail)
L_SIGNAL(l_bool, Fwv_MoveEnable_Status)
L_SIGNAL(l_bool, Fwv_Motor_Stall)
L_SIGNAL(l_bool, Fwv_Short_Circuit)
    65f0:	6001      	lod	AL, #1

000065f2 <.L95>:
    65f2:	42d8 11a1 	mov	0x11a1 <.LASF1798>, AL

000065f6 <.LBE175>:
	else
	{
		l_bool_wr_Fwv_Short_Circuit(0);
	}

	if (valve.diag.vs.state == VS_NORMAL)
    65f6:	72d8 1238 	lod	A, 0x1238 <.LLST0+0x6>
    65fa:	1d10      	jne	0x661c <.L61>

000065fc <.LBB178>:
L_SIGNAL(l_bool, Fwv_Open_Circuit)
L_SIGNAL(l_bool, Fwv_Undervoltage)
    65fc:	42d8 11a3 	mov	0x11a3 <.LASF1798+0x2>, AL

00006600 <.L96>:
L_SIGNAL(l_bool, Fwv_Overvoltage)
    6600:	42d8 11a4 	mov	0x11a4 <.LLST13>, AL
    6604:	0013      	jmp	0x662c <.L62>

00006606 <.L53>:
			l_bool_wr_Fwv_Motor_Stall(0);
		}
	}
	else
	{
		if ((valve.diag.stallFault & STALL_MASK_TEMPORARY) != 0)
    6606:	9401      	and	AL, #1
    6608:	66e0      	lod	YL, AL
    660a:	9401      	and	AL, #1
    660c:	1d5a      	jne	0x65c2 <.L100>

0000660e <.LBB183>:
L_SIGNAL(l_bool, Fwv_FaultMode)
L_SIGNAL(l_bool, Fwv_ProtectMode)
L_SIGNAL(l_bool, Fwv_InitialSta)
L_SIGNAL(l_bool, Fwv_Calibration_Fail)
L_SIGNAL(l_bool, Fwv_MoveEnable_Status)
L_SIGNAL(l_bool, Fwv_Motor_Stall)
    660e:	46d8 11a0 	mov	0x11a0 <_l_signals+0xc>, YL
    6612:	07df      	jmp	0x65d2 <.L55>

00006614 <.L57>:
L_SIGNAL(l_bool, Fwv_Short_Circuit)
L_SIGNAL(l_bool, Fwv_Open_Circuit)
    6614:	6000      	lod	AL, #0
    6616:	07e5      	jmp	0x65e2 <.L94>

00006618 <.L59>:
L_SIGNAL(l_bool, Fwv_ProtectMode)
L_SIGNAL(l_bool, Fwv_InitialSta)
L_SIGNAL(l_bool, Fwv_Calibration_Fail)
L_SIGNAL(l_bool, Fwv_MoveEnable_Status)
L_SIGNAL(l_bool, Fwv_Motor_Stall)
L_SIGNAL(l_bool, Fwv_Short_Circuit)
    6618:	6000      	lod	AL, #0
    661a:	07eb      	jmp	0x65f2 <.L95>

0000661c <.L61>:
    661c:	6400      	lod	YL, #0

0000661e <.LM111>:
	if (valve.diag.vs.state == VS_NORMAL)
	{
		l_bool_wr_Fwv_Undervoltage(0);
		l_bool_wr_Fwv_Overvoltage(0);
	}
	else if (valve.diag.vs.state == VS_UNDERVOLTAGE)
    661e:	ac01      	cmp	A, #1
    6620:	1901      	je	0x6624 <.LBB187>
    6622:	0037      	jmp	0x6692 <.L63>

00006624 <.LBB187>:
L_SIGNAL(l_bool, Fwv_Open_Circuit)
L_SIGNAL(l_bool, Fwv_Undervoltage)
    6624:	42d8 11a3 	mov	0x11a3 <.LASF1798+0x2>, AL

00006628 <.LBB189>:
L_SIGNAL(l_bool, Fwv_Overvoltage)
    6628:	46d8 11a4 	mov	0x11a4 <.LLST13>, YL

0000662c <.L62>:
	}
	else
	{
	}

	if (((valve.diag.motorFault & FAULT_MASK_OVER_CURRENT) != 0))
    662c:	6203      	lod	AL, [S-4]
    662e:	9440      	and	AL, #64
    6630:	66e0      	lod	YL, AL
    6632:	6203      	lod	AL, [S-4]
    6634:	9440      	and	AL, #64
    6636:	1933      	je	0x669e <.L64>

00006638 <.LBB191>:
L_SIGNAL(l_bool, Fwv_Overcurrent)
    6638:	6001      	lod	AL, #1
    663a:	42d8 11a5 	mov	0x11a5 <.LLST13+0x1>, AL

0000663e <.L65>:
	else
	{
		l_bool_wr_Fwv_Overcurrent(0);
	}

	if (valve.diag.temp.state == TEMPERATURE_HIGH)
    663e:	72d8 1244 	lod	A, 0x1244 <.LLST0+0x12>
    6642:	ac02      	cmp	A, #2
    6644:	1d2f      	jne	0x66a4 <.L66>

00006646 <.LBB193>:
L_SIGNAL(l_bool, Fwv_Overtemperature)
    6646:	6001      	lod	AL, #1

00006648 <.L97>:
    6648:	42d8 11a6 	mov	0x11a6 <.LLST13+0x2>, AL

0000664c <.LBE195>:
	{
		l_bool_wr_Fwv_Overtemperature(0);
	}

	/* Byte 2 [2..0] */
	if (valve.state == VALVE_DIAGRUN)
    664c:	7a05      	lod	Y, [S-6]
    664e:	ec04      	cmp	Y, #4
    6650:	1d2b      	jne	0x66a8 <.L68>

00006652 <.LBB198>:
L_SIGNAL(l_bool, Fwv_Diag_Forced_Status)
    6652:	6001      	lod	AL, #1

00006654 <.L98>:
    6654:	42d8 11a7 	mov	0x11a7 <.LLST13+0x3>, AL

00006658 <.LBE200>:
	}
	else
	{
		l_bool_wr_Fwv_Diag_Forced_Status(0);
	}
	l_bool_wr_Fwv_Position_Sensor_Fault(valve.diag.gmr.state);
    6658:	62d8 1252 	lod	AL, 0x1252 <.LLST6>
    665c:	5ca2      	sne	A

0000665e <.LBB203>:
L_SIGNAL(l_bool, Fwv_Position_Sensor_Fault)
    665e:	42d8 11a8 	mov	0x11a8 <.LLST13+0x4>, AL

00006662 <.LBE203>:
	l_bool_wr_Fwv_CommErr(valve.diag.linError);
    6662:	62d8 125a 	lod	AL, 0x125a <.LLST6+0x8>
    6666:	5ca2      	sne	A

00006668 <.LBB205>:
L_SIGNAL(l_bool, Fwv_CommErr)
    6668:	42d8 11a9 	mov	0x11a9 <.LLST13+0x5>, AL

0000666c <.LBE205>:
	valve.diag.linError = 0;
    666c:	6400      	lod	YL, #0
    666e:	46d8 125a 	mov	0x125a <.LLST6+0x8>, YL

00006672 <.LBB207>:
L_SIGNAL(l_u16, Fwv_SW_Version)
    6672:	0ea7      	lod	C, ML.7
    6674:	7002      	lod	A, #2
    6676:	52d8 11aa 	mov	0x11aa <.LLST13+0x6>, A

0000667a <.LBE207>:
	/* Byte 2 [7..3] and Byte 3 ~ 4*/
	l_u16_wr_Fwv_SW_Version(SW_VERSION);
#if 1
	int16_t pos = valve.pos.currentAngle;
    667a:	7ed8 1208 	lod	X, 0x1208 <.LLST4>

0000667e <.LM127>:
	if (pos >= (valve.pos.modeAngle[C_MODE_A] - (int16_t)C_VALVE_ACCURACY_ANGLE))
    667e:	0ea7      	lod	C, ML.7
    6680:	72d8 120a 	lod	A, 0x120a <.LLST4+0x2>
    6684:	a0ec      	add	A, #-20
    6686:	aeee      	cmp	A, X
    6688:	1f11      	jsg	0x66ac <.L70>

0000668a <.L99>:
L_SIGNAL(l_u8, Fwv_Stall_State)
    668a:	6001      	lod	AL, #1
    668c:	42d8 11ac 	mov	0x11ac <.LLST13+0x8>, AL
    6690:	5407      	ret	#8

00006692 <.L63>:
	else if (valve.diag.vs.state == VS_UNDERVOLTAGE)
	{
		l_bool_wr_Fwv_Undervoltage(1);
		l_bool_wr_Fwv_Overvoltage(0);
	}
	else if (valve.diag.vs.state == VS_OVERVOLTAGE)
    6692:	ac02      	cmp	A, #2
    6694:	1d4b      	jne	0x662c <.L62>

00006696 <.LBB211>:
L_SIGNAL(l_bool, Fwv_Calibration_Fail)
L_SIGNAL(l_bool, Fwv_MoveEnable_Status)
L_SIGNAL(l_bool, Fwv_Motor_Stall)
L_SIGNAL(l_bool, Fwv_Short_Circuit)
L_SIGNAL(l_bool, Fwv_Open_Circuit)
L_SIGNAL(l_bool, Fwv_Undervoltage)
    6696:	46d8 11a3 	mov	0x11a3 <.LASF1798+0x2>, YL

0000669a <.LBE211>:
L_SIGNAL(l_bool, Fwv_Overvoltage)
    669a:	6001      	lod	AL, #1
    669c:	07b1      	jmp	0x6600 <.L96>

0000669e <.L64>:
L_SIGNAL(l_bool, Fwv_Overcurrent)
    669e:	46d8 11a5 	mov	0x11a5 <.LLST13+0x1>, YL
    66a2:	07cd      	jmp	0x663e <.L65>

000066a4 <.L66>:
L_SIGNAL(l_bool, Fwv_Overtemperature)
    66a4:	6000      	lod	AL, #0
    66a6:	07d0      	jmp	0x6648 <.L97>

000066a8 <.L68>:
L_SIGNAL(l_bool, Fwv_Diag_Forced_Status)
    66a8:	6000      	lod	AL, #0
    66aa:	07d4      	jmp	0x6654 <.L98>

000066ac <.L70>:
	int16_t pos = valve.pos.currentAngle;
	if (pos >= (valve.pos.modeAngle[C_MODE_A] - (int16_t)C_VALVE_ACCURACY_ANGLE))
	{
		l_u8_wr_Fwv_Stall_State(1);
	}
	else if (pos <= (valve.pos.modeAngle[C_MODE_B] + (int16_t)C_VALVE_ACCURACY_ANGLE))
    66ac:	72d8 120c 	lod	A, 0x120c <.LLST4+0x4>
    66b0:	a014      	add	A, #20
    66b2:	aeee      	cmp	A, X
    66b4:	1eea      	jsge	0x668a <.L99>

000066b6 <.LBB218>:
L_SIGNAL(l_bool, Fwv_Position_Sensor_Fault)
L_SIGNAL(l_bool, Fwv_CommErr)
L_SIGNAL(l_u16, Fwv_SW_Version)
L_SIGNAL(l_u8, Fwv_Stall_State)
    66b6:	46d8 11ac 	mov	0x11ac <.LLST13+0x8>, YL

000066ba <.LBE218>:

		l_u8_wr_Fwv_Stall_State(3);
	}

#endif
}
    66ba:	5407      	ret	#8

000066bc <_get_valve_mode>:
	return status;
}
tValveState get_valve_mode(void)
{
	return valve.state;
}
    66bc:	72d8 11f8 	lod	A, 0x11f8 <_valve>
    66c0:	5401      	ret

000066c2 <_get_valve_voltage>:
uint16_t get_valve_voltage(void)
{
	return valve.diag.vs.voltage;
}
    66c2:	72d8 123a 	lod	A, 0x123a <.LLST0+0x8>
    66c6:	5401      	ret

000066c8 <_get_valve_temperature>:
int16_t get_valve_temperature(void)
{
	return valve.diag.temp.deg;
}
    66c8:	72d8 1248 	lod	A, 0x1248 <.LLST0+0x16>
    66cc:	5401      	ret

000066ce <_get_valve_motCurrent>:
uint16_t get_valve_motCurrent(void)
{
	return valve.diag.motorCurrent;
}
    66ce:	72d8 1258 	lod	A, 0x1258 <.LLST6+0x6>
    66d2:	5401      	ret

000066d4 <_AppValveInit>:

void AppValveInit(void)
{

	valve.state = VALVE_INIT;
    66d4:	7000      	lod	A, #0
    66d6:	52d8 11f8 	mov	0x11f8 <_valve>, A

000066da <.LM156>:
	valve.lastState = VALVE_INIT;
    66da:	52d8 11fa 	mov	0x11fa <_valve+0x2>, A

000066de <.LM157>:
	valve.elapsedTime = 0;
    66de:	0ea7      	lod	C, ML.7
    66e0:	52d8 11fe 	mov	0x11fe <_valve+0x6>, A

000066e4 <.LM158>:
	valve.sleepState = 0;
    66e4:	52d8 1202 	mov	0x1202 <_valve+0xa>, A

000066e8 <.LM159>:
	valve.initStatus = 0;
	valve.linLiveTimeOut = 4000;
    66e8:	7eda 0fa0 	lod	X, #4000
    66ec:	0ea7      	lod	C, ML.7
    66ee:	5ed8 11fc 	mov	0x11fc <_valve+0x4>, X

000066f2 <.LM160>:
	valve.pos.currentAngle = 0;
	valve.pos.targetAngle = 0;
    66f2:	52d8 1206 	mov	0x1206 <_valve+0xe>, A
    66f6:	52d8 1208 	mov	0x1208 <.LLST4>, A

000066fa <.LM161>:
	valve.lastState = VALVE_INIT;
	valve.elapsedTime = 0;
	valve.sleepState = 0;
	valve.initStatus = 0;
	valve.linLiveTimeOut = 4000;
	valve.pos.currentAngle = 0;
    66fa:	0ea7      	lod	C, ML.7
    66fc:	7eda 0b45 	lod	X, #2885
    6700:	5ed8 120a 	mov	0x120a <.LLST4+0x2>, X

00006704 <.LM162>:
	valve.pos.targetAngle = 0;
	valve.pos.modeAngle[C_MODE_A] = (int16_t)C_VALVE_MODE_A_ANGLE;
    6704:	7eda 07c1 	lod	X, #1985
    6708:	0ea7      	lod	C, ML.7
    670a:	5ed8 120c 	mov	0x120c <.LLST4+0x4>, X

0000670e <.LM163>:
	valve.pos.modeAngle[C_MODE_B] = (int16_t)C_VALVE_MODE_B_ANGLE;
    670e:	52d8 120e 	mov	0x120e <.LLST4+0x6>, A

00006712 <.LM164>:
	valve.pos.fault = 0;
	valve.pos.retryCnt = 0;

	valve.calibration.req2Cal = 0;
    6712:	42d8 1212 	mov	0x1212 <.LLST4+0xa>, AL

00006716 <.LM165>:
	valve.calibration.req1Cal = 0;
    6716:	0ea7      	lod	C, ML.7
    6718:	42d8 1213 	mov	0x1213 <.LLST4+0xb>, AL

0000671c <.LM166>:
	valve.calibration.offsetDone = 0;
    671c:	42d8 1211 	mov	0x1211 <.LLST4+0x9>, AL

00006720 <.LM167>:
	valve.comm.ForcedDiag = 0;
	valve.comm.targetMode = 0xFFu;
	valve.comm.lastMode = 0xFFu;
	valve.comm.actualMode = C_MODE_B;
	valve.comm.moving = 0;
	valve.comm.timeOut = 5000;
    6720:	7eda 1388 	lod	X, #5000
    6724:	0ea7      	lod	C, ML.7
    6726:	5ed8 121e 	mov	0x121e <.LASF1692>, X
    672a:	7eda 00ff 	lod	X, #255
    672e:	5ed8 1220 	mov	0x1220 <.LLST6+0x1>, X

00006732 <.LM168>:
	valve.calibration.req2Cal = 0;
	valve.calibration.req1Cal = 0;
	valve.calibration.offsetDone = 0;

	valve.comm.Initial = 0;
	valve.comm.Enable = 0;
    6732:	0ea7      	lod	C, ML.7
    6734:	52d8 1222 	mov	0x1222 <.LLST6+0x3>, A

00006738 <.LM169>:
	valve.comm.ForcedDiag = 0;
    6738:	7eda 01ff 	lod	X, #511
    673c:	5ed8 1224 	mov	0x1224 <.LLST6+0x5>, X

00006740 <.LM170>:
	valve.comm.targetMode = 0xFFu;
	valve.comm.lastMode = 0xFFu;
	valve.comm.actualMode = C_MODE_B;
    6740:	0ea7      	lod	C, ML.7
    6742:	52d8 1226 	mov	0x1226 <.LLST6+0x7>, A

00006746 <.LM171>:
	valve.comm.moving = 0;
	valve.comm.timeOut = 5000;
	valve.comm.faultMode = 0;

	valve.diag.protType = NONE_ERROR;
    6746:	52d8 1260 	mov	0x1260 <.LLST6+0xe>, A

0000674a <.LM172>:
	valve.diag.calFault = 0;
	valve.diag.motorFault = 0;
	valve.diag.stallFault = 0;
	valve.diag.McuFault = 0;
	valve.diag.mcuRetryCnt = 0;
	valve.diag.vs.state = VS_UNDEF;
    674a:	7c03      	lod	X, #3
    674c:	0ea7      	lod	C, ML.7
    674e:	5ed8 1238 	mov	0x1238 <.LLST0+0x6>, X

00006752 <.LM173>:
	valve.diag.vs.UVretryCnt = 0;
    6752:	52d8 1240 	mov	0x1240 <.LLST0+0xe>, A

00006756 <.LM174>:
	valve.diag.vs.OVretryCnt = 0;
    6756:	52d8 1242 	mov	0x1242 <.LLST0+0x10>, A

0000675a <.LM175>:
	valve.diag.ign.state = IGN_UNDEF;
    675a:	0ea7      	lod	C, ML.7
    675c:	7802      	lod	Y, #2
    675e:	5ad8 124c 	mov	0x124c <.LLST0+0x1a>, Y

00006762 <.LM176>:
	valve.diag.ign.uvTimer = 0;
	valve.diag.temp.state = TEMPERATURE_UNDEF;
    6762:	5ed8 1244 	mov	0x1244 <.LLST0+0x12>, X

00006766 <.LM177>:
	valve.diag.temp.retryCnt = 0;
    6766:	0ea7      	lod	C, ML.7
    6768:	52d8 1246 	mov	0x1246 <.LLST0+0x14>, A

0000676c <.LM178>:
	valve.diag.mcuRetryCnt = 0;
	valve.diag.vs.state = VS_UNDEF;
	valve.diag.vs.UVretryCnt = 0;
	valve.diag.vs.OVretryCnt = 0;
	valve.diag.ign.state = IGN_UNDEF;
	valve.diag.ign.uvTimer = 0;
    676c:	52d8 1250 	mov	0x1250 <.LASF1443+0x1>, A
    6770:	52d8 1252 	mov	0x1252 <.LLST6>, A

00006774 <.LM179>:
	valve.comm.moving = 0;
	valve.comm.timeOut = 5000;
	valve.comm.faultMode = 0;

	valve.diag.protType = NONE_ERROR;
	valve.diag.calFault = 0;
    6774:	0ea7      	lod	C, ML.7
    6776:	52d8 1262 	mov	0x1262 <.LLST6+0x10>, A

0000677a <.LM180>:
	valve.diag.motorFault = 0;
    677a:	52d8 1264 	mov	0x1264 <.LLST6+0x12>, A

0000677e <.LM181>:
	valve.diag.ign.uvTimer = 0;
	valve.diag.temp.state = TEMPERATURE_UNDEF;
	valve.diag.temp.retryCnt = 0;
	valve.diag.gmr.state = 0;
	valve.diag.gmr.retryCnt = 0;
	valve.diag.stallRetryCnt = 0;
    677e:	52d8 1266 	mov	0x1266 <.LLST6+0x14>, A

00006782 <.LM182>:
	valve.diag.calRetryCnt = 0;
	valve.diag.ObstructionRetryCnt = 0;
	valve.diag.motOcRetryCnt = 0;
    6782:	0ea7      	lod	C, ML.7
    6784:	52d8 1268 	mov	0x1268 <.LLST6+0x16>, A

00006788 <.LM183>:
	valve.diag.motOpenRetryCnt = 0;
	valve.diag.motShortRetryCnt = 0;
	valve.diag.linError = 0;
    6788:	52d8 125a 	mov	0x125a <.LLST6+0x8>, A

0000678c <.LM184>:
	valve.diag.linErrRetryCnt = 0;
    678c:	52d8 125c 	mov	0x125c <.LLST6+0xa>, A

00006790 <.LM185>:
	valve.diag.protType = NONE_ERROR;
	valve.diag.calFault = 0;
	valve.diag.motorFault = 0;
	valve.diag.stallFault = 0;
	valve.diag.McuFault = 0;
	valve.diag.mcuRetryCnt = 0;
    6790:	0ea7      	lod	C, ML.7
    6792:	42d8 125e 	mov	0x125e <.LLST6+0xc>, AL

00006796 <.LM186>:
	valve.diag.motOcRetryCnt = 0;
	valve.diag.motOpenRetryCnt = 0;
	valve.diag.motShortRetryCnt = 0;
	valve.diag.linError = 0;
	valve.diag.linErrRetryCnt = 0;
	if (eeprom_ReadValveConfig(&valve_gmr_data))
    6796:	72da 1326 	lod	A, #4902
    679a:	82db 433a 	callf	0x8674 <_eeprom_ReadValveConfig>
    679e:	ac00      	cmp	A, #0
    67a0:	1913      	je	0x67c8 <.L109>

000067a2 <.LM187>:
	{
		valve.memory.offset = (int16_t)valve_gmr_data.E1DATA0; // 250709-2 - EEPROM Load 1st -> Global Variables
    67a2:	72d8 1326 	lod	A, 0x1326 <_valve_gmr_data>
    67a6:	52d8 1230 	mov	0x1230 <.LLST6+0x11>, A

000067aa <.LM188>:
		if ((valve.memory.offset > 0) && (valve.memory.offset <= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT))
    67aa:	7ee2      	lod	X, A
    67ac:	20ff      	add	X, #-1
    67ae:	2eda 0e0f 	cmp	X, #3599
    67b2:	1e02      	jug	0x67b8 <.L110>

000067b4 <.LM189>:
		{

			set_gmr_sensor_offset(valve.memory.offset);
    67b4:	82db 3be7 	callf	0x77ce <_set_gmr_sensor_offset>

000067b8 <.L110>:
		}
		valve.memory.lastAngle = (int16_t)valve_gmr_data.E1DATA1; // 250709-2 - EEPROM Load 2nd -> Global Variables
		valve.memory.code_1 = valve_gmr_data.E1DATA2;			  // 250709-2 - EEPROM Load 3rd -> Global Variables
    67b8:	7ada 1232 	lod	Y, #4658
    67bc:	7eda 1328 	lod	X, #4904
    67c0:	0ea7      	lod	C, ML.7
    67c2:	54ce      	movsw	[Y++], [X++]
    67c4:	0ea7      	lod	C, ML.7
    67c6:	54ce      	movsw	[Y++], [X++]

000067c8 <.L109>:
	}
	else
	{
	}
	if (eeprom_ReadDiagConfig(&valve_diag_data))
    67c8:	72da 1320 	lod	A, #4896
    67cc:	82db 437b 	callf	0x86f6 <_eeprom_ReadDiagConfig>
    67d0:	ac00      	cmp	A, #0
    67d2:	1912      	je	0x67f8 <.L108>

000067d4 <.LM192>:
	{
		valve.memory.state = valve_diag_data.E1DATA0;
    67d4:	7ed8 1320 	lod	X, 0x1320 <_valve_diag_data>
    67d8:	5ed8 122a 	mov	0x122a <.LLST6+0xb>, X

000067dc <.LM193>:
		valve.memory.value = valve_diag_data.E1DATA1;
    67dc:	72d8 1322 	lod	A, 0x1322 <_valve_diag_data+0x2>
    67e0:	0ea7      	lod	C, ML.7
    67e2:	52d8 122e 	mov	0x122e <.LLST6+0xf>, A

000067e6 <.LM194>:
		valve.memory.code_2 = valve_diag_data.E1DATA2;
    67e6:	7ad8 1324 	lod	Y, 0x1324 <_valve_diag_data+0x4>
    67ea:	5ad8 1236 	mov	0x1236 <.LLST0+0x4>, Y

000067ee <.LM195>:
		u16EventState = valve.memory.state;
    67ee:	0ea7      	lod	C, ML.7
    67f0:	5ed8 10b6 	mov	0x10b6 <_u16EventState>, X

000067f4 <.LM196>:
		u16EventValue = valve.memory.value;
    67f4:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

000067f8 <.L108>:
	}
	else
	{
	}
}
    67f8:	5401      	ret

000067fa <_AppValveTask>:
 * \brief Actuator task called by every 1ms
 *
 */

void AppValveTask(void)
{
    67fa:	5807      	inc	S, #8

000067fc <.LBB278>:
	}
	return status;
}
static void valveDiagVs(void)
{
	valve.diag.vs.voltage = get_conv_supply_voltage();
    67fc:	82db 3c45 	callf	0x788a <_get_conv_supply_voltage>

00006800 <.LVL82>:
    6800:	52d8 123a 	mov	0x123a <.LLST0+0x8>, A

00006804 <.LM200>:
	switch (valve.diag.vs.state)
    6804:	7ed8 1238 	lod	X, 0x1238 <.LLST0+0x6>
    6808:	2c01      	cmp	X, #1
    680a:	1d01      	jne	0x680e <.LASF1076+0x5>
    680c:	0048      	jmp	0x689e <.L120>
    680e:	1807      	jc	0x681e <.L121>
    6810:	2c02      	cmp	X, #2
    6812:	1d01      	jne	0x6816 <.LM201>
    6814:	0059      	jmp	0x68c8 <.L122>

00006816 <.LM201>:
				}
			}
			else
#endif
	{
		valve.diag.vs.uvTimer = 0u;
    6816:	7000      	lod	A, #0
    6818:	52d8 123c 	mov	0x123c <.LLST0+0xa>, A
    681c:	005f      	jmp	0x68dc <.L538>

0000681e <.L121>:
{
	valve.diag.vs.voltage = get_conv_supply_voltage();
	switch (valve.diag.vs.state)
	{
	case VS_NORMAL:
		if (valve.diag.vs.voltage <= VS_UNDER_STOP)
    681e:	aeda 0320 	cmp	A, #800
    6822:	1e21      	jug	0x6866 <.L123>

00006824 <.LM203>:
		{
			valve.diag.vs.uvTimer++;
    6824:	72d8 123c 	lod	A, 0x123c <.LLST0+0xa>
    6828:	a001      	add	A, #1

0000682a <.LM204>:
			if (valve.diag.vs.uvTimer >= VS_ENTER_COUNT)
    682a:	aeda 03e7 	cmp	A, #999
    682e:	1e14      	jug	0x6858 <.L124>

00006830 <.LM205>:
	switch (valve.diag.vs.state)
	{
	case VS_NORMAL:
		if (valve.diag.vs.voltage <= VS_UNDER_STOP)
		{
			valve.diag.vs.uvTimer++;
    6830:	52d8 123c 	mov	0x123c <.LLST0+0xa>, A

00006834 <.L125>:
	break;
	}
}
static void valveDiagTemp(void)
{
	valve.diag.temp.deg = get_conv_ic_temperature();
    6834:	82db 3c48 	callf	0x7890 <_get_conv_ic_temperature>
    6838:	52d8 1248 	mov	0x1248 <.LLST0+0x16>, A

0000683c <.LM207>:

	switch (valve.diag.temp.state)
    683c:	7ed8 1244 	lod	X, 0x1244 <.LLST0+0x12>
    6840:	2c01      	cmp	X, #1
    6842:	1d01      	jne	0x6846 <.LM207+0xa>
    6844:	0061      	jmp	0x6908 <.L135>
    6846:	1c01      	jnc	0x684a <.LASF1137+0x2>
    6848:	004c      	jmp	0x68e2 <.L136>
    684a:	2c02      	cmp	X, #2
    684c:	1d01      	jne	0x6850 <.L535>
    684e:	007f      	jmp	0x694e <.L137>

00006850 <.L535>:

			}
			else
#endif
	{
		valve.diag.temp.timer = 0u;
    6850:	7000      	lod	A, #0
    6852:	52d8 124a 	mov	0x124a <.LLST0+0x18>, A
    6856:	0055      	jmp	0x6902 <.L546>

00006858 <.L124>:
		if (valve.diag.vs.voltage <= VS_UNDER_STOP)
		{
			valve.diag.vs.uvTimer++;
			if (valve.diag.vs.uvTimer >= VS_ENTER_COUNT)
			{
				valve.diag.vs.uvTimer = 0u;
    6858:	7000      	lod	A, #0
    685a:	52d8 123c 	mov	0x123c <.LLST0+0xa>, A

0000685e <.LM210>:
				valve.diag.vs.state = VS_UNDERVOLTAGE;
    685e:	7001      	lod	A, #1

00006860 <.L542>:
			else
#endif
	{
		valve.diag.vs.uvTimer = 0u;
		valve.diag.vs.ovTimer = 0u;
		valve.diag.vs.state = VS_NORMAL;
    6860:	52d8 1238 	mov	0x1238 <.LLST0+0x6>, A
    6864:	07e7      	jmp	0x6834 <.L125>

00006866 <.L123>:
    6866:	7ed8 123e 	lod	X, 0x123e <.LLST0+0xc>

0000686a <.LM212>:
			{
				valve.diag.vs.uvTimer = 0u;
				valve.diag.vs.state = VS_UNDERVOLTAGE;
			}
		}
		else if (valve.diag.vs.voltage >= VS_OVER_STOP)
    686a:	aeda 06a3 	cmp	A, #1699
    686e:	1a0d      	jule	0x688a <.L126>

00006870 <.LM213>:
		{
			valve.diag.vs.ovTimer++;
    6870:	2001      	add	X, #1

00006872 <.LM214>:
			if (valve.diag.vs.ovTimer >= VS_ENTER_COUNT)
    6872:	2eda 03e7 	cmp	X, #999
    6876:	1e03      	jug	0x687e <.L127>

00006878 <.L540>:
		else
		{
#if 1
			if (valve.diag.vs.ovTimer > 0)
			{
				valve.diag.vs.ovTimer--;
    6878:	5ed8 123e 	mov	0x123e <.LLST0+0xc>, X
    687c:	07db      	jmp	0x6834 <.L125>

0000687e <.L127>:
		else if (valve.diag.vs.voltage >= VS_OVER_STOP)
		{
			valve.diag.vs.ovTimer++;
			if (valve.diag.vs.ovTimer >= VS_ENTER_COUNT)
			{
				valve.diag.vs.ovTimer = 0u;
    687e:	7000      	lod	A, #0
    6880:	52d8 123e 	mov	0x123e <.LLST0+0xc>, A

00006884 <.LM217>:
				valve.diag.vs.state = VS_OVERVOLTAGE;
    6884:	7002      	lod	A, #2
    6886:	0ea7      	lod	C, ML.7
    6888:	07eb      	jmp	0x6860 <.L542>

0000688a <.L126>:
			}
		}
		else
		{
#if 1
			if (valve.diag.vs.uvTimer > 0)
    688a:	72d8 123c 	lod	A, 0x123c <.LLST0+0xa>
    688e:	1903      	je	0x6896 <.L132>

00006890 <.LM219>:
			{
				valve.diag.vs.uvTimer--;
    6890:	a0ff      	add	A, #-1
    6892:	52d8 123c 	mov	0x123c <.LLST0+0xa>, A

00006896 <.L132>:
			}
		}
		else
		{
#if 1
			if (valve.diag.vs.ovTimer > 0)
    6896:	2c00      	cmp	X, #0
    6898:	194d      	je	0x6834 <.L125>

0000689a <.LM221>:
			{
				valve.diag.vs.ovTimer--;
    689a:	20ff      	add	X, #-1
    689c:	07ed      	jmp	0x6878 <.L540>

0000689e <.L120>:
    689e:	7ed8 123c 	lod	X, 0x123c <.LLST0+0xa>

000068a2 <.LM222>:
#endif
		}
		break;
	case VS_UNDERVOLTAGE:

		if (valve.diag.vs.voltage >= VS_UNDER_RETURN)
    68a2:	aeda 0383 	cmp	A, #899
    68a6:	1a0b      	jule	0x68be <.L130>

000068a8 <.LM223>:
		{
			valve.diag.vs.uvTimer++;
    68a8:	2001      	add	X, #1

000068aa <.LM224>:
			if (valve.diag.vs.uvTimer >= VS_ENTER_COUNT)
    68aa:	2eda 03e7 	cmp	X, #999
    68ae:	1e03      	jug	0x68b6 <.L131>

000068b0 <.L539>:
		else
		{
#if 1
			if (valve.diag.vs.uvTimer > 0)
			{
				valve.diag.vs.uvTimer--;
    68b0:	5ed8 123c 	mov	0x123c <.LLST0+0xa>, X
    68b4:	07bf      	jmp	0x6834 <.L125>

000068b6 <.L131>:
		if (valve.diag.vs.voltage >= VS_UNDER_RETURN)
		{
			valve.diag.vs.uvTimer++;
			if (valve.diag.vs.uvTimer >= VS_ENTER_COUNT)
			{
				valve.diag.vs.uvTimer = 0u;
    68b6:	7000      	lod	A, #0
    68b8:	52d8 123c 	mov	0x123c <.LLST0+0xa>, A
    68bc:	07d1      	jmp	0x6860 <.L542>

000068be <.L130>:
			}
		}
		else
		{
#if 1
			if (valve.diag.vs.uvTimer > 0)
    68be:	2c00      	cmp	X, #0
    68c0:	1d01      	jne	0x68c4 <.LM228>
    68c2:	07b8      	jmp	0x6834 <.L125>

000068c4 <.LM228>:
			{
				valve.diag.vs.uvTimer--;
    68c4:	20ff      	add	X, #-1
    68c6:	07f4      	jmp	0x68b0 <.L539>

000068c8 <.L122>:
    68c8:	7ed8 123e 	lod	X, 0x123e <.LLST0+0xc>

000068cc <.LM229>:
#endif
		}
		break;
	case VS_OVERVOLTAGE:

		if (valve.diag.vs.voltage <= VS_OVER_RETURN)
    68cc:	aeda 0640 	cmp	A, #1600
    68d0:	1e62      	jug	0x6896 <.L132>

000068d2 <.LM230>:
		{
			valve.diag.vs.ovTimer++;
    68d2:	2001      	add	X, #1

000068d4 <.LM231>:
			if (valve.diag.vs.ovTimer >= VS_ENTER_COUNT)
    68d4:	2eda 03e7 	cmp	X, #999
    68d8:	1a4f      	jule	0x6878 <.L540>

000068da <.LM232>:
			{
				valve.diag.vs.ovTimer = 0u;
    68da:	7000      	lod	A, #0

000068dc <.L538>:
			}
			else
#endif
	{
		valve.diag.vs.uvTimer = 0u;
		valve.diag.vs.ovTimer = 0u;
    68dc:	52d8 123e 	mov	0x123e <.LLST0+0xc>, A
    68e0:	07bf      	jmp	0x6860 <.L542>

000068e2 <.L136>:
    68e2:	7ed8 124a 	lod	X, 0x124a <.LLST0+0x18>

000068e6 <.LM234>:
	valve.diag.temp.deg = get_conv_ic_temperature();

	switch (valve.diag.temp.state)
	{
	case TEMPERATURE_NORMAL:
		if (valve.diag.temp.deg > (int16_t)TEMP_OVER_STOP)
    68e6:	aeda 00af 	cmp	A, #175
    68ea:	1f01      	jsg	0x68ee <.LM235>
    68ec:	0035      	jmp	0x6958 <.L143>

000068ee <.LM235>:
		{
			valve.diag.temp.timer++;
    68ee:	2001      	add	X, #1

000068f0 <.LM236>:
			if (valve.diag.temp.timer >= TEMP_ENTER_COUNT)
    68f0:	2c63      	cmp	X, #99
    68f2:	1e03      	jug	0x68fa <.L139>

000068f4 <.L544>:
		else
		{
#if 1
			if (valve.diag.temp.timer > 0)
			{
				valve.diag.temp.timer--;
    68f4:	5ed8 124a 	mov	0x124a <.LLST0+0x18>, X
    68f8:	0011      	jmp	0x691c <.L140>

000068fa <.L139>:
		if (valve.diag.temp.deg > (int16_t)TEMP_OVER_STOP)
		{
			valve.diag.temp.timer++;
			if (valve.diag.temp.timer >= TEMP_ENTER_COUNT)
			{
				valve.diag.temp.timer = 0u;
    68fa:	7000      	lod	A, #0
    68fc:	52d8 124a 	mov	0x124a <.LLST0+0x18>, A

00006900 <.LM239>:
				valve.diag.temp.state = TEMPERATURE_HIGH;
    6900:	7002      	lod	A, #2

00006902 <.L546>:
			}
			else
#endif
	{
		valve.diag.temp.timer = 0u;
		valve.diag.temp.state = TEMPERATURE_NORMAL;
    6902:	52d8 1244 	mov	0x1244 <.LLST0+0x12>, A
    6906:	000a      	jmp	0x691c <.L140>

00006908 <.L135>:
    6908:	7ed8 124a 	lod	X, 0x124a <.LLST0+0x18>

0000690c <.LM241>:
#endif
		}
		break;
	case TEMPERATURE_LOW:

		if (valve.diag.temp.deg >= (int16_t)TEMP_UNDER_RETURN)
    690c:	ac31      	cmp	A, #49
    690e:	1b24      	jsle	0x6958 <.L143>

00006910 <.L543>:
		{
			valve.diag.temp.timer++;
    6910:	2001      	add	X, #1
    6912:	5ed8 124a 	mov	0x124a <.LLST0+0x18>, X

00006916 <.LM243>:
			if (valve.diag.temp.timer >= TEMP_ENTER_COUNT)
    6916:	2c63      	cmp	X, #99
    6918:	1a01      	jule	0x691c <.L140>
    691a:	079a      	jmp	0x6850 <.L535>

0000691c <.L140>:
	}
}
static void valveDiagIgn(void)
{
	static uint16_t ignNormalTimer = 0;
	valve.diag.ign.voltage = get_conv_ignition_voltage();
    691c:	82db 3ce4 	callf	0x79c8 <_get_conv_ignition_voltage>
    6920:	52d8 124e 	mov	0x124e <.LLST0+0x1c>, A

00006924 <.LM245>:

	switch (valve.diag.ign.state)
    6924:	7ed8 124c 	lod	X, 0x124c <.LLST0+0x1a>
    6928:	191b      	je	0x6960 <.L146>
    692a:	2c01      	cmp	X, #1
    692c:	1d01      	jne	0x6930 <.LM246>
    692e:	0037      	jmp	0x699e <.L147>

00006930 <.LM246>:
#endif
		}
		break;

	default: /* VS_INIT */
		if (valve.diag.ign.voltage > IGN_UNDER_STOP)
    6930:	aeda 02bc 	cmp	A, #700
    6934:	1e01      	jug	0x6938 <.LM247>
    6936:	0067      	jmp	0x6a06 <.L154>

00006938 <.LM247>:
		{
			ignNormalTimer += 1;
    6938:	72d8 10b2 	lod	A, 0x10b2 <___ignNormalTimer_5863>
    693c:	a001      	add	A, #1
    693e:	52d8 10b2 	mov	0x10b2 <___ignNormalTimer_5863>, A
    6942:	7c00      	lod	X, #0

00006944 <.LM248>:
			if (ignNormalTimer >= 10u)
    6944:	ac09      	cmp	A, #9
    6946:	1a28      	jule	0x6998 <.L155>

00006948 <.LM249>:
			{
				valve.diag.ign.state = IGN_NORMAL;
    6948:	5ed8 124c 	mov	0x124c <.LLST0+0x1a>, X
    694c:	0025      	jmp	0x6998 <.L155>

0000694e <.L137>:
    694e:	7ed8 124a 	lod	X, 0x124a <.LLST0+0x18>

00006952 <.LBE287>:
#endif
		}
		break;
	case TEMPERATURE_HIGH:

		if (valve.diag.temp.deg <= (int16_t)TEMP_OVER_RETURN)
    6952:	aeda 00a5 	cmp	A, #165
    6956:	1b5c      	jsle	0x6910 <.L543>

00006958 <.L143>:
			}
		}
		else
		{
#if 1
			if (valve.diag.temp.timer > 0)
    6958:	2c00      	cmp	X, #0
    695a:	1960      	je	0x691c <.L140>

0000695c <.LM252>:
			{
				valve.diag.temp.timer--;
    695c:	20ff      	add	X, #-1
    695e:	07ca      	jmp	0x68f4 <.L544>

00006960 <.L146>:
    6960:	7ed8 1250 	lod	X, 0x1250 <.LASF1443+0x1>

00006964 <.LM253>:
	valve.diag.ign.voltage = get_conv_ignition_voltage();

	switch (valve.diag.ign.state)
	{
	case IGN_NORMAL:
		if (valve.diag.ign.voltage <= IGN_UNDER_STOP)
    6964:	aeda 02bc 	cmp	A, #700
    6968:	1e14      	jug	0x6992 <.L148>

0000696a <.LM254>:
		{
			valve.diag.ign.uvTimer++;
    696a:	2001      	add	X, #1
    696c:	5ed8 1250 	mov	0x1250 <.LASF1443+0x1>, X

00006970 <.LM255>:
			if (valve.diag.ign.uvTimer >= IGN_ENTER_COUNT)
    6970:	2eda 01f3 	cmp	X, #499
    6974:	1a0a      	jule	0x698a <.L158>

00006976 <.L157>:
			{
				valve.diag.ign.uvTimer = 0u;
    6976:	7000      	lod	A, #0
    6978:	52d8 1250 	mov	0x1250 <.LASF1443+0x1>, A

0000697c <.LM257>:
				valve.diag.ign.state = IGN_OFF;
    697c:	7001      	lod	A, #1

0000697e <.L547>:
		{
			valve.diag.ign.uvTimer++;
			if (valve.diag.ign.uvTimer >= IGN_ENTER_COUNT)
			{
				valve.diag.ign.uvTimer = 0u;
				valve.diag.ign.state = IGN_NORMAL;
    697e:	52d8 124c 	mov	0x124c <.LLST0+0x1a>, A

00006982 <.L150>:

static void ValvePowerOffTask(void)
{
	int16_t cOffset = 0, cPos = 0, diff = 0;

	if (valve.diag.ign.state == IGN_OFF)
    6982:	72d8 124c 	lod	A, 0x124c <.LLST0+0x1a>
    6986:	ac01      	cmp	A, #1
    6988:	1915      	je	0x69b4 <.L325>

0000698a <.L158>:
			}
		}
	}
	else
	{
		valve.ignOffCnt = 0;
    698a:	7000      	lod	A, #0
    698c:	52d8 1200 	mov	0x1200 <_valve+0x8>, A
    6990:	0030      	jmp	0x69f2 <.L548>

00006992 <.L148>:
			}
		}
		else
		{
#if 1
			if (valve.diag.ign.uvTimer > 0)
    6992:	2c00      	cmp	X, #0
    6994:	197a      	je	0x698a <.L158>

00006996 <.L571>:
		else
		{
#if 1
			if (valve.diag.ign.uvTimer > 0)
			{
				valve.diag.ign.uvTimer--;
    6996:	20ff      	add	X, #-1

00006998 <.L155>:
			ignNormalTimer += 1;
			if (ignNormalTimer >= 10u)
			{
				valve.diag.ign.state = IGN_NORMAL;
			}
			valve.diag.ign.uvTimer = 0u;
    6998:	5ed8 1250 	mov	0x1250 <.LASF1443+0x1>, X
    699c:	07f2      	jmp	0x6982 <.L150>

0000699e <.L147>:
    699e:	7ed8 1250 	lod	X, 0x1250 <.LASF1443+0x1>

000069a2 <.LM264>:
		}
		break;

	case IGN_OFF:

		if (valve.diag.ign.voltage >= IGN_UNDER_RETURN)
    69a2:	aeda 031f 	cmp	A, #799
    69a6:	1a2c      	jule	0x6a00 <.L151>

000069a8 <.LM265>:
		{
			valve.diag.ign.uvTimer++;
    69a8:	2001      	add	X, #1

000069aa <.LM266>:
			if (valve.diag.ign.uvTimer >= IGN_ENTER_COUNT)
    69aa:	2eda 01f3 	cmp	X, #499
    69ae:	1e24      	jug	0x69f8 <.L152>

000069b0 <.LM267>:

	case IGN_OFF:

		if (valve.diag.ign.voltage >= IGN_UNDER_RETURN)
		{
			valve.diag.ign.uvTimer++;
    69b0:	5ed8 1250 	mov	0x1250 <.LASF1443+0x1>, X

000069b4 <.L325>:
{
	int16_t cOffset = 0, cPos = 0, diff = 0;

	if (valve.diag.ign.state == IGN_OFF)
	{
		if (valve.ignOffCnt < 0xffffu)
    69b4:	72d8 1200 	lod	A, 0x1200 <_valve+0x8>
    69b8:	acff      	cmp	A, #-1
    69ba:	1903      	je	0x69c2 <.L159>

000069bc <.LM269>:
		{
			valve.ignOffCnt += 1;
    69bc:	a001      	add	A, #1
    69be:	52d8 1200 	mov	0x1200 <_valve+0x8>, A

000069c2 <.L159>:
		}

		if (valve.ignOffCnt >= 60000u) /*60sec*/
    69c2:	72d8 1200 	lod	A, 0x1200 <_valve+0x8>
    69c6:	aeda ea5f 	cmp	A, #59999
    69ca:	1e01      	jug	0x69ce <.LM271>
    69cc:	0066      	jmp	0x6a9a <.L160>

000069ce <.LM271>:
		{
			if (valve.sleepState == 0)
    69ce:	62d8 1202 	lod	AL, 0x1202 <_valve+0xa>
    69d2:	66e0      	lod	YL, AL
    69d4:	5cf6      	usex	Y
    69d6:	8c00      	cmp	AL, #0
    69d8:	1901      	je	0x69dc <.LM272>
    69da:	002e      	jmp	0x6a38 <.L161>

000069dc <.LM272>:
			{
				/*sleep ready -> calibration  (?  quick cal,  full cal */
				if ((check_fault_mode() == 0) && (check_protect_mode() == 0))
    69dc:	1562      	call	0x64a2 <_check_fault_mode>
    69de:	ac00      	cmp	A, #0
    69e0:	1d26      	jne	0x6a2e <.L162>
    69e2:	14fc      	call	0x63dc <_check_protect_mode>
    69e4:	ac00      	cmp	A, #0
    69e6:	1d23      	jne	0x6a2e <.L162>

000069e8 <.LM273>:
				{
					ValveFaultReset();
    69e8:	1520      	call	0x642a <_ValveFaultReset>

000069ea <.LM274>:
					valve.calibration.req1Cal = 1;
    69ea:	6001      	lod	AL, #1
    69ec:	42d8 1213 	mov	0x1213 <.LLST4+0xb>, AL

000069f0 <.L163>:
				else
				{
					ValveFaultReset();
					valve.calibration.req2Cal = 1;
				}
				valve.sleepState = 1;
    69f0:	6001      	lod	AL, #1

000069f2 <.L548>:
		}
	}
	else
	{
		valve.ignOffCnt = 0;
		valve.sleepState = 0;
    69f2:	42d8 1202 	mov	0x1202 <_valve+0xa>, AL
    69f6:	0051      	jmp	0x6a9a <.L160>

000069f8 <.L152>:
		if (valve.diag.ign.voltage >= IGN_UNDER_RETURN)
		{
			valve.diag.ign.uvTimer++;
			if (valve.diag.ign.uvTimer >= IGN_ENTER_COUNT)
			{
				valve.diag.ign.uvTimer = 0u;
    69f8:	7000      	lod	A, #0
    69fa:	52d8 1250 	mov	0x1250 <.LASF1443+0x1>, A
    69fe:	07bf      	jmp	0x697e <.L547>

00006a00 <.L151>:
			}
		}
		else
		{
#if 1
			if (valve.diag.ign.uvTimer > 0)
    6a00:	2c00      	cmp	X, #0
    6a02:	1958      	je	0x69b4 <.L325>
    6a04:	07c8      	jmp	0x6996 <.L571>

00006a06 <.L154>:
    6a06:	7c00      	lod	X, #0

00006a08 <.LM279>:
			{
				valve.diag.ign.state = IGN_NORMAL;
			}
			valve.diag.ign.uvTimer = 0u;
		}
		else if (valve.diag.ign.voltage < IGN_UNDER_STOP)
    6a08:	aeda 02bc 	cmp	A, #700
    6a0c:	190b      	je	0x6a24 <.L156>

00006a0e <.LM280>:
		{
			valve.diag.ign.voltage = 0;
    6a0e:	5ed8 124e 	mov	0x124e <.LLST0+0x1c>, X

00006a12 <.LM281>:
			valve.diag.ign.uvTimer++;
    6a12:	72d8 1250 	lod	A, 0x1250 <.LASF1443+0x1>
    6a16:	a001      	add	A, #1
    6a18:	52d8 1250 	mov	0x1250 <.LASF1443+0x1>, A

00006a1c <.LM282>:
			if (valve.diag.ign.uvTimer >= 10u)
    6a1c:	ac09      	cmp	A, #9
    6a1e:	1a01      	jule	0x6a22 <.LASF1067+0x1>
    6a20:	07aa      	jmp	0x6976 <.L157>
    6a22:	07af      	jmp	0x6982 <.L150>

00006a24 <.L156>:
				valve.diag.ign.state = IGN_OFF;
			}
		}
		else
		{
			valve.diag.ign.uvTimer = 0u;
    6a24:	5ed8 1250 	mov	0x1250 <.LASF1443+0x1>, X

00006a28 <.LM284>:
			ignNormalTimer = 0;
    6a28:	5ed8 10b2 	mov	0x10b2 <___ignNormalTimer_5863>, X
    6a2c:	07aa      	jmp	0x6982 <.L150>

00006a2e <.L162>:
					ValveFaultReset();
					valve.calibration.req1Cal = 1;
				}
				else
				{
					ValveFaultReset();
    6a2e:	14fd      	call	0x642a <_ValveFaultReset>

00006a30 <.LM286>:
					valve.calibration.req2Cal = 1;
    6a30:	6001      	lod	AL, #1
    6a32:	42d8 1212 	mov	0x1212 <.LLST4+0xa>, AL
    6a36:	07dc      	jmp	0x69f0 <.L163>

00006a38 <.L161>:
				}
				valve.sleepState = 1;
			}
			else
			{
				if (valve.state != VALVE_CALIBRATION)
    6a38:	72d8 11f8 	lod	A, 0x11f8 <_valve>
    6a3c:	ac05      	cmp	A, #5
    6a3e:	192d      	je	0x6a9a <.L160>

00006a40 <.LM288>:
				{
					if (valve.sleepState == 1)
    6a40:	ec01      	cmp	Y, #1
    6a42:	1d28      	jne	0x6a94 <.L164>

00006a44 <.LM289>:
					{
						/* */
						cOffset = get_gmr_sensor_offset();
    6a44:	82db 3bea 	callf	0x77d4 <_get_gmr_sensor_offset>

00006a48 <.LM290>:
						cPos = valve.pos.currentAngle;
    6a48:	7ad8 1208 	lod	Y, 0x1208 <.LLST4>

00006a4c <.LM291>:
						diff = cPos - valve.memory.lastAngle;
						if (diff < 0)
						{
							diff = -diff;
						}
						if ((cOffset != valve.memory.offset) || (diff > (int16_t)C_VALVE_ACCURACY_ANGLE))
    6a4c:	aed8 1230 	cmp	A, 0x1230 <.LLST6+0x11>
    6a50:	1d07      	jne	0x6a60 <.L165>

00006a52 <.LM292>:
					if (valve.sleepState == 1)
					{
						/* */
						cOffset = get_gmr_sensor_offset();
						cPos = valve.pos.currentAngle;
						diff = cPos - valve.memory.lastAngle;
    6a52:	7ee6      	lod	X, Y
    6a54:	2ad8 1232 	sub	X, 0x1232 <.LLST0>

00006a58 <.LM293>:
						if (diff < 0)
						{
							diff = -diff;
						}
						if ((cOffset != valve.memory.offset) || (diff > (int16_t)C_VALVE_ACCURACY_ANGLE))
    6a58:	1d81      	jnn	0x6a5c <.L575>
    6a5a:	5cce      	neg	X

00006a5c <.L575>:
    6a5c:	2c14      	cmp	X, #20
    6a5e:	1b06      	jsle	0x6a6c <.L166>

00006a60 <.L165>:
						{
							valve_gmr_write((uint16_t)cOffset, (uint16_t)cPos, 0x5555);
    6a60:	54ca 5555 	pushw	#21845

00006a64 <.LCFI3>:
    6a64:	5adf      	push	Y

00006a66 <.LCFI4>:
    6a66:	82db 43bc 	callf	0x8778 <_valve_gmr_write>

00006a6a <.LVL98>:
    6a6a:	5c03      	dec	S, #4

00006a6c <.L166>:
						}
						if ((u16EventState != valve.memory.state) || (u16EventValue != valve.memory.value))
    6a6c:	72d8 10b6 	lod	A, 0x10b6 <_u16EventState>
    6a70:	7ed8 10b4 	lod	X, 0x10b4 <_u16EventValue>
    6a74:	7ad8 122a 	lod	Y, 0x122a <.LLST6+0xb>
    6a78:	eee2      	cmp	Y, A
    6a7a:	1d04      	jne	0x6a84 <.L167>
    6a7c:	7ad8 122e 	lod	Y, 0x122e <.LLST6+0xf>
    6a80:	eeee      	cmp	Y, X
    6a82:	1906      	je	0x6a90 <.L168>

00006a84 <.L167>:
						{
							valve_diag_write(u16EventState, u16EventValue, 0xAAAA);
    6a84:	54ca aaaa 	pushw	#43690

00006a88 <.LCFI6>:
    6a88:	5edf      	push	X

00006a8a <.LCFI7>:
    6a8a:	82db 43ca 	callf	0x8794 <_valve_diag_write>
    6a8e:	5c03      	dec	S, #4

00006a90 <.L168>:
						}
						valve.sleepState = 2;
    6a90:	6002      	lod	AL, #2
    6a92:	07af      	jmp	0x69f2 <.L548>

00006a94 <.L164>:
					}
					else
					{
						MotRequestHardStop();
    6a94:	82db 3e17 	callf	0x7c2e <_MotRequestHardStop>

00006a98 <.LM299>:
						AppLinSleepEnter();
    6a98:	149c      	call	0x63d2 <_AppLinSleepEnter>

00006a9a <.L160>:
	valveDiagVs();
	valveDiagTemp();
	valveDiagIgn();

	ValvePowerOffTask();
	valve.motorMotion = MotGetState();
    6a9a:	82db 3e6b 	callf	0x7cd6 <_MotGetState>
    6a9e:	52d8 1204 	mov	0x1204 <_valve+0xc>, A

00006aa2 <.LM301>:
	valve.diag.motorFault = MotGetFaultState();
    6aa2:	82db 3e72 	callf	0x7ce4 <_MotGetFaultState>
    6aa6:	42d8 1263 	mov	0x1263 <.LLST6+0x11>, AL

00006aaa <.LM302>:
	valve.diag.stallFault = MotGetStallState();
    6aaa:	82db 3e6e 	callf	0x7cdc <_MotGetStallState>
    6aae:	42d8 1264 	mov	0x1264 <.LLST6+0x12>, AL

00006ab2 <.LBB302>:
		break;
	}
}
static void valveDiagSensor(void)
{
	uint8_t sensor_f = SensorGetState();
    6ab2:	82db 3e76 	callf	0x7cec <_SensorGetState>

00006ab6 <.LM304>:
	valve.diag.motorCurrent = get_conv_mot_current();
    6ab6:	5203      	mov	[S-4], A
    6ab8:	82db 3c53 	callf	0x78a6 <_get_conv_mot_current>

00006abc <.LVL107>:
    6abc:	52d8 1258 	mov	0x1258 <.LLST6+0x6>, A

00006ac0 <.LM305>:

	if ((valve.state != VALVE_CALIBRATION) && (valve.motorMotion == MOTION_RUNNING))
    6ac0:	7ed8 11f8 	lod	X, 0x11f8 <_valve>
    6ac4:	7a03      	lod	Y, [S-4]
    6ac6:	2c05      	cmp	X, #5
    6ac8:	1d01      	jne	0x6acc <.LASF1024+0x1>
    6aca:	0039      	jmp	0x6b3e <.L169>
    6acc:	7ed8 1204 	lod	X, 0x1204 <_valve+0xc>
    6ad0:	2c03      	cmp	X, #3
    6ad2:	1901      	je	0x6ad6 <.LASF1024+0xb>
    6ad4:	0034      	jmp	0x6b3e <.L169>
    6ad6:	7ed8 1256 	lod	X, 0x1256 <.LLST6+0x4>

00006ada <.LM306>:
	{

		if ((valve.diag.motorCurrent >= 500) && (sensor_f == C_STATUS_STOP))
    6ada:	aeda 01f3 	cmp	A, #499
    6ade:	1a2b      	jule	0x6b36 <.L170>
    6ae0:	ec02      	cmp	Y, #2
    6ae2:	1d29      	jne	0x6b36 <.L170>

00006ae4 <.LM307>:
		{

			valve.diag.gmr.count += 1;
    6ae4:	2001      	add	X, #1

00006ae6 <.L549>:
		}
		else
		{
			if (valve.diag.gmr.count > 0)
				valve.diag.gmr.count -= 1;
    6ae6:	5ed8 1256 	mov	0x1256 <.LLST6+0x4>, X

00006aea <.L171>:
		}

		if (valve.diag.gmr.count > 2000) /*20250715*/
    6aea:	72d8 1256 	lod	A, 0x1256 <.LLST6+0x4>
    6aee:	aeda 07d0 	cmp	A, #2000
    6af2:	1a07      	jule	0x6b02 <.L172>

00006af4 <.LM310>:
		{
			valve.diag.gmr.count = 0;
    6af4:	7000      	lod	A, #0
    6af6:	52d8 1256 	mov	0x1256 <.LLST6+0x4>, A

00006afa <.LM311>:
			valve.diag.gmr.state = 1;
    6afa:	6001      	lod	AL, #1
    6afc:	0ea7      	lod	C, ML.7
    6afe:	42d8 1252 	mov	0x1252 <.LLST6>, AL

00006b02 <.L172>:
	}
}
static void valveDiagMcu(void)
{
	static uint16_t LV_filterCnt = 0, HV_filterCnt = 0;
	uint16_t voltage = get_conv_vdda_voltage();
    6b02:	82db 3c42 	callf	0x7884 <_get_conv_vdda_voltage>
    6b06:	7ee2      	lod	X, A

00006b08 <.LM313>:
	if (valve.diag.McuFault == 0)
    6b08:	62d8 125c 	lod	AL, 0x125c <.LLST6+0xa>

00006b0c <.LVL110>:
    6b0c:	1901      	je	0x6b10 <.LVL110+0x4>
    6b0e:	0047      	jmp	0x6b9e <.L173>
    6b10:	66e0      	lod	YL, AL
    6b12:	5cf6      	usex	Y

00006b14 <.LM314>:
	{
		HV_filterCnt = 0;
    6b14:	5ad8 10b0 	mov	0x10b0 <___HV_filterCnt_5876>, Y
    6b18:	72d8 10ae 	lod	A, 0x10ae <___LV_filterCnt_5875>

00006b1c <.LM315>:
		if (voltage <= 300) /*scale: 10mV*/
    6b1c:	2eda 012c 	cmp	X, #300
    6b20:	1e12      	jug	0x6b46 <.L174>

00006b22 <.LM316>:
		{
			LV_filterCnt += 1;
    6b22:	a001      	add	A, #1
    6b24:	52d8 10ae 	mov	0x10ae <___LV_filterCnt_5875>, A

00006b28 <.LM317>:
			if (LV_filterCnt >= 500)
    6b28:	aeda 01f3 	cmp	A, #499
    6b2c:	1a11      	jule	0x6b50 <.L176>

00006b2e <.LM318>:
			{
				valve.diag.McuFault = 1;
    6b2e:	6001      	lod	AL, #1

00006b30 <.L550>:
		if (voltage >= 320) /*scale: 10mV*/
		{
			HV_filterCnt += 1;
			if (HV_filterCnt >= 500)
			{
				valve.diag.McuFault = 0;
    6b30:	42d8 125c 	mov	0x125c <.LLST6+0xa>, AL
    6b34:	000d      	jmp	0x6b50 <.L176>

00006b36 <.L170>:

			valve.diag.gmr.count += 1;
		}
		else
		{
			if (valve.diag.gmr.count > 0)
    6b36:	2c00      	cmp	X, #0
    6b38:	1958      	je	0x6aea <.L171>

00006b3a <.LM321>:
				valve.diag.gmr.count -= 1;
    6b3a:	20ff      	add	X, #-1
    6b3c:	07d4      	jmp	0x6ae6 <.L549>

00006b3e <.L169>:
			valve.diag.gmr.state = 1;
		}
	}
	else
	{
		valve.diag.gmr.count = 0;
    6b3e:	7000      	lod	A, #0
    6b40:	52d8 1256 	mov	0x1256 <.LLST6+0x4>, A
    6b44:	07de      	jmp	0x6b02 <.L172>

00006b46 <.L174>:
				valve.diag.McuFault = 1;
			}
		}
		else
		{
			if (LV_filterCnt > 0)
    6b46:	ac00      	cmp	A, #0
    6b48:	1903      	je	0x6b50 <.L176>

00006b4a <.LM324>:
				LV_filterCnt -= 1;
    6b4a:	a0ff      	add	A, #-1
    6b4c:	52d8 10ae 	mov	0x10ae <___LV_filterCnt_5875>, A

00006b50 <.L176>:
	valve.diag.motorFault = MotGetFaultState();
	valve.diag.stallFault = MotGetStallState();
	valveDiagSensor();
	valveDiagMcu();

	fault_err = check_fault_mode();
    6b50:	14a8      	call	0x64a2 <_check_fault_mode>
    6b52:	5205      	mov	[S-6], A

00006b54 <.LM326>:
	protect_mode = check_protect_mode();
    6b54:	1443      	call	0x63dc <_check_protect_mode>

00006b56 <.LVL116>:
    6b56:	5207      	mov	[S-8], A

00006b58 <.LM327>:
	if ((valve.state != VALVE_FAULT) && (fault_err != 0))
    6b58:	7ada 11f8 	lod	Y, #4600
    6b5c:	7ef0      	lod	X, [Y]
    6b5e:	2c06      	cmp	X, #6
    6b60:	1d01      	jne	0x6b64 <.LM328>
    6b62:	0033      	jmp	0x6bca <.L179>

00006b64 <.LM328>:
    6b64:	7205      	lod	A, [S-6]

00006b66 <.LVL118>:
    6b66:	1931      	je	0x6bca <.L179>

00006b68 <.LM329>:
	{

		valve.initStatus = 1;
    6b68:	6001      	lod	AL, #1
    6b6a:	42d8 1203 	mov	0x1203 <_valve+0xb>, AL

00006b6e <.LM330>:
		valve.elapsedTime = 0;
    6b6e:	7000      	lod	A, #0
    6b70:	0ea7      	lod	C, ML.7
    6b72:	52d8 11fe 	mov	0x11fe <_valve+0x6>, A

00006b76 <.LM331>:
		valve.lastState = valve.state;
    6b76:	5ed8 11fa 	mov	0x11fa <_valve+0x2>, X

00006b7a <.LM332>:
		valve.state = VALVE_FAULT;
    6b7a:	7006      	lod	A, #6
    6b7c:	52f0      	mov	[Y], A

00006b7e <.L180>:
	}
	else
	{
	}

	valve.pos.currentAngle = MotGetCurrentPosition();
    6b7e:	82db 3e36 	callf	0x7c6c <_MotGetCurrentPosition>
    6b82:	7ee2      	lod	X, A
    6b84:	52d8 1208 	mov	0x1208 <.LLST4>, A

00006b88 <.LBB311>:

static void calc_PosToLinData(int16_t currentAngle)
{
// #define CAL_POS_ANGLE_THD	(50* C_GMR_ANGLE_SCALE_FACTOR)
#define CAL_POS_ANGLE_THD (1 * C_GMR_ANGLE_SCALE_FACTOR)
	switch (valve.comm.actualMode)
    6b88:	62d8 1225 	lod	AL, 0x1225 <.LLST6+0x6>

00006b8c <.LVL121>:
    6b8c:	1d01      	jne	0x6b90 <.LASF1075+0x1>
    6b8e:	0031      	jmp	0x6bf2 <.L182>
    6b90:	66e0      	lod	YL, AL
    6b92:	5cf6      	usex	Y
    6b94:	ec01      	cmp	Y, #1
    6b96:	1d01      	jne	0x6b9a <.L537>
    6b98:	0045      	jmp	0x6c24 <.L183>

00006b9a <.L537>:
		else
		{
		}
		break;
	default:
		valve.comm.actualMode = C_MODE_B;
    6b9a:	6001      	lod	AL, #1
    6b9c:	0049      	jmp	0x6c30 <.L551>

00006b9e <.L173>:
				LV_filterCnt -= 1;
		}
	}
	else
	{
		LV_filterCnt = 0;
    6b9e:	7000      	lod	A, #0
    6ba0:	52d8 10ae 	mov	0x10ae <___LV_filterCnt_5875>, A
    6ba4:	7ad8 10b0 	lod	Y, 0x10b0 <___HV_filterCnt_5876>

00006ba8 <.LM337>:
		if (voltage >= 320) /*scale: 10mV*/
    6ba8:	0ea7      	lod	C, ML.7
    6baa:	2eda 013f 	cmp	X, #319
    6bae:	1a07      	jule	0x6bbe <.L178>

00006bb0 <.LM338>:
		{
			HV_filterCnt += 1;
    6bb0:	e001      	add	Y, #1
    6bb2:	5ad8 10b0 	mov	0x10b0 <___HV_filterCnt_5876>, Y

00006bb6 <.LM339>:
			if (HV_filterCnt >= 500)
    6bb6:	eeda 01f3 	cmp	Y, #499
    6bba:	1a4a      	jule	0x6b50 <.L176>
    6bbc:	07b9      	jmp	0x6b30 <.L550>

00006bbe <.L178>:
				valve.diag.McuFault = 0;
			}
		}
		else
		{
			if (HV_filterCnt > 0)
    6bbe:	ec00      	cmp	Y, #0
    6bc0:	1947      	je	0x6b50 <.L176>

00006bc2 <.LM341>:
				HV_filterCnt -= 1;
    6bc2:	e0ff      	add	Y, #-1
    6bc4:	5ad8 10b0 	mov	0x10b0 <___HV_filterCnt_5876>, Y
    6bc8:	07c3      	jmp	0x6b50 <.L176>

00006bca <.L179>:
		valve.initStatus = 1;
		valve.elapsedTime = 0;
		valve.lastState = valve.state;
		valve.state = VALVE_FAULT;
	}
	else if ((valve.state != VALVE_FAULT) && (valve.state != VALVE_PROTECTION) && (protect_mode != 0))
    6bca:	7aee      	lod	Y, X
    6bcc:	e0fa      	add	Y, #-6
    6bce:	ec01      	cmp	Y, #1
    6bd0:	1a56      	jule	0x6b7e <.L180>

00006bd2 <.LM343>:
    6bd2:	7207      	lod	A, [S-8]
    6bd4:	1954      	je	0x6b7e <.L180>

00006bd6 <.LM344>:
	{
		valve.initStatus = 1;
    6bd6:	6001      	lod	AL, #1
    6bd8:	42d8 1203 	mov	0x1203 <_valve+0xb>, AL

00006bdc <.LM345>:
		valve.elapsedTime = 0;
    6bdc:	7000      	lod	A, #0
    6bde:	0ea7      	lod	C, ML.7
    6be0:	52d8 11fe 	mov	0x11fe <_valve+0x6>, A

00006be4 <.LM346>:
		valve.lastState = valve.state;
    6be4:	5ed8 11fa 	mov	0x11fa <_valve+0x2>, X

00006be8 <.LM347>:
		valve.state = VALVE_PROTECTION;
    6be8:	7007      	lod	A, #7
    6bea:	0ea7      	lod	C, ML.7
    6bec:	52d8 11f8 	mov	0x11f8 <_valve>, A
    6bf0:	07c6      	jmp	0x6b7e <.L180>

00006bf2 <.L182>:
// #define CAL_POS_ANGLE_THD	(50* C_GMR_ANGLE_SCALE_FACTOR)
#define CAL_POS_ANGLE_THD (1 * C_GMR_ANGLE_SCALE_FACTOR)
	switch (valve.comm.actualMode)
	{
	case C_MODE_A:
		if (currentAngle <= (valve.pos.modeAngle[C_MODE_B] + (int16_t)CAL_POS_ANGLE_THD))
    6bf2:	72d8 120c 	lod	A, 0x120c <.LLST4+0x4>
    6bf6:	a00a      	add	A, #10
    6bf8:	2ee2      	cmp	X, A
    6bfa:	1b4f      	jsle	0x6b9a <.L537>

00006bfc <.L184>:
	{
	}

	valve.pos.currentAngle = MotGetCurrentPosition();
	calc_PosToLinData(valve.pos.currentAngle);
	if ((valve.motorMotion >= MOTION_ACC) && (valve.motorMotion <= MOTION_DEC))
    6bfc:	7ad8 1204 	lod	Y, 0x1204 <_valve+0xc>
    6c00:	5a01      	mov	[S-2], Y
    6c02:	72e6      	lod	A, Y
    6c04:	a0fe      	add	A, #-2
    6c06:	ac02      	cmp	A, #2
    6c08:	1e16      	jug	0x6c36 <.L185>

00006c0a <.LM350>:
	{
		valve.comm.moving = 1;
    6c0a:	6001      	lod	AL, #1

00006c0c <.L552>:
	}
	else
	{
		valve.comm.moving = 0;
    6c0c:	42d8 1226 	mov	0x1226 <.LLST6+0x7>, AL

00006c10 <.LM352>:
	}
	switch (valve.state)
    6c10:	72d8 11f8 	lod	A, 0x11f8 <_valve>
    6c14:	ac0a      	cmp	A, #10
    6c16:	1a01      	jule	0x6c1a <.LM352+0xa>
    6c18:	0035      	jmp	0x6c84 <.L561>
    6c1a:	4422      	asl	A
    6c1c:	a2da 5cc2 	add	A, #23746
    6c20:	7ae2      	lod	Y, A
    6c22:	76f0      	jmp	[Y]

00006c24 <.L183>:
		else
		{
		}
		break;
	case C_MODE_B:
		if (currentAngle >= (valve.pos.modeAngle[C_MODE_A] - (int16_t)CAL_POS_ANGLE_THD))
    6c24:	72d8 120a 	lod	A, 0x120a <.LLST4+0x2>
    6c28:	a0f6      	add	A, #-10
    6c2a:	2ee2      	cmp	X, A
    6c2c:	1ae7      	jsl	0x6bfc <.L184>

00006c2e <.LM354>:
		{
			valve.comm.actualMode = C_MODE_A;
    6c2e:	6000      	lod	AL, #0

00006c30 <.L551>:
		else
		{
		}
		break;
	default:
		valve.comm.actualMode = C_MODE_B;
    6c30:	42d8 1225 	mov	0x1225 <.LLST6+0x6>, AL
    6c34:	07e3      	jmp	0x6bfc <.L184>

00006c36 <.L185>:
	{
		valve.comm.moving = 1;
	}
	else
	{
		valve.comm.moving = 0;
    6c36:	6000      	lod	AL, #0
    6c38:	07e9      	jmp	0x6c0c <.L552>

00006c3a <.L188>:

#endif
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    6c3a:	5ed8 1206 	mov	0x1206 <_valve+0xe>, X

00006c3e <.LBE320>:
{
	tValveState nextState = VALVE_INIT;
	int16_t diff = 0;

	ValveTargetAngleUpdate(valve.pos.currentAngle);
	MotSetTargetPosition(valve.pos.targetAngle);
    6c3e:	72ee      	lod	A, X
    6c40:	82db 3e1f 	callf	0x7c3e <_MotSetTargetPosition>

00006c44 <.LM359>:
	if ((valve.diag.ign.state == IGN_NORMAL) && (valve.elapsedTime >= 5u))
    6c44:	72d8 124c 	lod	A, 0x124c <.LLST0+0x1a>
    6c48:	1902      	je	0x6c4e <.LASF1029+0x2>
    6c4a:	76da 3a80 	jmpf	0x7500 <.L326>
    6c4e:	7ed8 11fe 	lod	X, 0x11fe <_valve+0x6>
    6c52:	2c04      	cmp	X, #4
    6c54:	1e01      	jug	0x6c58 <.LM360>
    6c56:	0050      	jmp	0x6cf8 <.L200>

00006c58 <.LM360>:
	{
		if (u16EventState == VALVE_CAL_FAULT)
    6c58:	72d8 10b6 	lod	A, 0x10b6 <_u16EventState>
    6c5c:	ac09      	cmp	A, #9
    6c5e:	1d03      	jne	0x6c66 <.L201>

00006c60 <.LM361>:
		{
			valve.calibration.req2Cal = 1;
    6c60:	6001      	lod	AL, #1
    6c62:	42d8 1212 	mov	0x1212 <.LLST4+0xa>, AL

00006c66 <.L201>:
		}
		if (valve.memory.lastAngle != 0)
    6c66:	7ed8 1232 	lod	X, 0x1232 <.LLST0>
    6c6a:	72d8 1208 	lod	A, 0x1208 <.LLST4>
    6c6e:	2c00      	cmp	X, #0
    6c70:	190b      	je	0x6c88 <.L202>

00006c72 <.L572>:
		{
			diff = valve.pos.currentAngle - valve.memory.lastAngle;
    6c72:	aaee      	sub	A, X

00006c74 <.L553>:
			if (diff < 0)
			{
				diff = -diff;
			}
			if (diff > (int16_t)C_VALVE_ACCURACY_ANGLE)
    6c74:	ac00      	cmp	A, #0
    6c76:	1d81      	jnn	0x6c7a <.L576>
    6c78:	5cc2      	neg	A

00006c7a <.L576>:
    6c7a:	ac14      	cmp	A, #20
    6c7c:	1b03      	jsle	0x6c84 <.L561>

00006c7e <.LM365>:
			{

				valve.calibration.req2Cal = 1;
    6c7e:	6001      	lod	AL, #1

00006c80 <.LVL133>:
    6c80:	42d8 1212 	mov	0x1212 <.LLST4+0xa>, AL

00006c84 <.L561>:
		break;
	case CALSTEP_COMPLETED:

		valve.calibration.req2Cal = 0;
		valve.calibration.req1Cal = 0;
		nextState = VALVE_STANDBY;
    6c84:	7001      	lod	A, #1
    6c86:	0038      	jmp	0x6cf8 <.L200>

00006c88 <.L202>:
			}
		}
		else
		{

			if (valve.pos.currentAngle <= (valve.pos.modeAngle[C_MODE_B] + (int16_t)(45 * C_GMR_ANGLE_SCALE_FACTOR)))
    6c88:	7ed8 120c 	lod	X, 0x120c <.LLST4+0x4>
    6c8c:	7aee      	lod	Y, X
    6c8e:	e2da 01c2 	add	Y, #450
    6c92:	eee2      	cmp	Y, A
    6c94:	1eee      	jsge	0x6c72 <.L572>

00006c96 <.LM368>:
			{
				diff = valve.pos.currentAngle - valve.pos.modeAngle[C_MODE_B];
			}
			else
			{
				diff = valve.pos.currentAngle - valve.pos.modeAngle[C_MODE_A];
    6c96:	aad8 120a 	sub	A, 0x120a <.LLST4+0x2>
    6c9a:	07ec      	jmp	0x6c74 <.L553>

00006c9c <.L190>:
{

	tValveState nextState = VALVE_STANDBY;
	int16_t diffPos;

	if (valve.initStatus != 0)
    6c9c:	62d8 1203 	lod	AL, 0x1203 <_valve+0xb>
    6ca0:	1903      	je	0x6ca8 <.L207>

00006ca2 <.LM370>:
	{
		valve.initStatus = 0;
    6ca2:	6000      	lod	AL, #0
    6ca4:	42d8 1203 	mov	0x1203 <_valve+0xb>, AL

00006ca8 <.L207>:
	}

	MotRequestHardStop();
    6ca8:	82db 3e17 	callf	0x7c2e <_MotRequestHardStop>

00006cac <.LM372>:

	if ((valve.calibration.req2Cal == 1) || (valve.calibration.req1Cal == 1))
    6cac:	62d8 1212 	lod	AL, 0x1212 <.LLST4+0xa>
    6cb0:	8c01      	cmp	AL, #1
    6cb2:	1d01      	jne	0x6cb6 <.LM372+0xa>
    6cb4:	0106      	jmp	0x6ec2 <.L567>
    6cb6:	62d8 1213 	lod	AL, 0x1213 <.LLST4+0xb>
    6cba:	8c01      	cmp	AL, #1
    6cbc:	1d01      	jne	0x6cc0 <.LM373>
    6cbe:	0101      	jmp	0x6ec2 <.L567>

00006cc0 <.LM373>:
	{

		nextState = VALVE_CALIBRATION;
	}
	else if (valve.comm.ForcedDiag != 0)
    6cc0:	62d8 1223 	lod	AL, 0x1223 <.LLST6+0x4>
    6cc4:	1902      	je	0x6cca <.L208>

00006cc6 <.L563>:
}

static tValveState ValveDiagRunTask(void)
{

	tValveState nextState = VALVE_DIAGRUN;
    6cc6:	7004      	lod	A, #4
    6cc8:	0017      	jmp	0x6cf8 <.L200>

00006cca <.L208>:
	else if (valve.comm.ForcedDiag != 0)
	{

		nextState = VALVE_DIAGRUN;
	}
	else if (valve.comm.Enable != 0)
    6cca:	62d8 1221 	lod	AL, 0x1221 <.LLST6+0x2>
    6cce:	195a      	je	0x6c84 <.L561>

00006cd0 <.LM376>:
	{

		if (valve.pos.targetAngle > valve.pos.currentAngle)
    6cd0:	7ed8 1206 	lod	X, 0x1206 <_valve+0xe>
    6cd4:	72d8 1208 	lod	A, 0x1208 <.LLST4>
    6cd8:	2ee2      	cmp	X, A
    6cda:	1f01      	jsg	0x6cde <.LM377>
    6cdc:	003d      	jmp	0x6d58 <.L209>

00006cde <.LM377>:
		{
			diffPos = valve.pos.targetAngle - valve.pos.currentAngle;
    6cde:	2ae2      	sub	X, A

00006ce0 <.L210>:
		{

			nextState = VALVE_READY;
		}
#else
		if ((valve.comm.lastMode != valve.comm.targetMode) && (diffPos >= (int16_t)C_VALVE_ACCURACY_ANGLE))
    6ce0:	66d8 1220 	lod	YL, 0x1220 <.LLST6+0x1>
    6ce4:	62d8 1224 	lod	AL, 0x1224 <.LLST6+0x5>
    6ce8:	8ee8      	cmp	AL, YL
    6cea:	1d01      	jne	0x6cee <.LM379>
    6cec:	0038      	jmp	0x6d5e <.L330>

00006cee <.LM379>:
		{

			nextState = VALVE_READY;
    6cee:	2c13      	cmp	X, #19
    6cf0:	5cb2      	ssg	A
    6cf2:	a001      	add	A, #1

00006cf4 <.L211>:
		}
#endif
		valve.comm.lastMode = valve.comm.targetMode;
    6cf4:	46d8 1224 	mov	0x1224 <.LLST6+0x5>, YL

00006cf8 <.L200>:
		nextState = VALVE_STANDBY;
		break;
	}

	/* state changed */
	if (valve.state != nextState)
    6cf8:	7ed8 11f8 	lod	X, 0x11f8 <_valve>
    6cfc:	2ee2      	cmp	X, A
    6cfe:	1d01      	jne	0x6d02 <.LM382>
    6d00:	01a6      	jmp	0x704e <.L318>

00006d02 <.LM382>:
	{

		valve.initStatus = 1;
    6d02:	6401      	lod	YL, #1
    6d04:	46d8 1203 	mov	0x1203 <_valve+0xb>, YL

00006d08 <.LM383>:
		valve.elapsedTime = 0;
    6d08:	7800      	lod	Y, #0
    6d0a:	0ea7      	lod	C, ML.7
    6d0c:	5ad8 11fe 	mov	0x11fe <_valve+0x6>, Y

00006d10 <.LM384>:
		if (valve.state != VALVE_LOWPOWER)
    6d10:	2c09      	cmp	X, #9
    6d12:	1902      	je	0x6d18 <.L319>

00006d14 <.LM385>:
		{
			valve.lastState = valve.state;
    6d14:	5ed8 11fa 	mov	0x11fa <_valve+0x2>, X

00006d18 <.L319>:
		}
		valve.state = nextState;
    6d18:	52d8 11f8 	mov	0x11f8 <_valve>, A

00006d1c <.L320>:
	{
		if (valve.elapsedTime < 0xffffu)
			valve.elapsedTime += 1;
	}

	if (valve.linLiveTimeOut > 0)
    6d1c:	72d8 11fc 	lod	A, 0x11fc <_valve+0x4>
    6d20:	1d01      	jne	0x6d24 <.LM388>
    6d22:	03f4      	jmp	0x750c <.L321>

00006d24 <.LM388>:
	{
		valve.linLiveTimeOut -= 1;
    6d24:	a0ff      	add	A, #-1
    6d26:	52d8 11fc 	mov	0x11fc <_valve+0x4>, A

00006d2a <.L322>:
	else
	{
		valve.diag.linError = 1;
	}
	//	valve.comm.actualMode
	if (Fwv_Request_Event != 0)
    6d2a:	62d8 10ab 	lod	AL, 0x10ab <_Fwv_Request_Event>
    6d2e:	1908      	je	0x6d40 <.L323>

00006d30 <.LM390>:
	{
		Fwv_Request_Event = 0;
    6d30:	6000      	lod	AL, #0
    6d32:	42d8 10ab 	mov	0x10ab <_Fwv_Request_Event>, AL

00006d36 <.LM391>:
		//		ValveLinGetCommand();
		valve.linLiveTimeOut = 4000;
    6d36:	72da 0fa0 	lod	A, #4000
    6d3a:	0ea7      	lod	C, ML.7
    6d3c:	52d8 11fc 	mov	0x11fc <_valve+0x4>, A

00006d40 <.L323>:
	}
	if (Fwv_Response_Event != 0)
    6d40:	62d8 10aa 	lod	AL, 0x10aa <__data_end>
    6d44:	1908      	je	0x6d56 <.L118>

00006d46 <.LM393>:
	{
		Fwv_Response_Event = 0;
    6d46:	6000      	lod	AL, #0
    6d48:	42d8 10aa 	mov	0x10aa <__data_end>, AL

00006d4c <.LM394>:
		//		ValveLinUpdateSignals();
		valve.linLiveTimeOut = 4000;
    6d4c:	72da 0fa0 	lod	A, #4000
    6d50:	0ea7      	lod	C, ML.7
    6d52:	52d8 11fc 	mov	0x11fc <_valve+0x4>, A

00006d56 <.L118>:
	}
}
    6d56:	5409      	ret	#10

00006d58 <.L209>:
		{
			diffPos = valve.pos.targetAngle - valve.pos.currentAngle;
		}
		else
		{
			diffPos = valve.pos.currentAngle - valve.pos.targetAngle;
    6d58:	aaee      	sub	A, X
    6d5a:	7ee2      	lod	X, A

00006d5c <.LVL146>:
    6d5c:	07c1      	jmp	0x6ce0 <.L210>

00006d5e <.L330>:
}

static tValveState ValveStandbyTask(void)
{

	tValveState nextState = VALVE_STANDBY;
    6d5e:	7001      	lod	A, #1
    6d60:	07c9      	jmp	0x6cf4 <.L211>

00006d62 <.L191>:
static tValveState ValveReadyTask(void)
{

	tValveState nextState = VALVE_READY;

	if (valve.initStatus != 0)
    6d62:	62d8 1203 	lod	AL, 0x1203 <_valve+0xb>
    6d66:	1905      	je	0x6d72 <.L212>

00006d68 <.LM399>:
	{
		valve.initStatus = 0;
    6d68:	6000      	lod	AL, #0
    6d6a:	42d8 1203 	mov	0x1203 <_valve+0xb>, AL

00006d6e <.LM400>:
		MotClearHardStop();
    6d6e:	82db 3e1b 	callf	0x7c36 <_MotClearHardStop>

00006d72 <.L212>:
	}

	MotSetTargetPosition(valve.pos.targetAngle);
    6d72:	72d8 1206 	lod	A, 0x1206 <_valve+0xe>
    6d76:	82db 3e1f 	callf	0x7c3e <_MotSetTargetPosition>

00006d7a <.L332>:
}

static tValveState ValveOperationTask(void)
{

	tValveState nextState = VALVE_OPERATION;
    6d7a:	7003      	lod	A, #3
    6d7c:	07bd      	jmp	0x6cf8 <.L200>

00006d7e <.L192>:
	int16_t actualPos;

	if (valve.initStatus != 0)
    6d7e:	62d8 1203 	lod	AL, 0x1203 <_valve+0xb>
    6d82:	1905      	je	0x6d8e <.L213>

00006d84 <.LM404>:
	{
		valve.initStatus = 0;
    6d84:	6000      	lod	AL, #0
    6d86:	42d8 1203 	mov	0x1203 <_valve+0xb>, AL

00006d8a <.LM405>:

		MotClearHardStop();
    6d8a:	82db 3e1b 	callf	0x7c36 <_MotClearHardStop>

00006d8e <.L213>:
	}

	if (valve.elapsedTime >= valve.comm.timeOut)
    6d8e:	72d8 11fe 	lod	A, 0x11fe <_valve+0x6>
    6d92:	aed8 121e 	cmp	A, 0x121e <.LASF1692>
    6d96:	1805      	jc	0x6da2 <.L214>

00006d98 <.LM407>:
	{

		valve.pos.fault = 1;
    6d98:	6001      	lod	AL, #1
    6d9a:	42d8 120e 	mov	0x120e <.LLST4+0x6>, AL

00006d9e <.L314>:
				valve.pos.fault = 1;
			}
#endif
			if (valve.pos.fault != 0)
			{
				nextState = VALVE_PROTECTION;
    6d9e:	7007      	lod	A, #7
    6da0:	07ab      	jmp	0x6cf8 <.L200>

00006da2 <.L214>:
		else
		{
			nextState = VALVE_STANDBY;
		}
#else
		if ((valve.motorMotion >= MOTION_ACC) && (valve.motorMotion <= MOTION_DEC))
    6da2:	72d8 1204 	lod	A, 0x1204 <_valve+0xc>
    6da6:	a0fe      	add	A, #-2
    6da8:	ac02      	cmp	A, #2
    6daa:	1a67      	jule	0x6d7a <.L332>

00006dac <.LM410>:
		{
		}
		else
		{

			actualPos = valve.pos.currentAngle;
    6dac:	7ed8 1208 	lod	X, 0x1208 <.LLST4>

00006db0 <.LM411>:
				
				}
			}
			else {}
#else
			if ((actualPos >= (valve.pos.modeAngle[C_MODE_A] - (int16_t)C_VALVE_ACCURACY_ANGLE)) && (actualPos <= (valve.pos.modeAngle[C_MODE_A] + (int16_t)C_VALVE_ACCURACY_ANGLE)))
    6db0:	72d8 120a 	lod	A, 0x120a <.LLST4+0x2>
    6db4:	7ae2      	lod	Y, A
    6db6:	e0ec      	add	Y, #-20
    6db8:	2ee6      	cmp	X, Y
    6dba:	1a83      	jsl	0x6dc2 <.L215>
    6dbc:	a014      	add	A, #20
    6dbe:	2ee2      	cmp	X, A
    6dc0:	1b0c      	jsle	0x6dda <.L216>

00006dc2 <.L215>:
			{
			}
			else if ((actualPos >= (valve.pos.modeAngle[C_MODE_B] - (int16_t)C_VALVE_ACCURACY_ANGLE)) && (actualPos <= (valve.pos.modeAngle[C_MODE_B] + (int16_t)C_VALVE_ACCURACY_ANGLE)))
    6dc2:	72d8 120c 	lod	A, 0x120c <.LLST4+0x4>
    6dc6:	7ae2      	lod	Y, A
    6dc8:	e0ec      	add	Y, #-20
    6dca:	2ee6      	cmp	X, Y
    6dcc:	1a83      	jsl	0x6dd4 <.L217>
    6dce:	a014      	add	A, #20
    6dd0:	2ee2      	cmp	X, A
    6dd2:	1b03      	jsle	0x6dda <.L216>

00006dd4 <.L217>:
			{
			}
			else
			{
				valve.pos.fault = 1;
    6dd4:	6001      	lod	AL, #1
    6dd6:	42d8 120e 	mov	0x120e <.LLST4+0x6>, AL

00006dda <.L216>:
			}
#endif
			if (valve.pos.fault != 0)
    6dda:	62d8 120e 	lod	AL, 0x120e <.LLST4+0x6>

00006dde <.L555>:
    6dde:	8c00      	cmp	AL, #0
    6de0:	1d01      	jne	0x6de4 <.LASF1037+0x2>
    6de2:	0750      	jmp	0x6c84 <.L561>
    6de4:	07dc      	jmp	0x6d9e <.L314>

00006de6 <.L193>:
static tValveState ValveDiagRunTask(void)
{

	tValveState nextState = VALVE_DIAGRUN;

	if (valve.initStatus != 0)
    6de6:	62d8 1203 	lod	AL, 0x1203 <_valve+0xb>
    6dea:	1909      	je	0x6dfe <.L218>

00006dec <.LM416>:
	{
		valve.initStatus = 0;
    6dec:	6000      	lod	AL, #0
    6dee:	42d8 1203 	mov	0x1203 <_valve+0xb>, AL

00006df2 <.LM417>:
		valve.test.step = 0;
    6df2:	7000      	lod	A, #0
    6df4:	0ea7      	lod	C, ML.7
    6df6:	52d8 1228 	mov	0x1228 <.LLST6+0x9>, A

00006dfa <.LM418>:
		MotClearHardStop();
    6dfa:	82db 3e1b 	callf	0x7c36 <_MotClearHardStop>

00006dfe <.L218>:
	}
	valve.comm.lastMode = 0xff;
    6dfe:	60ff      	lod	AL, #-1
    6e00:	42d8 1224 	mov	0x1224 <.LLST6+0x5>, AL

00006e04 <.LM420>:
	if (valve.comm.ForcedDiag == 0)
    6e04:	62d8 1223 	lod	AL, 0x1223 <.LLST6+0x4>
    6e08:	1d05      	jne	0x6e14 <.L219>

00006e0a <.LM421>:
	{
		if (valve.comm.moving == 0)
    6e0a:	62d8 1226 	lod	AL, 0x1226 <.LLST6+0x7>
    6e0e:	1d01      	jne	0x6e12 <.LM421+0x8>
    6e10:	0739      	jmp	0x6c84 <.L561>
    6e12:	0759      	jmp	0x6cc6 <.L563>

00006e14 <.L219>:
		}
	}
	else
	{
		/* B->A->B*/
		if ((valve.motorMotion >= MOTION_ACC) && (valve.motorMotion <= MOTION_DEC))
    6e14:	72d8 1204 	lod	A, 0x1204 <_valve+0xc>
    6e18:	a0fe      	add	A, #-2
    6e1a:	ac02      	cmp	A, #2
    6e1c:	1e04      	jug	0x6e26 <.L221>

00006e1e <.LM423>:
		{
			valve.elapsedTime = 0;
    6e1e:	7000      	lod	A, #0
    6e20:	52d8 11fe 	mov	0x11fe <_valve+0x6>, A
    6e24:	0750      	jmp	0x6cc6 <.L563>

00006e26 <.L221>:
		}
		else
		{

			if (valve.elapsedTime >= 2000u)
    6e26:	72d8 11fe 	lod	A, 0x11fe <_valve+0x6>
    6e2a:	aeda 07cf 	cmp	A, #1999
    6e2e:	1e01      	jug	0x6e32 <.LM425>
    6e30:	074a      	jmp	0x6cc6 <.L563>

00006e32 <.LM425>:
			{
				if (valve.test.step == 0)
    6e32:	72d8 1228 	lod	A, 0x1228 <.LLST6+0x9>
    6e36:	1d06      	jne	0x6e44 <.L222>

00006e38 <.LM426>:
				{
					valve.test.step = 1;
    6e38:	7001      	lod	A, #1

00006e3a <.L564>:
					ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_A]);
					MotSetTargetPosition(valve.pos.targetAngle);
				}
				else if (valve.test.step == 2) /*20250714*/
				{
					valve.test.step = 3;
    6e3a:	52d8 1228 	mov	0x1228 <.LLST6+0x9>, A

00006e3e <.LM428>:
					ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]);
    6e3e:	72d8 120c 	lod	A, 0x120c <.LLST4+0x4>
    6e42:	0007      	jmp	0x6e52 <.L562>

00006e44 <.L222>:
				{
					valve.test.step = 1;
					ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]);
					MotSetTargetPosition(valve.pos.targetAngle);
				}
				else if (valve.test.step == 1)
    6e44:	ac01      	cmp	A, #1
    6e46:	1d0a      	jne	0x6e5c <.L223>

00006e48 <.LM430>:
				{
#if 0
					valve.test.step=0;
#else
					valve.test.step = 2;
    6e48:	7002      	lod	A, #2
    6e4a:	52d8 1228 	mov	0x1228 <.LLST6+0x9>, A

00006e4e <.LM431>:
#endif
					ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_A]);
    6e4e:	72d8 120a 	lod	A, 0x120a <.LLST4+0x2>

00006e52 <.L562>:

#endif
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    6e52:	52d8 1206 	mov	0x1206 <_valve+0xe>, A

00006e56 <.LBE350>:
				}
				else if (valve.test.step == 2) /*20250714*/
				{
					valve.test.step = 3;
					ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]);
					MotSetTargetPosition(valve.pos.targetAngle);
    6e56:	82db 3e1f 	callf	0x7c3e <_MotSetTargetPosition>
    6e5a:	0735      	jmp	0x6cc6 <.L563>

00006e5c <.L223>:
					valve.test.step = 2;
#endif
					ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_A]);
					MotSetTargetPosition(valve.pos.targetAngle);
				}
				else if (valve.test.step == 2) /*20250714*/
    6e5c:	ac02      	cmp	A, #2
    6e5e:	1901      	je	0x6e62 <.LM435>
    6e60:	0732      	jmp	0x6cc6 <.L563>

00006e62 <.LM435>:
				{
					valve.test.step = 3;
    6e62:	7003      	lod	A, #3
    6e64:	07ea      	jmp	0x6e3a <.L564>

00006e66 <.L194>:
{
	tValveState nextState = VALVE_CALIBRATION;
	int16_t diff;
	uint16_t timeOut;

	if (valve.calibration.req2Cal)
    6e66:	62d8 1212 	lod	AL, 0x1212 <.LLST4+0xa>
    6e6a:	66e0      	lod	YL, AL
    6e6c:	5cf6      	usex	Y
    6e6e:	5a07      	mov	[S-8], Y

00006e70 <.LVL163>:
    6e70:	8c00      	cmp	AL, #0
    6e72:	191c      	je	0x6eac <.L333>

00006e74 <.LM437>:
	{
		timeOut = 20000;
    6e74:	7ada 4e20 	lod	Y, #20000

00006e78 <.L556>:
	}
	else
	{
		timeOut = 6000;
    6e78:	5a05      	mov	[S-6], Y

00006e7a <.LM439>:
	}
	// uint16_t state,value;
	if (valve.initStatus != 0)
    6e7a:	62d8 1203 	lod	AL, 0x1203 <_valve+0xb>
    6e7e:	1908      	je	0x6e90 <.L225>

00006e80 <.LM440>:
	{
		valve.initStatus = 0;
    6e80:	6000      	lod	AL, #0
    6e82:	42d8 1203 	mov	0x1203 <_valve+0xb>, AL

00006e86 <.LM441>:
		valve.calibration.state = CALSTEP_RESET;
    6e86:	42d8 1210 	mov	0x1210 <.LLST4+0x8>, AL

00006e8a <.LM442>:
		valve.diag.calFault = 0;
    6e8a:	0ea7      	lod	C, ML.7
    6e8c:	42d8 1262 	mov	0x1262 <.LLST6+0x10>, AL

00006e90 <.L225>:
	}
	valve.comm.lastMode = 0xff;
    6e90:	60ff      	lod	AL, #-1
    6e92:	42d8 1224 	mov	0x1224 <.LLST6+0x5>, AL

00006e96 <.LM444>:
	switch (valve.calibration.state)
    6e96:	62d8 1210 	lod	AL, 0x1210 <.LLST4+0x8>
    6e9a:	5cf2      	usex	A
    6e9c:	ac09      	cmp	A, #9
    6e9e:	1a01      	jule	0x6ea2 <.LASF1080+0x3>
    6ea0:	06f1      	jmp	0x6c84 <.L561>
    6ea2:	4422      	asl	A
    6ea4:	a2da 5cd8 	add	A, #23768
    6ea8:	7ae2      	lod	Y, A

00006eaa <.LVL165>:
    6eaa:	76f0      	jmp	[Y]

00006eac <.L333>:
	{
		timeOut = 20000;
	}
	else
	{
		timeOut = 6000;
    6eac:	7ada 1770 	lod	Y, #6000
    6eb0:	07e3      	jmp	0x6e78 <.L556>

00006eb2 <.L226>:
	}
	valve.comm.lastMode = 0xff;
	switch (valve.calibration.state)
	{
	case CALSTEP_RESET:
		MotClearStallFlag(0); /* clear stall flag if set */
    6eb2:	7000      	lod	A, #0
    6eb4:	82db 3e39 	callf	0x7c72 <_MotClearStallFlag>

00006eb8 <.LM447>:
		MotRequestHardStop();
    6eb8:	82db 3e17 	callf	0x7c2e <_MotRequestHardStop>

00006ebc <.LM448>:
		valve.calibration.state = CALSTEP_START;
    6ebc:	6001      	lod	AL, #1

00006ebe <.L565>:
		valve.calibration.timer = 0;
		if (valve.calibration.req2Cal != 0)
		{
			ValveTargetAngleUpdate(-10 * C_GMR_ANGLE_SCALE_FACTOR); /* move to 0% position */
			MotSetTargetPosition(valve.pos.targetAngle);
			valve.calibration.state = CALSTEP_0d_POS;
    6ebe:	42d8 1210 	mov	0x1210 <.LLST4+0x8>, AL

00006ec2 <.L567>:

	set_gmr_sensor_offset(offset);
}
static tValveState ValveCalibrationTask(void)
{
	tValveState nextState = VALVE_CALIBRATION;
    6ec2:	7005      	lod	A, #5
    6ec4:	0719      	jmp	0x6cf8 <.L200>

00006ec6 <.L228>:
		MotClearStallFlag(0); /* clear stall flag if set */
		MotRequestHardStop();
		valve.calibration.state = CALSTEP_START;
		break;
	case CALSTEP_START:
		MotClearHardStop();
    6ec6:	82db 3e1b 	callf	0x7c36 <_MotClearHardStop>

00006eca <.LM452>:
		valve.calibration.delay = 3;
    6eca:	7803      	lod	Y, #3
    6ecc:	5ad8 121a 	mov	0x121a <.LLST4+0x12>, Y

00006ed0 <.LM453>:
		valve.calibration.timer = 0;
    6ed0:	7000      	lod	A, #0
    6ed2:	0ea7      	lod	C, ML.7
    6ed4:	52d8 121c 	mov	0x121c <.LLST4+0x14>, A

00006ed8 <.LM454>:
		if (valve.calibration.req2Cal != 0)
    6ed8:	62d8 1212 	lod	AL, 0x1212 <.LLST4+0xa>
    6edc:	1908      	je	0x6eee <.L235>

00006ede <.L236>:

#endif
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    6ede:	709c      	lod	A, #-100
    6ee0:	52d8 1206 	mov	0x1206 <_valve+0xe>, A

00006ee4 <.LBE326>:
		valve.calibration.delay = 3;
		valve.calibration.timer = 0;
		if (valve.calibration.req2Cal != 0)
		{
			ValveTargetAngleUpdate(-10 * C_GMR_ANGLE_SCALE_FACTOR); /* move to 0% position */
			MotSetTargetPosition(valve.pos.targetAngle);
    6ee4:	82db 3e1f 	callf	0x7c3e <_MotSetTargetPosition>

00006ee8 <.LM457>:
			valve.calibration.state = CALSTEP_0d_POS;
    6ee8:	6002      	lod	AL, #2
    6eea:	0ea7      	lod	C, ML.7
    6eec:	07e8      	jmp	0x6ebe <.L565>

00006eee <.L235>:
		}
		else
		{
			if (valve.pos.currentAngle <= (valve.pos.modeAngle[C_MODE_B] + (int16_t)(45 * C_GMR_ANGLE_SCALE_FACTOR)))
    6eee:	72d8 120c 	lod	A, 0x120c <.LLST4+0x4>
    6ef2:	a2da 01c2 	add	A, #450
    6ef6:	aed8 1208 	cmp	A, 0x1208 <.LLST4>
    6efa:	1ef1      	jsge	0x6ede <.L236>

00006efc <.LBB328>:

#endif
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    6efc:	72da 0e74 	lod	A, #3700
    6f00:	52d8 1206 	mov	0x1206 <_valve+0xe>, A

00006f04 <.LBE328>:
				valve.calibration.state = CALSTEP_0d_POS;
			}
			else
			{
				ValveTargetAngleUpdate(370 * C_GMR_ANGLE_SCALE_FACTOR); /* move to 360% position */
				MotSetTargetPosition(valve.pos.targetAngle);
    6f04:	5a03      	mov	[S-4], Y
    6f06:	82db 3e1f 	callf	0x7c3e <_MotSetTargetPosition>

00006f0a <.LM461>:
				valve.calibration.state = CALSTEP_360d_POS;
    6f0a:	7a03      	lod	Y, [S-4]
    6f0c:	46d8 1210 	mov	0x1210 <.LLST4+0x8>, YL
    6f10:	07d8      	jmp	0x6ec2 <.L567>

00006f12 <.L229>:
			}
		}
		break;
	case CALSTEP_0d_POS:
		valve.calibration.timer += 1;
    6f12:	72d8 121c 	lod	A, 0x121c <.LLST4+0x14>
    6f16:	a001      	add	A, #1
    6f18:	52d8 121c 	mov	0x121c <.LLST4+0x14>, A

00006f1c <.LM463>:
		if (valve.calibration.timer >= timeOut)
    6f1c:	ae05      	cmp	A, [S-6]
    6f1e:	1802      	jc	0x6f24 <.L237>

00006f20 <.L574>:
			{

				MotClearStallFlag(0); /* clear stall flag if set */
				MotRequestHardStop();

				valve.calibration.state = CALSTEP_FAULT;
    6f20:	6008      	lod	AL, #8
    6f22:	07cd      	jmp	0x6ebe <.L565>

00006f24 <.L237>:
		if (valve.calibration.timer >= timeOut)
		{

			valve.calibration.state = CALSTEP_FAULT;
		}
		else if (valve.calibration.delay > 0)
    6f24:	72d8 121a 	lod	A, 0x121a <.LLST4+0x12>
    6f28:	1904      	je	0x6f32 <.L238>

00006f2a <.L573>:
		}
		break;
	case CALSTEP_INIT_POS:
		if (valve.calibration.delay > 0)
		{
			valve.calibration.delay -= 1;
    6f2a:	a0ff      	add	A, #-1
    6f2c:	52d8 121a 	mov	0x121a <.LLST4+0x12>, A
    6f30:	07c8      	jmp	0x6ec2 <.L567>

00006f32 <.L238>:
			valve.calibration.delay -= 1;
		}
		else
		{

			if (valve.motorMotion == MOTION_STALL)
    6f32:	7a01      	lod	Y, [S-2]
    6f34:	ec06      	cmp	Y, #6
    6f36:	1901      	je	0x6f3a <.LM468>
    6f38:	0086      	jmp	0x7046 <.L249>

00006f3a <.LM468>:
			{
				MotClearStallFlag(0); /* clear stall flag if set */
    6f3a:	82db 3e39 	callf	0x7c72 <_MotClearStallFlag>

00006f3e <.LM469>:
				MotRequestHardStop();
    6f3e:	82db 3e17 	callf	0x7c2e <_MotRequestHardStop>

00006f42 <.LM470>:
				if (valve.calibration.offsetDone == 0)
    6f42:	62d8 1211 	lod	AL, 0x1211 <.LLST4+0x9>
    6f46:	1d31      	jne	0x6faa <.L241>

00006f48 <.LM471>:
				{
					calcSensorOffset(valve.pos.currentAngle);
    6f48:	7ad8 1208 	lod	Y, 0x1208 <.LLST4>

00006f4c <.LBB330>:

	return nextState;
}
static void calcSensorOffset(int16_t currDegree)
{
	int16_t offset = get_gmr_sensor_offset();
    6f4c:	5a03      	mov	[S-4], Y
    6f4e:	82db 3bea 	callf	0x77d4 <_get_gmr_sensor_offset>

00006f52 <.LM473>:
	if (offset >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
	{
		offset -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
	}
#else
	offset += (int16_t)((int16_t)(C_GMR_SENSOR_OFFSET * C_GMR_ANGLE_SCALE_FACTOR) - currDegree);
    6f52:	7a03      	lod	Y, [S-4]
    6f54:	aae6      	sub	A, Y

00006f56 <.LVL183>:
    6f56:	a2da 0708 	add	A, #1800

00006f5a <.LM474>:
	if (offset >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
    6f5a:	aeda 0e0f 	cmp	A, #3599
    6f5e:	1b32      	jsle	0x6fc4 <.L242>

00006f60 <.LM475>:
	{
		offset -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    6f60:	a2da f1f0 	add	A, #61936

00006f64 <.L243>:
	else
	{
	}
#endif

	set_gmr_sensor_offset(offset);
    6f64:	82db 3be7 	callf	0x77ce <_set_gmr_sensor_offset>

00006f68 <.LBE330>:
				MotClearStallFlag(0); /* clear stall flag if set */
				MotRequestHardStop();
				if (valve.calibration.offsetDone == 0)
				{
					calcSensorOffset(valve.pos.currentAngle);
					diff = valve.memory.offset - get_gmr_sensor_offset();
    6f68:	7ad8 1230 	lod	Y, 0x1230 <.LLST6+0x11>
    6f6c:	5a03      	mov	[S-4], Y
    6f6e:	82db 3bea 	callf	0x77d4 <_get_gmr_sensor_offset>
    6f72:	7a03      	lod	Y, [S-4]
    6f74:	eae2      	sub	Y, A

00006f76 <.LM478>:
					if (diff < 0)
					{
						diff = -diff;
					}
					if (diff > C_VALVE_CAL_HYSTERISYS)
    6f76:	1d81      	jnn	0x6f7a <.L577>
    6f78:	5cc6      	neg	Y

00006f7a <.L577>:
    6f7a:	4cf9      	movs	YA, Y
    6f7c:	82db 2fed 	callf	0x5fda <___floatsisf>

00006f80 <.LVL190>:
    6f80:	54ca 0000 	pushw	#0
    6f84:	54ca 4120 	pushw	#16672

00006f88 <.LCFI9>:
    6f88:	82db 2fcb 	callf	0x5f96 <___gtsf2>
    6f8c:	5c03      	dec	S, #4

00006f8e <.LCFI10>:
    6f8e:	ac00      	cmp	A, #0
    6f90:	1b0c      	jsle	0x6faa <.L241>

00006f92 <.LM479>:
					{
						valve_gmr_write((uint16_t)get_gmr_sensor_offset(), (uint16_t)valve.pos.currentAngle, 0x5555);
    6f92:	7ad8 1208 	lod	Y, 0x1208 <.LLST4>
    6f96:	5a03      	mov	[S-4], Y
    6f98:	82db 3bea 	callf	0x77d4 <_get_gmr_sensor_offset>
    6f9c:	54ca 5555 	pushw	#21845

00006fa0 <.LCFI11>:
    6fa0:	7a05      	lod	Y, [S-6]
    6fa2:	5adf      	push	Y

00006fa4 <.LCFI12>:
    6fa4:	82db 43bc 	callf	0x8778 <_valve_gmr_write>
    6fa8:	5c03      	dec	S, #4

00006faa <.L241>:
					}
				}
				valve.calibration.offsetDone = 1;
				valve.calibration.delay = 3;
    6faa:	7003      	lod	A, #3
    6fac:	52d8 121a 	mov	0x121a <.LLST4+0x12>, A

00006fb0 <.LM481>:
				valve.calibration.timer = 0;
    6fb0:	7000      	lod	A, #0
    6fb2:	0ea7      	lod	C, ML.7
    6fb4:	52d8 121c 	mov	0x121c <.LLST4+0x14>, A

00006fb8 <.LM482>:
				valve.calibration.state = CALSTEP_CALC;
    6fb8:	72da 0105 	lod	A, #261
    6fbc:	52d8 1210 	mov	0x1210 <.LLST4+0x8>, A
    6fc0:	0ea7      	lod	C, ML.7
    6fc2:	077f      	jmp	0x6ec2 <.L567>

00006fc4 <.L242>:
	offset += (int16_t)((int16_t)(C_GMR_SENSOR_OFFSET * C_GMR_ANGLE_SCALE_FACTOR) - currDegree);
	if (offset >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
	{
		offset -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
	}
	else if (offset < 0)
    6fc4:	ac00      	cmp	A, #0
    6fc6:	1ece      	jsge	0x6f64 <.L243>

00006fc8 <.LM484>:
	{
		offset = (-offset);
		offset = (int16_t)C_GMR_SENSOR_ANGLE_LIMIT - offset;
    6fc8:	a2da 0e10 	add	A, #3600

00006fcc <.LVL201>:
    6fcc:	07cb      	jmp	0x6f64 <.L243>

00006fce <.L230>:
			}
		}
		break;

	case CALSTEP_360d_POS:
		valve.calibration.timer += 1;
    6fce:	72d8 121c 	lod	A, 0x121c <.LLST4+0x14>
    6fd2:	a001      	add	A, #1
    6fd4:	52d8 121c 	mov	0x121c <.LLST4+0x14>, A

00006fd8 <.LM486>:
		if (valve.calibration.timer >= timeOut)
    6fd8:	7e05      	lod	X, [S-6]
    6fda:	2ee2      	cmp	X, A
    6fdc:	1e01      	jug	0x6fe0 <.LM487>
    6fde:	07a0      	jmp	0x6f20 <.L574>

00006fe0 <.LM487>:
		{

			valve.calibration.state = CALSTEP_FAULT;
		}
		else if (valve.calibration.delay > 0)
    6fe0:	72d8 121a 	lod	A, 0x121a <.LLST4+0x12>
    6fe4:	1901      	je	0x6fe8 <.LM488>
    6fe6:	07a1      	jmp	0x6f2a <.L573>

00006fe8 <.LM488>:
		{
			valve.calibration.delay -= 1;
		}
		else
		{
			if (valve.motorMotion == MOTION_STALL)
    6fe8:	7a01      	lod	Y, [S-2]
    6fea:	ec06      	cmp	Y, #6
    6fec:	1d2c      	jne	0x7046 <.L249>

00006fee <.LM489>:
			{
				MotClearStallFlag(0);																	/* clear stall flag if set */
    6fee:	82db 3e39 	callf	0x7c72 <_MotClearStallFlag>

00006ff2 <.LM490>:
				valve.calibration.d360Angle = (valve.pos.currentAngle - (int16_t)C_STOPPER_360D_ANGLE); // C_STOPPER_360D_ANGLE
    6ff2:	72d8 1208 	lod	A, 0x1208 <.LLST4>
    6ff6:	7ee2      	lod	X, A
    6ff8:	22da ff47 	add	X, #65351

00006ffc <.LM491>:
				if (valve.calibration.d360Angle < 0)
    6ffc:	2c00      	cmp	X, #0
    6ffe:	1e85      	jsge	0x700a <.L250>

00007000 <.LM492>:
				{
					valve.calibration.d360Angle += (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    7000:	a2da 0d57 	add	A, #3415

00007004 <.L558>:
				}
				else if (valve.calibration.d360Angle >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
				{
					valve.calibration.d360Angle -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    7004:	52d8 1218 	mov	0x1218 <.LLST4+0x10>, A
    7008:	0005      	jmp	0x7014 <.L251>

0000700a <.L250>:
				valve.calibration.d360Angle = (valve.pos.currentAngle - (int16_t)C_STOPPER_360D_ANGLE); // C_STOPPER_360D_ANGLE
				if (valve.calibration.d360Angle < 0)
				{
					valve.calibration.d360Angle += (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
				}
				else if (valve.calibration.d360Angle >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
    700a:	2eda 0e0f 	cmp	X, #3599
    700e:	1f18      	jsg	0x7040 <.L252>

00007010 <.LM495>:
		else
		{
			if (valve.motorMotion == MOTION_STALL)
			{
				MotClearStallFlag(0);																	/* clear stall flag if set */
				valve.calibration.d360Angle = (valve.pos.currentAngle - (int16_t)C_STOPPER_360D_ANGLE); // C_STOPPER_360D_ANGLE
    7010:	5ed8 1218 	mov	0x1218 <.LLST4+0x10>, X

00007014 <.L251>:
					valve.calibration.d360Angle -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
				}
				else
				{
				}
				valve.calibration.travel = valve.calibration.d360Angle - valve.calibration.d0Angle;
    7014:	72d8 1218 	lod	A, 0x1218 <.LLST4+0x10>
    7018:	7ee2      	lod	X, A
    701a:	2ad8 1216 	sub	X, 0x1216 <.LLST4+0xe>
    701e:	5ed8 1214 	mov	0x1214 <.LLST4+0xc>, X

00007022 <.LM497>:
#if 1
				valve.pos.modeAngle[C_MODE_A] = valve.calibration.d360Angle;
    7022:	52d8 120a 	mov	0x120a <.LLST4+0x2>, A

00007026 <.LM498>:
#endif
				ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]); /* move to init position */
    7026:	0ea7      	lod	C, ML.7
    7028:	72d8 120c 	lod	A, 0x120c <.LLST4+0x4>

0000702c <.LBB334>:

#endif
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    702c:	52d8 1206 	mov	0x1206 <_valve+0xe>, A

00007030 <.LBE334>:
				valve.calibration.travel = valve.calibration.d360Angle - valve.calibration.d0Angle;
#if 1
				valve.pos.modeAngle[C_MODE_A] = valve.calibration.d360Angle;
#endif
				ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]); /* move to init position */
				MotSetTargetPosition(valve.pos.targetAngle);
    7030:	82db 3e1f 	callf	0x7c3e <_MotSetTargetPosition>

00007034 <.LM501>:
				valve.calibration.delay = 3;
    7034:	7003      	lod	A, #3
    7036:	0ea7      	lod	C, ML.7
    7038:	52d8 121a 	mov	0x121a <.LLST4+0x12>, A

0000703c <.LM502>:
				valve.calibration.state = CALSTEP_INIT_POS;
    703c:	6007      	lod	AL, #7
    703e:	073f      	jmp	0x6ebe <.L565>

00007040 <.L252>:
				{
					valve.calibration.d360Angle += (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
				}
				else if (valve.calibration.d360Angle >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
				{
					valve.calibration.d360Angle -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    7040:	a2da f137 	add	A, #61751
    7044:	07df      	jmp	0x7004 <.L558>

00007046 <.L249>:
				ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]); /* move to init position */
				MotSetTargetPosition(valve.pos.targetAngle);
				valve.calibration.delay = 3;
				valve.calibration.state = CALSTEP_INIT_POS;
			}
			else if (valve.motorMotion == MOTION_STOPPED)
    7046:	7a01      	lod	Y, [S-2]
    7048:	ec01      	cmp	Y, #1
    704a:	1d01      	jne	0x704e <.L318>
    704c:	0769      	jmp	0x6f20 <.L574>

0000704e <.L318>:
		}
		valve.state = nextState;
	}
	else
	{
		if (valve.elapsedTime < 0xffffu)
    704e:	72d8 11fe 	lod	A, 0x11fe <_valve+0x6>
    7052:	acff      	cmp	A, #-1
    7054:	1d01      	jne	0x7058 <.LM506>
    7056:	0662      	jmp	0x6d1c <.L320>

00007058 <.LM506>:
			valve.elapsedTime += 1;
    7058:	a001      	add	A, #1
    705a:	52d8 11fe 	mov	0x11fe <_valve+0x6>, A
    705e:	065e      	jmp	0x6d1c <.L320>

00007060 <.L231>:
				valve.calibration.state = CALSTEP_FAULT;
			}
		}
		break;
	case CALSTEP_CALC:
		if (valve.calibration.delay > 0)
    7060:	72d8 121a 	lod	A, 0x121a <.LLST4+0x12>
    7064:	1901      	je	0x7068 <.LM508>
    7066:	0761      	jmp	0x6f2a <.L573>

00007068 <.LM508>:
		{
			valve.calibration.delay -= 1;
		}
		else
		{
			valve.calibration.d0Angle = (valve.pos.currentAngle + (int16_t)C_STOPPER_0D_ANGLE); // C_STOPPER_0D_ANGLE
    7068:	72ee      	lod	A, X
    706a:	a2da 00b9 	add	A, #185

0000706e <.LM509>:
			if (valve.calibration.d0Angle >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
    706e:	aeda 0e0f 	cmp	A, #3599
    7072:	1b05      	jsle	0x707e <.L254>

00007074 <.LM510>:
			{
				valve.calibration.d0Angle -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    7074:	22da f2a9 	add	X, #62121

00007078 <.L559>:
			}
			else if (valve.calibration.d0Angle < 0)
			{
				valve.calibration.d0Angle += (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    7078:	5ed8 1216 	mov	0x1216 <.LLST4+0xe>, X
    707c:	0004      	jmp	0x7086 <.L255>

0000707e <.L254>:
			valve.calibration.d0Angle = (valve.pos.currentAngle + (int16_t)C_STOPPER_0D_ANGLE); // C_STOPPER_0D_ANGLE
			if (valve.calibration.d0Angle >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
			{
				valve.calibration.d0Angle -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
			}
			else if (valve.calibration.d0Angle < 0)
    707e:	ac00      	cmp	A, #0
    7080:	1a96      	jsl	0x70ae <.L256>

00007082 <.LM513>:
		{
			valve.calibration.delay -= 1;
		}
		else
		{
			valve.calibration.d0Angle = (valve.pos.currentAngle + (int16_t)C_STOPPER_0D_ANGLE); // C_STOPPER_0D_ANGLE
    7082:	52d8 1216 	mov	0x1216 <.LLST4+0xe>, A

00007086 <.L255>:
			}
			else
			{
			}
#if 1
			valve.pos.modeAngle[C_MODE_B] = valve.calibration.d0Angle;
    7086:	72d8 1216 	lod	A, 0x1216 <.LLST4+0xe>
    708a:	52d8 120c 	mov	0x120c <.LLST4+0x4>, A

0000708e <.LM515>:
#endif
			if (valve.calibration.req2Cal != 0)
    708e:	7a07      	lod	Y, [S-8]
    7090:	1911      	je	0x70b4 <.L257>

00007092 <.LBB336>:

#endif
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    7092:	72da 0e74 	lod	A, #3700
    7096:	52d8 1206 	mov	0x1206 <_valve+0xe>, A

0000709a <.LBE336>:
			valve.pos.modeAngle[C_MODE_B] = valve.calibration.d0Angle;
#endif
			if (valve.calibration.req2Cal != 0)
			{
				ValveTargetAngleUpdate(370 * C_GMR_ANGLE_SCALE_FACTOR); /* move to 360% position */
				valve.calibration.state = CALSTEP_360d_POS;
    709a:	6003      	lod	AL, #3

0000709c <.L560>:
			}
			else
			{
				ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]); /* move to init position */
				valve.calibration.state = CALSTEP_INIT_POS;
    709c:	42d8 1210 	mov	0x1210 <.LLST4+0x8>, AL

000070a0 <.LM519>:
			}
			MotClearHardStop();
    70a0:	82db 3e1b 	callf	0x7c36 <_MotClearHardStop>

000070a4 <.LM520>:
			MotSetTargetPosition(valve.pos.targetAngle);
    70a4:	72d8 1206 	lod	A, 0x1206 <_valve+0xe>
    70a8:	82db 3e1f 	callf	0x7c3e <_MotSetTargetPosition>
    70ac:	070a      	jmp	0x6ec2 <.L567>

000070ae <.L256>:
			{
				valve.calibration.d0Angle -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
			}
			else if (valve.calibration.d0Angle < 0)
			{
				valve.calibration.d0Angle += (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    70ae:	22da 0ec9 	add	X, #3785
    70b2:	07e2      	jmp	0x7078 <.L559>

000070b4 <.L257>:

#endif
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    70b4:	52d8 1206 	mov	0x1206 <_valve+0xe>, A

000070b8 <.LBE338>:
				valve.calibration.state = CALSTEP_360d_POS;
			}
			else
			{
				ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]); /* move to init position */
				valve.calibration.state = CALSTEP_INIT_POS;
    70b8:	6007      	lod	AL, #7
    70ba:	07f0      	jmp	0x709c <.L560>

000070bc <.L232>:
			MotClearHardStop();
			MotSetTargetPosition(valve.pos.targetAngle);
		}
		break;
	case CALSTEP_INIT_POS:
		if (valve.calibration.delay > 0)
    70bc:	72d8 121a 	lod	A, 0x121a <.LLST4+0x12>
    70c0:	1901      	je	0x70c4 <.LM525>
    70c2:	0733      	jmp	0x6f2a <.L573>

000070c4 <.LM525>:
		{
			valve.calibration.delay -= 1;
		}
		else
		{
			if (valve.motorMotion == MOTION_STALL)
    70c4:	7a01      	lod	Y, [S-2]
    70c6:	ec06      	cmp	Y, #6
    70c8:	1d05      	jne	0x70d4 <.L260>

000070ca <.LM526>:
			{

				MotClearStallFlag(0); /* clear stall flag if set */
    70ca:	82db 3e39 	callf	0x7c72 <_MotClearStallFlag>

000070ce <.LM527>:
				MotRequestHardStop();
    70ce:	82db 3e17 	callf	0x7c2e <_MotRequestHardStop>
    70d2:	0726      	jmp	0x6f20 <.L574>

000070d4 <.L260>:

				valve.calibration.state = CALSTEP_FAULT;
			}
			else if (valve.motorMotion == MOTION_STOPPED)
    70d4:	7a01      	lod	Y, [S-2]
    70d6:	ec01      	cmp	Y, #1
    70d8:	1901      	je	0x70dc <.LM529>
    70da:	07b9      	jmp	0x704e <.L318>

000070dc <.LM529>:
			{

				valve.calibration.state = CALSTEP_COMPLETED;
    70dc:	6009      	lod	AL, #9
    70de:	06ef      	jmp	0x6ebe <.L565>

000070e0 <.L233>:
		}
		break;

	case CALSTEP_FAULT:

		valve.calibration.req2Cal = 0;
    70e0:	7000      	lod	A, #0
    70e2:	52d8 1212 	mov	0x1212 <.LLST4+0xa>, A

000070e6 <.LM531>:
		valve.calibration.req1Cal = 0;
		valve.diag.calFault = 1;
    70e6:	6001      	lod	AL, #1
    70e8:	0ea7      	lod	C, ML.7
    70ea:	42d8 1262 	mov	0x1262 <.LLST6+0x10>, AL

000070ee <.LM532>:
		u16EventState = VALVE_CAL_FAULT;
    70ee:	7009      	lod	A, #9
    70f0:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

000070f4 <.LM533>:
		u16EventValue = valve.pos.currentAngle;
    70f4:	0ea7      	lod	C, ML.7
    70f6:	5ed8 10b4 	mov	0x10b4 <_u16EventValue>, X

000070fa <.L566>:
	}
	return nextState;
}
static tValveState ValveFaultTask(void)
{
	tValveState nextState = VALVE_FAULT;
    70fa:	7006      	lod	A, #6
    70fc:	05fd      	jmp	0x6cf8 <.L200>

000070fe <.L234>:

		nextState = VALVE_FAULT;
		break;
	case CALSTEP_COMPLETED:

		valve.calibration.req2Cal = 0;
    70fe:	7000      	lod	A, #0
    7100:	52d8 1212 	mov	0x1212 <.LLST4+0xa>, A
    7104:	05bf      	jmp	0x6c84 <.L561>

00007106 <.L195>:
}
static tValveState ValveFaultTask(void)
{
	tValveState nextState = VALVE_FAULT;
	uint16_t status = 1;
	MotRequestHardStop();
    7106:	82db 3e17 	callf	0x7c2e <_MotRequestHardStop>

0000710a <.LM537>:
	valve.comm.lastMode = 0xff;
    710a:	60ff      	lod	AL, #-1
    710c:	42d8 1224 	mov	0x1224 <.LLST6+0x5>, AL

00007110 <.LM538>:
	if (valve.initStatus != 0)
    7110:	62d8 1203 	lod	AL, 0x1203 <_valve+0xb>
    7114:	1926      	je	0x7162 <.L262>

00007116 <.LM539>:
	{
		valve.initStatus = 0;
    7116:	6000      	lod	AL, #0
    7118:	42d8 1203 	mov	0x1203 <_valve+0xb>, AL

0000711c <.LM540>:
		if (valve.diag.calFault != 0)
    711c:	62d8 1262 	lod	AL, 0x1262 <.LLST6+0x10>
    7120:	1905      	je	0x712c <.L263>

00007122 <.LM541>:
		{
			valve.diag.calRetryCnt += 1;
    7122:	62d8 1266 	lod	AL, 0x1266 <.LLST6+0x14>
    7126:	8001      	add	AL, #1
    7128:	42d8 1266 	mov	0x1266 <.LLST6+0x14>, AL

0000712c <.L263>:
		}
		if ((valve.diag.stallFault & STALL_MASK_PERMENT) != 0)
    712c:	62d8 1264 	lod	AL, 0x1264 <.LLST6+0x12>
    7130:	9402      	and	AL, #2
    7132:	1905      	je	0x713e <.L264>

00007134 <.LM543>:
		{
			valve.diag.stallRetryCnt += 1;
    7134:	62d8 1265 	lod	AL, 0x1265 <.LLST6+0x13>
    7138:	8001      	add	AL, #1
    713a:	42d8 1265 	mov	0x1265 <.LLST6+0x13>, AL

0000713e <.L264>:
		}
		if ((valve.diag.motorFault & FAULT_MASK_PHASE_A_OPEN) != 0)
    713e:	66d8 1263 	lod	YL, 0x1263 <.LLST6+0x11>
    7142:	62e8      	lod	AL, YL
    7144:	9401      	and	AL, #1
    7146:	1905      	je	0x7152 <.L265>

00007148 <.LM545>:
		{
			valve.diag.motOpenRetryCnt += 1;
    7148:	62d8 1268 	lod	AL, 0x1268 <.LLST6+0x16>
    714c:	8001      	add	AL, #1
    714e:	42d8 1268 	mov	0x1268 <.LLST6+0x16>, AL

00007152 <.L265>:
		}
		if ((valve.diag.motorFault & FAULT_MASK_PHASE_A_SHORT) != 0)
    7152:	62e8      	lod	AL, YL
    7154:	9410      	and	AL, #16
    7156:	1905      	je	0x7162 <.L262>

00007158 <.LM547>:
		{
			valve.diag.motShortRetryCnt += 1;
    7158:	62d8 1269 	lod	AL, 0x1269 <.LLST6+0x17>
    715c:	8001      	add	AL, #1
    715e:	42d8 1269 	mov	0x1269 <.LLST6+0x17>, AL

00007162 <.L262>:
		}
	}

	if (valve.elapsedTime >= 5000u)
    7162:	72d8 11fe 	lod	A, 0x11fe <_valve+0x6>
    7166:	aeda 1387 	cmp	A, #4999
    716a:	1a47      	jule	0x70fa <.L566>

0000716c <.LM549>:
	{
		if (valve.diag.calRetryCnt < 3)
    716c:	62d8 1266 	lod	AL, 0x1266 <.LLST6+0x14>
    7170:	8c02      	cmp	AL, #2
    7172:	1e03      	jug	0x717a <.L267>

00007174 <.LM550>:
		{
			valve.diag.calFault = 0;
    7174:	6000      	lod	AL, #0
    7176:	42d8 1262 	mov	0x1262 <.LLST6+0x10>, AL

0000717a <.L267>:
		}
		if (valve.diag.stallRetryCnt < 3)
    717a:	62d8 1265 	lod	AL, 0x1265 <.LLST6+0x13>
    717e:	8c02      	cmp	AL, #2
    7180:	1e03      	jug	0x7188 <.L268>

00007182 <.LM552>:
		{
			MotClearStallFlag(0);
    7182:	7000      	lod	A, #0
    7184:	82db 3e39 	callf	0x7c72 <_MotClearStallFlag>

00007188 <.L268>:
		}
		if (valve.diag.motOpenRetryCnt < 3)
    7188:	62d8 1268 	lod	AL, 0x1268 <.LLST6+0x16>
    718c:	8c02      	cmp	AL, #2
    718e:	1e03      	jug	0x7196 <.L269>

00007190 <.LM554>:
		{
			MotClearFaultFlag(1);
    7190:	7001      	lod	A, #1
    7192:	82db 3e48 	callf	0x7c90 <_MotClearFaultFlag>

00007196 <.L269>:
		}
		if (valve.diag.motShortRetryCnt < 3)
    7196:	62d8 1269 	lod	AL, 0x1269 <.LLST6+0x17>
    719a:	8c02      	cmp	AL, #2
    719c:	1e03      	jug	0x71a4 <.L270>

0000719e <.LM556>:
		{
			MotClearFaultFlag(2);
    719e:	7002      	lod	A, #2
    71a0:	82db 3e48 	callf	0x7c90 <_MotClearFaultFlag>

000071a4 <.L270>:
		}

		if (valve.diag.calFault != 0)
    71a4:	66d8 1262 	lod	YL, 0x1262 <.LLST6+0x10>

000071a8 <.LM558>:
		{
			status = 0;
		}
		if (MotGetStallState() != 0)
    71a8:	5a03      	mov	[S-4], Y
    71aa:	82db 3e6e 	callf	0x7cdc <_MotGetStallState>
    71ae:	7a03      	lod	Y, [S-4]
    71b0:	ac00      	cmp	A, #0
    71b2:	1d0f      	jne	0x71d2 <.L335>

000071b4 <.LM559>:
	return nextState;
}
static tValveState ValveFaultTask(void)
{
	tValveState nextState = VALVE_FAULT;
	uint16_t status = 1;
    71b4:	62e8      	lod	AL, YL
    71b6:	5c86      	se	Y

000071b8 <.L271>:
		}
		if (MotGetStallState() != 0)
		{
			status = 0;
		}
		if (MotGetFaultState() != 0)
    71b8:	5a03      	mov	[S-4], Y
    71ba:	82db 3e72 	callf	0x7ce4 <_MotGetFaultState>

000071be <.LVL227>:
    71be:	7a03      	lod	Y, [S-4]
    71c0:	ac00      	cmp	A, #0
    71c2:	1d03      	jne	0x71ca <.L272>

000071c4 <.LM561>:
		{
			status = 0;
		}

		if (status != 0)
    71c4:	ec00      	cmp	Y, #0
    71c6:	1901      	je	0x71ca <.L272>
    71c8:	055d      	jmp	0x6c84 <.L561>

000071ca <.L272>:
			//			nextState=valve.lastState;
			nextState = VALVE_STANDBY;
		}
		else
		{
			valve.comm.faultMode = 1;
    71ca:	6001      	lod	AL, #1
    71cc:	42d8 1227 	mov	0x1227 <.LLST6+0x8>, AL
    71d0:	0794      	jmp	0x70fa <.L566>

000071d2 <.L335>:
		{
			status = 0;
		}
		if (MotGetStallState() != 0)
		{
			status = 0;
    71d2:	7800      	lod	Y, #0
    71d4:	07f1      	jmp	0x71b8 <.L271>

000071d6 <.L196>:
static tValveState ValveProtectionTask(void)
{
	tValveState nextState = VALVE_PROTECTION;
	uint16_t status = 1;

	MotRequestHardStop();
    71d6:	82db 3e17 	callf	0x7c2e <_MotRequestHardStop>

000071da <.LM565>:
	valve.comm.lastMode = 0xff;
    71da:	60ff      	lod	AL, #-1
    71dc:	42d8 1224 	mov	0x1224 <.LLST6+0x5>, AL

000071e0 <.LM566>:
	if (valve.initStatus != 0)
    71e0:	62d8 1203 	lod	AL, 0x1203 <_valve+0xb>
    71e4:	1d01      	jne	0x71e8 <.LM567>
    71e6:	00d9      	jmp	0x739a <.L274>

000071e8 <.LM567>:
	{
		valve.initStatus = 0;
    71e8:	6000      	lod	AL, #0
    71ea:	42d8 1203 	mov	0x1203 <_valve+0xb>, AL

000071ee <.LM568>:

		if (valve.diag.vs.state == VS_UNDERVOLTAGE)
    71ee:	72d8 1238 	lod	A, 0x1238 <.LLST0+0x6>
    71f2:	ac01      	cmp	A, #1
    71f4:	1d17      	jne	0x7224 <.L275>

000071f6 <.LM569>:
		{
			if (valve.diag.protType != VS_LOW_ERROR)
    71f6:	72d8 1260 	lod	A, 0x1260 <.LLST6+0xe>
    71fa:	ac01      	cmp	A, #1
    71fc:	1902      	je	0x7202 <.L276>

000071fe <.LM570>:
			{
				ValveErrorReset();
    71fe:	82db 3237 	callf	0x646e <_ValveErrorReset>

00007202 <.L276>:
			}
			if (valve.diag.vs.UVretryCnt < 0xffffu)
    7202:	72d8 1240 	lod	A, 0x1240 <.LLST0+0xe>
    7206:	acff      	cmp	A, #-1
    7208:	1903      	je	0x7210 <.L277>

0000720a <.LM572>:
			{
				valve.diag.vs.UVretryCnt += 1;
    720a:	a001      	add	A, #1
    720c:	52d8 1240 	mov	0x1240 <.LLST0+0xe>, A

00007210 <.L277>:
			}
			valve.diag.protType = VS_LOW_ERROR;
    7210:	7001      	lod	A, #1
    7212:	52d8 1260 	mov	0x1260 <.LLST6+0xe>, A

00007216 <.LM574>:
			u16EventState = VS_LOW_ERROR;
    7216:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

0000721a <.LM575>:
			u16EventValue = valve.diag.vs.state;
    721a:	0ea7      	lod	C, ML.7
    721c:	72d8 1238 	lod	A, 0x1238 <.LLST0+0x6>
    7220:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

00007224 <.L275>:
		}
		if (valve.diag.vs.state == VS_OVERVOLTAGE)
    7224:	72d8 1238 	lod	A, 0x1238 <.LLST0+0x6>
    7228:	ac02      	cmp	A, #2
    722a:	1d17      	jne	0x725a <.L278>

0000722c <.LM577>:
		{
			if (valve.diag.protType != VS_HIGH_ERROR)
    722c:	72d8 1260 	lod	A, 0x1260 <.LLST6+0xe>
    7230:	ac02      	cmp	A, #2
    7232:	1902      	je	0x7238 <.L279>

00007234 <.LM578>:
			{
				ValveErrorReset();
    7234:	82db 3237 	callf	0x646e <_ValveErrorReset>

00007238 <.L279>:
			}
			if (valve.diag.vs.OVretryCnt < 0xffffu)
    7238:	72d8 1242 	lod	A, 0x1242 <.LLST0+0x10>
    723c:	acff      	cmp	A, #-1
    723e:	1903      	je	0x7246 <.L280>

00007240 <.LM580>:
			{
				valve.diag.vs.OVretryCnt += 1;
    7240:	a001      	add	A, #1
    7242:	52d8 1242 	mov	0x1242 <.LLST0+0x10>, A

00007246 <.L280>:
			}
			valve.diag.protType = VS_HIGH_ERROR;
    7246:	7002      	lod	A, #2
    7248:	52d8 1260 	mov	0x1260 <.LLST6+0xe>, A

0000724c <.LM582>:
			u16EventState = VS_HIGH_ERROR;
    724c:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

00007250 <.LM583>:
			u16EventValue = valve.diag.vs.state;
    7250:	0ea7      	lod	C, ML.7
    7252:	72d8 1238 	lod	A, 0x1238 <.LLST0+0x6>
    7256:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

0000725a <.L278>:
		}
		if (valve.diag.temp.state != TEMPERATURE_NORMAL)
    725a:	72d8 1244 	lod	A, 0x1244 <.LLST0+0x12>
    725e:	1918      	je	0x7290 <.L281>

00007260 <.LM585>:
		{
			if (valve.diag.protType != TEMP_HIGH_ERROR)
    7260:	72d8 1260 	lod	A, 0x1260 <.LLST6+0xe>
    7264:	ac03      	cmp	A, #3
    7266:	1902      	je	0x726c <.L282>

00007268 <.LM586>:
			{
				ValveErrorReset();
    7268:	82db 3237 	callf	0x646e <_ValveErrorReset>

0000726c <.L282>:
			}
			if (valve.diag.temp.retryCnt < 0xffu)
    726c:	72d8 1246 	lod	A, 0x1246 <.LLST0+0x14>
    7270:	aeda 00fe 	cmp	A, #254
    7274:	1e03      	jug	0x727c <.L283>

00007276 <.LM588>:
			{
				valve.diag.temp.retryCnt += 1;
    7276:	a001      	add	A, #1
    7278:	52d8 1246 	mov	0x1246 <.LLST0+0x14>, A

0000727c <.L283>:
			}
			valve.diag.protType = TEMP_HIGH_ERROR;
    727c:	7003      	lod	A, #3
    727e:	52d8 1260 	mov	0x1260 <.LLST6+0xe>, A

00007282 <.LM590>:
			u16EventState = TEMP_HIGH_ERROR;
    7282:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

00007286 <.LM591>:
			u16EventValue = valve.diag.temp.deg;
    7286:	0ea7      	lod	C, ML.7
    7288:	72d8 1248 	lod	A, 0x1248 <.LLST0+0x16>
    728c:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

00007290 <.L281>:
		}
		
		if ((valve.diag.motorFault & FAULT_MASK_OVER_CURRENT) != 0)
    7290:	62d8 1263 	lod	AL, 0x1263 <.LLST6+0x11>
    7294:	9440      	and	AL, #64
    7296:	1913      	je	0x72be <.L284>

00007298 <.LM593>:
		{
			
			if (valve.diag.protType != MOT_OC_ERROR)
    7298:	72d8 1260 	lod	A, 0x1260 <.LLST6+0xe>
    729c:	ac04      	cmp	A, #4
    729e:	1902      	je	0x72a4 <.L285>

000072a0 <.LM594>:
			{
				ValveErrorReset();
    72a0:	82db 3237 	callf	0x646e <_ValveErrorReset>

000072a4 <.L285>:
			}
			if (valve.diag.motOcRetryCnt < 0xffu)
    72a4:	62d8 1267 	lod	AL, 0x1267 <.LLST6+0x15>
    72a8:	66e0      	lod	YL, AL
    72aa:	5cf6      	usex	Y
    72ac:	eeda 00ff 	cmp	Y, #255
    72b0:	1903      	je	0x72b8 <.L286>

000072b2 <.LM596>:
			{
				valve.diag.motOcRetryCnt += 1;
    72b2:	8001      	add	AL, #1
    72b4:	42d8 1267 	mov	0x1267 <.LLST6+0x15>, AL

000072b8 <.L286>:
			}
			valve.diag.protType = MOT_OC_ERROR;
    72b8:	7004      	lod	A, #4
    72ba:	52d8 1260 	mov	0x1260 <.LLST6+0xe>, A

000072be <.L284>:
		}
		if ((valve.diag.stallFault & STALL_MASK_TEMPORARY) != 0)
    72be:	62d8 1264 	lod	AL, 0x1264 <.LLST6+0x12>
    72c2:	9401      	and	AL, #1
    72c4:	1913      	je	0x72ec <.L287>

000072c6 <.LM599>:
		{
			if (valve.diag.protType != MOT_ABSTALL_ERROR)
    72c6:	72d8 1260 	lod	A, 0x1260 <.LLST6+0xe>
    72ca:	ac05      	cmp	A, #5
    72cc:	1902      	je	0x72d2 <.L288>

000072ce <.LM600>:
			{
				ValveErrorReset();
    72ce:	82db 3237 	callf	0x646e <_ValveErrorReset>

000072d2 <.L288>:
			}
			if (valve.diag.ObstructionRetryCnt < 0xffu)
    72d2:	62d8 125e 	lod	AL, 0x125e <.LLST6+0xc>
    72d6:	66e0      	lod	YL, AL
    72d8:	5cf6      	usex	Y
    72da:	eeda 00ff 	cmp	Y, #255
    72de:	1903      	je	0x72e6 <.L289>

000072e0 <.LM602>:
			{
				valve.diag.ObstructionRetryCnt += 1;
    72e0:	8001      	add	AL, #1
    72e2:	42d8 125e 	mov	0x125e <.LLST6+0xc>, AL

000072e6 <.L289>:
			}
			valve.diag.protType = MOT_ABSTALL_ERROR;
    72e6:	7005      	lod	A, #5
    72e8:	52d8 1260 	mov	0x1260 <.LLST6+0xe>, A

000072ec <.L287>:
		}
		if (valve.pos.fault != 0)
    72ec:	62d8 120e 	lod	AL, 0x120e <.LLST4+0x6>
    72f0:	191a      	je	0x7326 <.L290>

000072f2 <.LM605>:
		{
			if (valve.diag.protType != SENSOR_POS_ERROR)
    72f2:	72d8 1260 	lod	A, 0x1260 <.LLST6+0xe>
    72f6:	ac06      	cmp	A, #6
    72f8:	1902      	je	0x72fe <.L291>

000072fa <.LM606>:
			{
				ValveErrorReset();
    72fa:	82db 3237 	callf	0x646e <_ValveErrorReset>

000072fe <.L291>:
			}
			if (valve.pos.retryCnt < 0xffu)
    72fe:	62d8 120f 	lod	AL, 0x120f <.LLST4+0x7>
    7302:	66e0      	lod	YL, AL
    7304:	5cf6      	usex	Y
    7306:	eeda 00ff 	cmp	Y, #255
    730a:	1903      	je	0x7312 <.L292>

0000730c <.LM608>:
			{
				valve.pos.retryCnt += 1;
    730c:	8001      	add	AL, #1
    730e:	42d8 120f 	mov	0x120f <.LLST4+0x7>, AL

00007312 <.L292>:
			}
			valve.diag.protType = SENSOR_POS_ERROR;
    7312:	7006      	lod	A, #6
    7314:	52d8 1260 	mov	0x1260 <.LLST6+0xe>, A

00007318 <.LM610>:
			u16EventState = SENSOR_POS_ERROR;
    7318:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

0000731c <.LM611>:
			u16EventValue = valve.pos.currentAngle;
    731c:	0ea7      	lod	C, ML.7
    731e:	72d8 1208 	lod	A, 0x1208 <.LLST4>
    7322:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

00007326 <.L290>:
		}
		if (valve.diag.gmr.state != 0)
    7326:	62d8 1252 	lod	AL, 0x1252 <.LLST6>
    732a:	191a      	je	0x7360 <.L293>

0000732c <.LM613>:
		{
			if (valve.diag.protType != SENSOR_OUT_ERROR)
    732c:	72d8 1260 	lod	A, 0x1260 <.LLST6+0xe>
    7330:	ac07      	cmp	A, #7
    7332:	1902      	je	0x7338 <.L294>

00007334 <.LM614>:
			{
				ValveErrorReset();
    7334:	82db 3237 	callf	0x646e <_ValveErrorReset>

00007338 <.L294>:
			}
			if (valve.diag.gmr.retryCnt < 0xffu)
    7338:	62d8 1253 	lod	AL, 0x1253 <.LLST6+0x1>
    733c:	66e0      	lod	YL, AL
    733e:	5cf6      	usex	Y
    7340:	eeda 00ff 	cmp	Y, #255
    7344:	1903      	je	0x734c <.L295>

00007346 <.LM616>:
			{
				valve.diag.gmr.retryCnt += 1;
    7346:	8001      	add	AL, #1
    7348:	42d8 1253 	mov	0x1253 <.LLST6+0x1>, AL

0000734c <.L295>:
			}
			valve.diag.protType = SENSOR_OUT_ERROR;
    734c:	7007      	lod	A, #7
    734e:	52d8 1260 	mov	0x1260 <.LLST6+0xe>, A

00007352 <.LM618>:
			u16EventState = SENSOR_OUT_ERROR;
    7352:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

00007356 <.LM619>:
			u16EventValue = valve.pos.currentAngle;
    7356:	0ea7      	lod	C, ML.7
    7358:	72d8 1208 	lod	A, 0x1208 <.LLST4>
    735c:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

00007360 <.L293>:
		}

		if (valve.diag.McuFault != 0)
    7360:	62d8 125c 	lod	AL, 0x125c <.LLST6+0xa>
    7364:	191a      	je	0x739a <.L274>

00007366 <.LM621>:
		{
			if (valve.diag.protType != MCU_ERROR)
    7366:	72d8 1260 	lod	A, 0x1260 <.LLST6+0xe>
    736a:	ac08      	cmp	A, #8
    736c:	1902      	je	0x7372 <.L297>

0000736e <.LM622>:
			{
				ValveErrorReset();
    736e:	82db 3237 	callf	0x646e <_ValveErrorReset>

00007372 <.L297>:
			}
			if (valve.diag.mcuRetryCnt < 0xffu)
    7372:	62d8 125d 	lod	AL, 0x125d <.LLST6+0xb>
    7376:	66e0      	lod	YL, AL
    7378:	5cf6      	usex	Y
    737a:	eeda 00ff 	cmp	Y, #255
    737e:	1903      	je	0x7386 <.L298>

00007380 <.LM624>:
			{
				valve.diag.mcuRetryCnt += 1;
    7380:	8001      	add	AL, #1
    7382:	42d8 125d 	mov	0x125d <.LLST6+0xb>, AL

00007386 <.L298>:
			}
			valve.diag.protType = MCU_ERROR;
    7386:	7008      	lod	A, #8
    7388:	52d8 1260 	mov	0x1260 <.LLST6+0xe>, A

0000738c <.LM626>:
			u16EventState = MCU_ERROR;
    738c:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

00007390 <.LM627>:
			u16EventValue = valve.diag.vs.state;
    7390:	0ea7      	lod	C, ML.7
    7392:	72d8 1238 	lod	A, 0x1238 <.LLST0+0x6>
    7396:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

0000739a <.L274>:
		}
	}

	if (valve.elapsedTime >= 3000u)
    739a:	72d8 11fe 	lod	A, 0x11fe <_valve+0x6>
    739e:	aeda 0bb7 	cmp	A, #2999
    73a2:	1a20      	jule	0x73e4 <.L299>

000073a4 <.LM629>:
	{
		if (valve.diag.ObstructionRetryCnt < 10)
    73a4:	62d8 125e 	lod	AL, 0x125e <.LLST6+0xc>
    73a8:	8c09      	cmp	AL, #9
    73aa:	1a01      	jule	0x73ae <.LM630>
    73ac:	0062      	jmp	0x7472 <.L300>

000073ae <.LM630>:
		{
			MotClearStallFlag(1);
    73ae:	7001      	lod	A, #1
    73b0:	82db 3e39 	callf	0x7c72 <_MotClearStallFlag>

000073b4 <.L301>:
		else
		{
			valve.comm.faultMode = 1;
		}

		if (valve.diag.motOcRetryCnt < CHECK_OVER_CURRENT_CNT)
    73b4:	62d8 1267 	lod	AL, 0x1267 <.LLST6+0x15>
    73b8:	8c09      	cmp	AL, #9
    73ba:	1a01      	jule	0x73be <.LM632>
    73bc:	005e      	jmp	0x747a <.L302>

000073be <.LM632>:
		{
			MotClearFaultFlag(3);
    73be:	7003      	lod	A, #3
    73c0:	82db 3e48 	callf	0x7c90 <_MotClearFaultFlag>

000073c4 <.L303>:
		else
		{
			valve.comm.faultMode = 1;
		}

		if (valve.pos.retryCnt < CHECK_POSITION_SENSOR_CNT)
    73c4:	62d8 120f 	lod	AL, 0x120f <.LLST4+0x7>
    73c8:	8c09      	cmp	AL, #9
    73ca:	1a01      	jule	0x73ce <.LM634>
    73cc:	005a      	jmp	0x7482 <.L304>

000073ce <.LM634>:
		{
			valve.pos.fault = 0;
    73ce:	6000      	lod	AL, #0
    73d0:	42d8 120e 	mov	0x120e <.LLST4+0x6>, AL

000073d4 <.L305>:
		else
		{
			valve.comm.faultMode = 1;
		}
		
		if (valve.diag.gmr.retryCnt < 10)
    73d4:	62d8 1253 	lod	AL, 0x1253 <.LLST6+0x1>
    73d8:	8c09      	cmp	AL, #9
    73da:	1a01      	jule	0x73de <.LM636>
    73dc:	0056      	jmp	0x748a <.L306>

000073de <.LM636>:
		{
			valve.diag.gmr.state = 0;
    73de:	6000      	lod	AL, #0
    73e0:	42d8 1252 	mov	0x1252 <.LLST6>, AL

000073e4 <.L299>:
		{
			valve.comm.faultMode = 1;
		}
	}

	if (valve.diag.vs.state == VS_NORMAL)
    73e4:	7ed8 1238 	lod	X, 0x1238 <.LLST0+0x6>
    73e8:	1911      	je	0x740c <.L307>

000073ea <.LM638>:
	{
		status = 0;
	}
	else
	{
		if (valve.diag.vs.UVretryCnt > CHECK_UNDER_VOLTAGE_CNT)
    73ea:	72d8 1240 	lod	A, 0x1240 <.LLST0+0xe>
    73ee:	ac1e      	cmp	A, #30
    73f0:	1e01      	jug	0x73f4 <.LM639>
    73f2:	004f      	jmp	0x7492 <.L337>

000073f4 <.LM639>:
		{
			status = 0;
			valve.comm.faultMode = 1;
    73f4:	6001      	lod	AL, #1
    73f6:	42d8 1227 	mov	0x1227 <.LLST6+0x8>, AL

000073fa <.LM640>:
	}
	else
	{
		if (valve.diag.vs.UVretryCnt > CHECK_UNDER_VOLTAGE_CNT)
		{
			status = 0;
    73fa:	7c00      	lod	X, #0

000073fc <.L308>:
			valve.comm.faultMode = 1;
		}
		if (valve.diag.vs.OVretryCnt > CHECK_OVER_VOLTAGE_CNT)
    73fc:	72d8 1242 	lod	A, 0x1242 <.LLST0+0x10>
    7400:	ac1e      	cmp	A, #30
    7402:	1a04      	jule	0x740c <.L307>

00007404 <.LM642>:
		{
			status = 0;
			valve.comm.faultMode = 1;
    7404:	6001      	lod	AL, #1
    7406:	42d8 1227 	mov	0x1227 <.LLST6+0x8>, AL

0000740a <.LM643>:
			status = 0;
			valve.comm.faultMode = 1;
		}
		if (valve.diag.vs.OVretryCnt > CHECK_OVER_VOLTAGE_CNT)
		{
			status = 0;
    740a:	7c00      	lod	X, #0

0000740c <.L307>:
			valve.comm.faultMode = 1;
		}
	}

	if (valve.diag.temp.state == TEMPERATURE_NORMAL)
    740c:	72d8 1244 	lod	A, 0x1244 <.LLST0+0x12>
    7410:	1d01      	jne	0x7414 <.LM645>
    7412:	0041      	jmp	0x7496 <.L338>

00007414 <.LM645>:
	{
		status = 0;
	}
	else
	{
		if (valve.diag.temp.retryCnt >= CHECK_HIGH_TEMP_CNT)
    7414:	72d8 1246 	lod	A, 0x1246 <.LLST0+0x14>
    7418:	ac09      	cmp	A, #9
    741a:	1a04      	jule	0x7424 <.L309>

0000741c <.LM646>:
		{
			status = 0;
			valve.comm.faultMode = 1;
    741c:	6001      	lod	AL, #1
    741e:	42d8 1227 	mov	0x1227 <.LLST6+0x8>, AL

00007422 <.LM647>:
	}
	else
	{
		if (valve.diag.temp.retryCnt >= CHECK_HIGH_TEMP_CNT)
		{
			status = 0;
    7422:	7c00      	lod	X, #0

00007424 <.L309>:
			valve.comm.faultMode = 1;
		}
	}
	if (valve.diag.McuFault != 0)
    7424:	62d8 125c 	lod	AL, 0x125c <.LLST6+0xa>
    7428:	1d07      	jne	0x7438 <.L339>

0000742a <.LM649>:
	{
		status = 0;
	}
	else
	{
		if (valve.diag.mcuRetryCnt >= 10)
    742a:	62d8 125d 	lod	AL, 0x125d <.LLST6+0xb>
    742e:	8c09      	cmp	AL, #9
    7430:	1a04      	jule	0x743a <.L310>

00007432 <.LM650>:
		{
			status = 0;
			valve.comm.faultMode = 1;
    7432:	6001      	lod	AL, #1
    7434:	42d8 1227 	mov	0x1227 <.LLST6+0x8>, AL

00007438 <.L339>:
			valve.comm.faultMode = 1;
		}
	}
	if (valve.diag.McuFault != 0)
	{
		status = 0;
    7438:	7c00      	lod	X, #0

0000743a <.L310>:
		{
			status = 0;
			valve.comm.faultMode = 1;
		}
	}
	if ((valve.diag.stallFault & STALL_MASK_TEMPORARY) != 0)
    743a:	62d8 1264 	lod	AL, 0x1264 <.LLST6+0x12>
    743e:	9401      	and	AL, #1
    7440:	1901      	je	0x7444 <.L311>

00007442 <.LM653>:
	{
		status = 0;
    7442:	7c00      	lod	X, #0

00007444 <.L311>:
	}
	if ((valve.diag.motorFault & FAULT_MASK_OVER_CURRENT) != 0)
    7444:	62d8 1263 	lod	AL, 0x1263 <.LLST6+0x11>
    7448:	9440      	and	AL, #64
    744a:	1901      	je	0x744e <.L312>

0000744c <.LM655>:
	{
		status = 0;
    744c:	7c00      	lod	X, #0

0000744e <.L312>:
	}

	if ((valve.diag.gmr.state != 0) || (valve.pos.fault != 0))
    744e:	62d8 1252 	lod	AL, 0x1252 <.LLST6>
    7452:	1d23      	jne	0x749a <.L342>
    7454:	66e0      	lod	YL, AL
    7456:	5cf6      	usex	Y
    7458:	62d8 120e 	lod	AL, 0x120e <.LLST4+0x6>
    745c:	1d20      	jne	0x749e <.L343>

0000745e <.L313>:
	{
		status = 0;
	}
	if (valve.linLiveTimeOut == 0)
    745e:	72d8 11fc 	lod	A, 0x11fc <_valve+0x4>
    7462:	1d01      	jne	0x7466 <.LM658>
    7464:	049c      	jmp	0x6d9e <.L314>

00007466 <.LM658>:
	{
		status = 0;
	}
	if ((status != 0) && (valve.comm.faultMode == 0))
    7466:	2c00      	cmp	X, #0
    7468:	1d01      	jne	0x746c <.LASF2071+0x4>
    746a:	0499      	jmp	0x6d9e <.L314>
    746c:	62d8 1227 	lod	AL, 0x1227 <.LLST6+0x8>
    7470:	04b6      	jmp	0x6dde <.L555>

00007472 <.L300>:
		{
			MotClearStallFlag(1);
		}
		else
		{
			valve.comm.faultMode = 1;
    7472:	6001      	lod	AL, #1
    7474:	42d8 1227 	mov	0x1227 <.LLST6+0x8>, AL
    7478:	079d      	jmp	0x73b4 <.L301>

0000747a <.L302>:
		{
			MotClearFaultFlag(3);
		}
		else
		{
			valve.comm.faultMode = 1;
    747a:	6001      	lod	AL, #1
    747c:	42d8 1227 	mov	0x1227 <.LLST6+0x8>, AL
    7480:	07a1      	jmp	0x73c4 <.L303>

00007482 <.L304>:
		{
			valve.pos.fault = 0;
		}
		else
		{
			valve.comm.faultMode = 1;
    7482:	6001      	lod	AL, #1
    7484:	42d8 1227 	mov	0x1227 <.LLST6+0x8>, AL
    7488:	07a5      	jmp	0x73d4 <.L305>

0000748a <.L306>:
		{
			valve.diag.gmr.state = 0;
		}
		else
		{
			valve.comm.faultMode = 1;
    748a:	6001      	lod	AL, #1
    748c:	42d8 1227 	mov	0x1227 <.LLST6+0x8>, AL
    7490:	07a9      	jmp	0x73e4 <.L299>

00007492 <.L337>:
}

static tValveState ValveProtectionTask(void)
{
	tValveState nextState = VALVE_PROTECTION;
	uint16_t status = 1;
    7492:	7c01      	lod	X, #1
    7494:	07b3      	jmp	0x73fc <.L308>

00007496 <.L338>:
		}
	}

	if (valve.diag.temp.state == TEMPERATURE_NORMAL)
	{
		status = 0;
    7496:	7ee2      	lod	X, A

00007498 <.LVL256>:
    7498:	07c5      	jmp	0x7424 <.L309>

0000749a <.L342>:
		status = 0;
	}

	if ((valve.diag.gmr.state != 0) || (valve.pos.fault != 0))
	{
		status = 0;
    749a:	7c00      	lod	X, #0

0000749c <.LVL258>:
    749c:	07e0      	jmp	0x745e <.L313>

0000749e <.L343>:
    749e:	7ee6      	lod	X, Y

000074a0 <.LVL260>:
    74a0:	07de      	jmp	0x745e <.L313>

000074a2 <.L197>:
}
static tValveState ValvePowerLatchTask(void)
{
	tValveState nextState = VALVE_POWERLATCH;

	MotRequestHardStop();
    74a2:	13c5      	call	0x7c2e <_MotRequestHardStop>

000074a4 <.LM667>:
	if (valve.initStatus != 0)
    74a4:	62d8 1203 	lod	AL, 0x1203 <_valve+0xb>
    74a8:	1903      	je	0x74b0 <.L315>

000074aa <.LM668>:
	{
		valve.initStatus = 0;
    74aa:	6000      	lod	AL, #0
    74ac:	42d8 1203 	mov	0x1203 <_valve+0xb>, AL

000074b0 <.L315>:
	}
	if (valve.diag.ign.state != IGN_OFF)
    74b0:	72d8 124c 	lod	A, 0x124c <.LLST0+0x1a>
    74b4:	ac01      	cmp	A, #1
    74b6:	1927      	je	0x7506 <.L344>

000074b8 <.LM670>:
	{

		nextState = valve.lastState;
    74b8:	72d8 11fa 	lod	A, 0x11fa <_valve+0x2>

000074bc <.LVL263>:
    74bc:	041d      	jmp	0x6cf8 <.L200>

000074be <.L198>:
}
static tValveState ValveLowPowerTask(void)
{
	tValveState nextState = VALVE_LOWPOWER;

	if (valve.initStatus != 0)
    74be:	62d8 1203 	lod	AL, 0x1203 <_valve+0xb>
    74c2:	1903      	je	0x74ca <.L316>

000074c4 <.LM672>:
	{
		valve.initStatus = 0;
    74c4:	6000      	lod	AL, #0
    74c6:	42d8 1203 	mov	0x1203 <_valve+0xb>, AL

000074ca <.L316>:
	}
	if (valve.diag.ign.state != IGN_OFF)
    74ca:	72d8 124c 	lod	A, 0x124c <.LLST0+0x1a>
    74ce:	ac01      	cmp	A, #1
    74d0:	1d0c      	jne	0x74ea <.L345>

000074d2 <.LM674>:

	return nextState;
}
static tValveState ValveLowPowerTask(void)
{
	tValveState nextState = VALVE_LOWPOWER;
    74d2:	7009      	lod	A, #9

000074d4 <.L317>:
	{

		nextState = VALVE_STANDBY;
	}

	if (valve.elapsedTime >= 60000u) /*60sec*/
    74d4:	7ed8 11fe 	lod	X, 0x11fe <_valve+0x6>
    74d8:	2eda ea5f 	cmp	X, #59999
    74dc:	1e01      	jug	0x74e0 <.LM676>
    74de:	040c      	jmp	0x6cf8 <.L200>

000074e0 <.LM676>:
	{
		AppLinSleepEnter();
    74e0:	5203      	mov	[S-4], A
    74e2:	82db 31e9 	callf	0x63d2 <_AppLinSleepEnter>

000074e6 <.LVL266>:
    74e6:	7203      	lod	A, [S-4]
    74e8:	0407      	jmp	0x6cf8 <.L200>

000074ea <.L345>:
		valve.initStatus = 0;
	}
	if (valve.diag.ign.state != IGN_OFF)
	{

		nextState = VALVE_STANDBY;
    74ea:	7001      	lod	A, #1
    74ec:	07f3      	jmp	0x74d4 <.L317>

000074ee <.L199>:
static tValveState ValveUndefTask(void)
{

	tValveState nextState = VALVE_UNDEF;

	if (valve.initStatus != 0)
    74ee:	62d8 1203 	lod	AL, 0x1203 <_valve+0xb>
    74f2:	1903      	je	0x74fa <.L346>

000074f4 <.LM679>:
	{
		valve.initStatus = 0;
    74f4:	6000      	lod	AL, #0
    74f6:	42d8 1203 	mov	0x1203 <_valve+0xb>, AL

000074fa <.L346>:
		break;
	case VALVE_LOWPOWER:
		nextState = ValveLowPowerTask();
		break;
	case VALVE_UNDEF:
		nextState = ValveUndefTask();
    74fa:	700a      	lod	A, #10
    74fc:	76da 367c 	jmpf	0x6cf8 <.L200>

00007500 <.L326>:
	valve.diag.temp.retryCnt = 0;
}

static tValveState ValveInitTask(void)
{
	tValveState nextState = VALVE_INIT;
    7500:	7000      	lod	A, #0
    7502:	76da 367c 	jmpf	0x6cf8 <.L200>

00007506 <.L344>:
	}
	return nextState;
}
static tValveState ValvePowerLatchTask(void)
{
	tValveState nextState = VALVE_POWERLATCH;
    7506:	7008      	lod	A, #8
    7508:	76da 367c 	jmpf	0x6cf8 <.L200>

0000750c <.L321>:
	{
		valve.linLiveTimeOut -= 1;
	}
	else
	{
		valve.diag.linError = 1;
    750c:	6001      	lod	AL, #1
    750e:	42d8 125a 	mov	0x125a <.LLST6+0x8>, AL
    7512:	040b      	jmp	0x6d2a <.L322>

00007514 <_adc_DoSoftwareTrigger>:
    7514:	5803      	inc	S, #4

00007516 <.LCFI0>:
    7516:	5201      	mov	[S-2], A

00007518 <.LM2>:
    7518:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>

0000751c <.LVL2>:
    751c:	9401      	and	AL, #1
    751e:	1d0a      	jne	0x7534 <.L2>

00007520 <.LBB540>:
    7520:	601f      	lod	AL, #31
    7522:	42d8 016b 	mov	0x16b <.LASF1962>, AL

00007526 <.LBB542>:
    7526:	7002      	lod	A, #2
    7528:	0ea7      	lod	C, ML.7
    752a:	52d8 016a 	mov	0x16a <_ADC_SAR+0x4>, A

0000752e <.LBB544>:
    752e:	7001      	lod	A, #1
    7530:	52d8 0166 	mov	0x166 <_ADC_SAR>, A

00007534 <.L2>:
    7534:	7028      	lod	A, #40
    7536:	82db 1128 	callf	0x2250 <_delay_cycles>

0000753a <.LBB549>:
    753a:	6004      	lod	AL, #4
    753c:	42d8 016a 	mov	0x16a <_ADC_SAR+0x4>, AL

00007540 <.L3>:
    7540:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>
    7544:	b402      	and	A, #2
    7546:	1902      	je	0x754c <.L5>

00007548 <.LM9>:
    7548:	7000      	lod	A, #0
    754a:	5405      	ret	#6

0000754c <.L5>:
    754c:	7ed8 016a 	lod	X, 0x16a <_ADC_SAR+0x4>
    7550:	7aee      	lod	Y, X
    7552:	44c8      	rl	YL, #2
    7554:	f403      	and	Y, #3
    7556:	ee01      	cmp	Y, [S-2]
    7558:	1906      	je	0x7566 <.L6>

0000755a <.LM11>:
    755a:	7ed8 016a 	lod	X, 0x16a <_ADC_SAR+0x4>
    755e:	36da 1000 	and	X, #4096
    7562:	196e      	je	0x7540 <.L3>

00007564 <.L4>:
    7564:	5405      	ret	#6

00007566 <.L6>:
    7566:	7001      	lod	A, #1
    7568:	07fd      	jmp	0x7564 <.L4>

0000756a <_adc_Init>:
    756a:	1290      	call	0x7a8c <_conv_high_voltage_init>

0000756c <.LM16>:
    756c:	12df      	call	0x7b2c <_conv_low_voltage_init>

0000756e <.LM17>:
    756e:	12f7      	call	0x7b5e <_conv_motor_voltage_init>

00007570 <.LM18>:
    7570:	132c      	call	0x7bca <_conv_shunt_current_init>

00007572 <.LBB551>:
    7572:	7000      	lod	A, #0
    7574:	52d8 131a 	mov	0x131a <_calib_current>, A

00007578 <.LBE551>:
    7578:	62d8 01f5 	lod	AL, 0x1f5 <_PORT_MISC2_OUT+0x1>
    757c:	8404      	or	AL, #4
    757e:	42d8 01f5 	mov	0x1f5 <_PORT_MISC2_OUT+0x1>, AL

00007582 <.LBB553>:
    7582:	72da 2710 	lod	A, #10000
    7586:	82db 1128 	callf	0x2250 <_delay_cycles>

0000758a <.LBE553>:
    758a:	62d8 020e 	lod	AL, 0x20e <_PORT_DRV_OUT>
    758e:	8440      	or	AL, #64
    7590:	42d8 020e 	mov	0x20e <_PORT_DRV_OUT>, AL

00007594 <.LM23>:
    7594:	62b4      	lod	AL, io:0x34 <_PORT_ADC_CTRL>
    7596:	8402      	or	AL, #2
    7598:	42b4      	mov	io:0x34 <_PORT_ADC_CTRL>, AL

0000759a <.LBB556>:
    759a:	7ee3      	lod	X, M

0000759c <.LBB559>:
    759c:	5049      	call	fp2:0x48

0000759e <.LBE559>:
    759e:	62d8 008c 	lod	AL, 0x8c <.LASF1529>
    75a2:	94f3      	and	AL, #-13
    75a4:	8404      	or	AL, #4
    75a6:	42d8 008c 	mov	0x8c <.LASF1529>, AL

000075aa <.LM27>:
    75aa:	62d8 0070 	lod	AL, 0x70 <__mlx4_cst_tables_ram_size+0x12>
    75ae:	8420      	or	AL, #32
    75b0:	42d8 0070 	mov	0x70 <__mlx4_cst_tables_ram_size+0x12>, AL

000075b4 <.LBB561>:
    75b4:	5ee3      	mov	M, X

000075b6 <.LBE556>:
    75b6:	5401      	ret

000075b8 <_adc_Start>:
    75b8:	7ee2      	lod	X, A

000075ba <.LBB565>:
    75ba:	601f      	lod	AL, #31

000075bc <.LVL18>:
    75bc:	42d8 016b 	mov	0x16b <.LASF1962>, AL

000075c0 <.LBB567>:
    75c0:	7002      	lod	A, #2
    75c2:	0ea7      	lod	C, ML.7
    75c4:	52d8 016a 	mov	0x16a <_ADC_SAR+0x4>, A

000075c8 <.LBB569>:
    75c8:	62b4      	lod	AL, io:0x34 <_PORT_ADC_CTRL>
    75ca:	8402      	or	AL, #2
    75cc:	42b4      	mov	io:0x34 <_PORT_ADC_CTRL>, AL

000075ce <.LM38>:
    75ce:	62d8 0166 	lod	AL, 0x166 <_ADC_SAR>
    75d2:	94fc      	and	AL, #-4
    75d4:	8402      	or	AL, #2
    75d6:	42d8 0166 	mov	0x166 <_ADC_SAR>, AL

000075da <.LM39>:
    75da:	6007      	lod	AL, #7
    75dc:	42d8 016c 	mov	0x16c <.LASF1962+0x1>, AL

000075e0 <.LM40>:
    75e0:	0ea7      	lod	C, ML.7
    75e2:	72da 101a 	lod	A, #4122
    75e6:	52d8 0168 	mov	0x168 <_ADC_SAR+0x2>, A

000075ea <.LM41>:
    75ea:	72da 0ac4 	lod	A, #2756
    75ee:	0ea7      	lod	C, ML.7
    75f0:	52d8 0166 	mov	0x166 <_ADC_SAR>, A

000075f4 <.LBB571>:
    75f4:	7ae3      	lod	Y, M

000075f6 <.LBB574>:
    75f6:	5049      	call	fp2:0x48

000075f8 <.LBE574>:
    75f8:	6020      	lod	AL, #32
    75fa:	42d8 0054 	mov	0x54 <.Lframe0>, AL

000075fe <.LBB576>:
    75fe:	5ae3      	mov	M, Y

00007600 <.LBB580>:
    7600:	7001      	lod	A, #1
    7602:	0ea7      	lod	C, ML.7
    7604:	52d8 0166 	mov	0x166 <_ADC_SAR>, A

00007608 <.LBE580>:
    7608:	2c00      	cmp	X, #0
    760a:	1904      	je	0x7614 <.L10>

0000760c <.L12>:
    760c:	72d8 0054 	lod	A, 0x54 <.Lframe0>
    7610:	9420      	and	AL, #32
    7612:	197c      	je	0x760c <.L12>

00007614 <.L10>:
    7614:	5401      	ret

00007616 <_adc_Stop>:
    7616:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>
    761a:	9402      	and	AL, #2
    761c:	1d1c      	jne	0x7656 <.L18>

0000761e <.L39>:
    761e:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>
    7622:	9402      	and	AL, #2
    7624:	1d14      	jne	0x764e <.L22>

00007626 <.LBB593>:
    7626:	7002      	lod	A, #2
    7628:	52d8 0166 	mov	0x166 <_ADC_SAR>, A
    762c:	07f8      	jmp	0x761e <.L39>

0000762e <.L23>:
    762e:	7001      	lod	A, #1
    7630:	52d8 0166 	mov	0x166 <_ADC_SAR>, A

00007634 <.L40>:
    7634:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>
    7638:	9401      	and	AL, #1
    763a:	1979      	je	0x762e <.L23>

0000763c <.LBB597>:
    763c:	0000      	nop

0000763e <.L41>:
    763e:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>
    7642:	9402      	and	AL, #2
    7644:	1d04      	jne	0x764e <.L22>

00007646 <.LBB599>:
    7646:	7002      	lod	A, #2
    7648:	52d8 0166 	mov	0x166 <_ADC_SAR>, A
    764c:	07f8      	jmp	0x763e <.L41>

0000764e <.L22>:
    764e:	72d8 016a 	lod	A, 0x16a <_ADC_SAR+0x4>
    7652:	94c0      	and	AL, #-64
    7654:	1d6f      	jne	0x7634 <.L40>

00007656 <.L18>:
    7656:	5401      	ret

00007658 <_adc_Shunt_OffsetCalib>:
    7658:	581d      	inc	S, #30

0000765a <.LCFI1>:
    765a:	7eef      	lod	X, S
    765c:	20f0      	add	X, #-16
    765e:	7800      	lod	Y, #0
    7660:	72e6      	lod	A, Y
    7662:	52de      	mov	[X++], A
    7664:	52de      	mov	[X++], A
    7666:	52de      	mov	[X++], A
    7668:	720f      	lod	A, [S-16]
    766a:	5207      	mov	[S-8], A
    766c:	720d      	lod	A, [S-14]
    766e:	5205      	mov	[S-6], A
    7670:	720b      	lod	A, [S-12]
    7672:	5203      	mov	[S-4], A
    7674:	72ef      	lod	A, S
    7676:	a0ea      	add	A, #-22
    7678:	5209      	mov	[S-10], A
    767a:	7207      	lod	A, [S-8]
    767c:	b483      	and	A, #-125
    767e:	a440      	or	A, #64
    7680:	b6da fc7f 	and	A, #64639
    7684:	a6da 0180 	or	A, #384
    7688:	5207      	mov	[S-8], A
    768a:	7205      	lod	A, [S-6]
    768c:	b483      	and	A, #-125
    768e:	a440      	or	A, #64
    7690:	b6da fc7f 	and	A, #64639
    7694:	a6da 0180 	or	A, #384
    7698:	5205      	mov	[S-6], A
    769a:	7203      	lod	A, [S-4]
    769c:	8403      	or	AL, #3
    769e:	5203      	mov	[S-4], A
    76a0:	7209      	lod	A, [S-10]
    76a2:	521d      	mov	[S-30], A
    76a4:	7207      	lod	A, [S-8]
    76a6:	521b      	mov	[S-28], A
    76a8:	7205      	lod	A, [S-6]
    76aa:	5219      	mov	[S-26], A
    76ac:	7203      	lod	A, [S-4]
    76ae:	5217      	mov	[S-24], A

000076b0 <.LM63>:
    76b0:	5a01      	mov	[S-2], Y
    76b2:	17b1      	call	0x7616 <_adc_Stop>

000076b4 <.LM64>:
    76b4:	62d8 020e 	lod	AL, 0x20e <_PORT_DRV_OUT>
    76b8:	8440      	or	AL, #64
    76ba:	42d8 020e 	mov	0x20e <_PORT_DRV_OUT>, AL

000076be <.LM65>:
    76be:	62b4      	lod	AL, io:0x34 <_PORT_ADC_CTRL>
    76c0:	8402      	or	AL, #2
    76c2:	42b4      	mov	io:0x34 <_PORT_ADC_CTRL>, AL

000076c4 <.LBB601>:
    76c4:	62b4      	lod	AL, io:0x34 <_PORT_ADC_CTRL>
    76c6:	8402      	or	AL, #2
    76c8:	42b4      	mov	io:0x34 <_PORT_ADC_CTRL>, AL

000076ca <.LM67>:
    76ca:	62d8 0166 	lod	AL, 0x166 <_ADC_SAR>
    76ce:	94fc      	and	AL, #-4
    76d0:	8402      	or	AL, #2
    76d2:	42d8 0166 	mov	0x166 <_ADC_SAR>, AL

000076d6 <.LM68>:
    76d6:	6007      	lod	AL, #7
    76d8:	42d8 016c 	mov	0x16c <.LASF1962+0x1>, AL

000076dc <.LM69>:
    76dc:	72ef      	lod	A, S
    76de:	a0e2      	add	A, #-30

000076e0 <.LVL26>:
    76e0:	52d8 0168 	mov	0x168 <_ADC_SAR+0x2>, A

000076e4 <.LM70>:
    76e4:	72da 08d8 	lod	A, #2264

000076e8 <.LVL27>:
    76e8:	52d8 0166 	mov	0x166 <_ADC_SAR>, A

000076ec <.LBE601>:
    76ec:	0ea7      	lod	C, ML.7
    76ee:	7003      	lod	A, #3
    76f0:	1711      	call	0x7514 <_adc_DoSoftwareTrigger>

000076f2 <.LM72>:
    76f2:	7a01      	lod	Y, [S-2]
    76f4:	72e6      	lod	A, Y
    76f6:	170e      	call	0x7514 <_adc_DoSoftwareTrigger>

000076f8 <.LM73>:
    76f8:	7215      	lod	A, [S-22]
    76fa:	7e13      	lod	X, [S-20]
    76fc:	a2ee      	add	A, X
    76fe:	a001      	add	A, #1
    7700:	4432      	lsr	A
    7702:	52d8 10ba 	mov	0x10ba <_i16MotorCurrentZeroOffset>, A

00007706 <.LM74>:
    7706:	541f      	ret	#32

00007708 <_adc_ConvertToCurrent>:
int16_t adc_ConvertToCurrent(uint16_t u16AdcVal)
{
    int16_t current;

    /* the current sensor current in mA units */
    current = conv_shunt_current(u16AdcVal); // Option-A
    7708:	0275      	jmp	0x7bf4 <_conv_shunt_current>

0000770a <_adc_ConvertToTchip>:
 * @param[in]  u16AdcVal  Raw adc measurement.
 * @return  the temperature in 1 degC.
 */
int16_t adc_ConvertToTchip(uint16_t u16AdcVal)
{
    return CalculateTemperature3pLinearize(u16AdcVal);
    770a:	76da 502d 	jmpf	0xa05a <_CalculateTemperature3pLinearize>

0000770e <_adc_ConvertToVsupply>:
 * @param[in]  u16AdcVal  Raw adc measurement.
 * @return  the supply voltage in 10 mV.
 */
int16_t adc_ConvertToVsupply(uint16_t u16AdcVal)
{
    return conv_high_voltage_with_tcorrection(u16AdcVal, dBase[ADC_SAMPLE_TEMP]);
    770e:	7ed8 12c6 	lod	X, 0x12c6 <_dBase+0x2>
    7712:	5edf      	push	X

00007714 <.LCFI5>:
    7714:	11e5      	call	0x7ae0 <_conv_high_voltage_with_tcorrection>

00007716 <.LCFI6>:
}
    7716:	5403      	ret	#4

00007718 <_adc_ConvertToVoltage>:
 */
MATHLIB_INLINE_STATIC __inline__ uint32_t mulU32_U16byU16(uint16_t multiplicand, uint16_t multiplier)
{
    uint32_t result;

    __asm__ __volatile__ (
    7718:	4822 0294 	mulu	YA, A, #660

0000771c <.LBE605>:
 */
int16_t adc_ConvertToVoltage(uint16_t u16AdcVal)
{
    int16_t i16Volt;

    i16Volt = (int16_t)(mulU32_U16byU16(u16AdcVal, 660u) / 1024u);
    771c:	48a9      	lsr	YA, #10

0000771e <.LM106>:

    return (i16Volt);
}
    771e:	5401      	ret

00007720 <__ADC_SAR_INT>:
/**
 * @brief ADC Interrupt Service Routine
 * In case no ADC_ISR action required, this ISR has 4us overhead
 */
__attribute__((interrupt)) void _ADC_SAR_INT(void)
{
    7720:	5edf      	push	X

00007722 <.LCFI9>:
    7722:	5adf      	push	Y

00007724 <.LCFI10>:
    7724:	52df      	push	A

00007726 <.LCFI11>:
    7726:	4c83      	push	D

00007728 <.LCFI12>:
    if (p16AdcIrq != NULL)
    7728:	72d8 10b8 	lod	A, 0x10b8 <_p16AdcIrq>
    772c:	1903      	je	0x7734 <.L51>

0000772e <.LM109>:
    {
        p16AdcIrq();
    772e:	0001      	jmp	0x7732 <.L57>

00007730 <.L56>:
    7730:	76e2      	jmp	A

00007732 <.L57>:
    7732:	17fe      	call	0x7730 <.L56>

00007734 <.L51>:
    if (p16AdcIrq2 != NULL)
    {
        p16AdcIrq2();
    }
#endif
}
    7734:	4cc3      	pop	D

00007736 <.LCFI13>:
    7736:	72cf      	pop	A

00007738 <.LCFI14>:
    7738:	7acf      	pop	Y

0000773a <.LCFI15>:
    773a:	7ecf      	pop	X

0000773c <.LCFI16>:
    773c:	72cb      	pop	M
    773e:	5401      	ret

00007740 <_gmr_calibration_setup>:
	l16_SetGmrSensorOffset = (DEFAULT_GMR_OFFSET * C_GMR_ANGLE_SCALE_FACTOR);
	l_au16MotorOffsetCurrent = 0;
}
void gmr_calibration_setup(void)
{
	l16_GmrCalEnable = 1;
    7740:	7801      	lod	Y, #1
    7742:	5ad8 10be 	mov	0x10be <_l16_GmrCalEnable>, Y

00007746 <.LM3>:
	l16_SinPosMaxPeak = 0;
    7746:	7c00      	lod	X, #0
    7748:	0ea7      	lod	C, ML.7
    774a:	5ed8 12ee 	mov	0x12ee <_l16_SinPosMaxPeak>, X

0000774e <.LM4>:
	l16_SinPosMinPeak = 0x7fff;
    774e:	72da 7fff 	lod	A, #32767
    7752:	52d8 12e8 	mov	0x12e8 <_l16_SinPosMinPeak>, A

00007756 <.LM5>:
	l16_SinNegMaxPeak = 0;
    7756:	0ea7      	lod	C, ML.7
    7758:	5ed8 12e6 	mov	0x12e6 <_l16_SinNegMaxPeak>, X

0000775c <.LM6>:
	l16_SinNegMinPeak = 0x7fff;
    775c:	52d8 12f2 	mov	0x12f2 <_l16_SinNegMinPeak>, A

00007760 <.LM7>:
	l16_CosinPosMaxPeak = 0;
    7760:	5ed8 12ec 	mov	0x12ec <_l16_CosinPosMaxPeak>, X

00007764 <.LM8>:
	l16_CosinPosMinPeak = 0x7fff;
    7764:	0ea7      	lod	C, ML.7
    7766:	52d8 12ea 	mov	0x12ea <_l16_CosinPosMinPeak>, A

0000776a <.LM9>:
	l16_CosinNegMaxPeak = 0;
    776a:	5ed8 12f4 	mov	0x12f4 <_l16_CosinNegMaxPeak>, X

0000776e <.LM10>:
	l16_CosinNegMinPeak = 0x7fff;
    776e:	52d8 12f0 	mov	0x12f0 <_l16_CosinNegMinPeak>, A

00007772 <.LM11>:
	l16_SinOutputOffset = 0xFFFF;
    7772:	0ea7      	lod	C, ML.7
    7774:	70ff      	lod	A, #-1
    7776:	52d8 12f6 	mov	0x12f6 <_l16_SinOutputOffset>, A

0000777a <.LM12>:
	l16_CosinOutputOffset = 1;
    777a:	5ad8 12f8 	mov	0x12f8 <_l16_CosinOutputOffset>, Y

0000777e <.LM13>:
}
    777e:	5401      	ret

00007780 <_sensor_init>:
int16_t l16_CosinNegMinPeak;
int16_t l16_SinOutputOffset;
int16_t l16_CosinOutputOffset;
int16_t l16_SetGmrSensorOffset = 0;
void sensor_init(void)
{
    7780:	5803      	inc	S, #4

00007782 <.LCFI0>:
    7782:	7eda 103a 	lod	X, #4154
    7786:	5e03      	mov	[S-4], X

00007788 <.LM15>:
	uint16_t num = 0, index = 0, initValue;

	for (num = 0; num < C_ADC_END_ITEM; num++)
    7788:	7000      	lod	A, #0
    778a:	5201      	mov	[S-2], A

0000778c <.LM16>:
	{
		if (num == C_ADC_VS_)
			initValue = 0xFF;
    778c:	72da 00ff 	lod	A, #255

00007790 <.L3>:
    7790:	7e03      	lod	X, [S-4]
    7792:	7afc      	lod	Y, [X+4]
    7794:	7c08      	lod	X, #8

00007796 <.L5>:
		else
			initValue = 0;
		l_sAdcAvgObject[num].u32MovAvgxN = 0;
		for (index = 0; index < 8; index++)
		{
			l_sAdcAvgObject[num].pu16Raw[index] = initValue;
    7796:	52d6      	mov	[Y++], A

00007798 <.LM18>:
		else if (num == C_ADC_TEMP_)
			initValue = 0x260;
		else
			initValue = 0;
		l_sAdcAvgObject[num].u32MovAvgxN = 0;
		for (index = 0; index < 8; index++)
    7798:	1bfe      	djnz	X, 0x7796 <.L5>
    779a:	4cf2      	usex	YA

0000779c <.LVL3>:
    779c:	48e2      	asl	YA, #3
    779e:	7e03      	lod	X, [S-4]
    77a0:	4ca7      	mov	[X], YA

000077a2 <.LM19>:
int16_t l16_SetGmrSensorOffset = 0;
void sensor_init(void)
{
	uint16_t num = 0, index = 0, initValue;

	for (num = 0; num < C_ADC_END_ITEM; num++)
    77a2:	7201      	lod	A, [S-2]
    77a4:	a001      	add	A, #1

000077a6 <.LVL5>:
    77a6:	5201      	mov	[S-2], A
    77a8:	ac09      	cmp	A, #9
    77aa:	1d06      	jne	0x77b8 <.L6>

000077ac <.LM20>:
		{
			l_sAdcAvgObject[num].pu16Raw[index] = initValue;
			l_sAdcAvgObject[num].u32MovAvgxN += initValue;
		}
	}
	gmr_calibration_setup();
    77ac:	17c9      	call	0x7740 <_gmr_calibration_setup>

000077ae <.LM21>:
	//	l16_SetGmrSensorOffset=C_GMR_SENSOR_OFFSET*C_GMR_ANGLE_SCALE_FACTOR;
	l16_SetGmrSensorOffset = (DEFAULT_GMR_OFFSET * C_GMR_ANGLE_SCALE_FACTOR);
    77ae:	72da 0456 	lod	A, #1110
    77b2:	52d8 10bc 	mov	0x10bc <_l16_SetGmrSensorOffset>, A

000077b6 <.LM22>:
	l_au16MotorOffsetCurrent = 0;
}
    77b6:	5405      	ret	#6

000077b8 <.L6>:

	for (num = 0; num < C_ADC_END_ITEM; num++)
	{
		if (num == C_ADC_VS_)
			initValue = 0xFF;
		else if (num == C_ADC_TEMP_)
    77b8:	7e01      	lod	X, [S-2]
    77ba:	2c01      	cmp	X, #1
    77bc:	1d06      	jne	0x77ca <.L7>

000077be <.LM24>:
			initValue = 0x260;
    77be:	72da 0260 	lod	A, #608

000077c2 <.L4>:
    77c2:	7e03      	lod	X, [S-4]
    77c4:	200c      	add	X, #12
    77c6:	5e03      	mov	[S-4], X
    77c8:	07e3      	jmp	0x7790 <.L3>

000077ca <.L7>:
		else
			initValue = 0;
    77ca:	7000      	lod	A, #0
    77cc:	07fa      	jmp	0x77c2 <.L4>

000077ce <_set_gmr_sensor_offset>:
void gmr_calibration_end(void)
{
}
void set_gmr_sensor_offset(int16_t offset)
{
	l16_SetGmrSensorOffset = offset;
    77ce:	52d8 10bc 	mov	0x10bc <_l16_SetGmrSensorOffset>, A

000077d2 <.LM30>:
}
    77d2:	5401      	ret

000077d4 <_get_gmr_sensor_offset>:
int16_t get_gmr_sensor_offset(void)
{
	return l16_SetGmrSensorOffset;
}
    77d4:	72d8 10bc 	lod	A, 0x10bc <_l16_SetGmrSensorOffset>
    77d8:	5401      	ret

000077da <_adc_raw_update>:
void adc_raw_update(void)
{
    77da:	5801      	inc	S, #2

000077dc <.LCFI1>:
	uint16_t index = 0;

	for (index = 0; index < C_ADC_END_ITEM; index++)
    77dc:	7000      	lod	A, #0
    77de:	5201      	mov	[S-2], A

000077e0 <.L25>:
	{
		switch (index)
    77e0:	7201      	lod	A, [S-2]
    77e2:	a0ff      	add	A, #-1
    77e4:	ac07      	cmp	A, #7
    77e6:	1e05      	jug	0x77f2 <.L13>
    77e8:	4422      	asl	A
    77ea:	7ee2      	lod	X, A
    77ec:	22da 5cec 	add	X, #23788
    77f0:	76f8      	jmp	[X]

000077f2 <.L13>:
 * @returns  raw Vs adc sample.
 */
static INLINE uint16_t adc_GetRawVs(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_VS];
    77f2:	72d8 12ce 	lod	A, 0x12ce <_dBase+0xa>

000077f6 <.LBE38>:
		{
		case C_ADC_VS_:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_VS_], adc_GetRawVs());
    77f6:	52df      	push	A

000077f8 <.LCFI2>:
    77f8:	72da 1038 	lod	A, #4152

000077fc <.L28>:
		case C_ADC_SENSOR_3:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_SENSOR_3], adc_Get_GMR_pCosine());
			//						temp = l_sAdcAvgObject[C_ADC_SENSOR_].u16MovAvg;
			break;
		case C_ADC_SENSOR_4:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_SENSOR_4], adc_Get_GMR_pSine());
    77fc:	82db 43d8 	callf	0x87b0 <_FILTER_AVG_CalcMovAvg>

00007800 <.LM39>:
}
void adc_raw_update(void)
{
	uint16_t index = 0;

	for (index = 0; index < C_ADC_END_ITEM; index++)
    7800:	7203      	lod	A, [S-4]
    7802:	5c01      	dec	S, #2

00007804 <.LCFI3>:
    7804:	a001      	add	A, #1
    7806:	5201      	mov	[S-2], A
    7808:	ac09      	cmp	A, #9
    780a:	1d6a      	jne	0x77e0 <.L25>

0000780c <.LM40>:
			break;
		default:
			break;
		}
	}
}
    780c:	5403      	ret	#4

0000780e <.L14>:
 * @returns  raw temperature adc sample.
 */
static INLINE uint16_t adc_GetRawTemperature(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_TEMP];
    780e:	72d8 12c6 	lod	A, 0x12c6 <_dBase+0x2>

00007812 <.LBE40>:
		case C_ADC_VS_:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_VS_], adc_GetRawVs());
			//						temp = l_sAdcAvgObject[C_ADC_VS_].u16MovAvg;
			break;
		case C_ADC_TEMP_:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_TEMP_], adc_GetRawTemperature());
    7812:	52df      	push	A

00007814 <.LCFI4>:
    7814:	72da 1044 	lod	A, #4164
    7818:	07f1      	jmp	0x77fc <.L28>

0000781a <.L16>:
 */
static INLINE uint16_t adc_GetRawCurrent(void)
{
    extern volatile uint16_t dBase[];
    extern int16_t i16MotorCurrentZeroOffset;
    int16_t i16MotorCurrent = ((dBase[ADC_SAMPLE_CURR] + dBase[ADC_SAMPLE_CURR_2]) >> 1);
    781a:	72d8 12c8 	lod	A, 0x12c8 <_dBase+0x4>
    781e:	7ed8 12d4 	lod	X, 0x12d4 <_dBase+0x10>
    7822:	a2ee      	add	A, X
    7824:	4432      	lsr	A

00007826 <.LM44>:
    if (i16MotorCurrent >= i16MotorCurrentZeroOffset)
    7826:	7ed8 10ba 	lod	X, 0x10ba <_i16MotorCurrentZeroOffset>
    782a:	aeee      	cmp	A, X
    782c:	1a85      	jsl	0x7838 <.L26>

0000782e <.LM45>:
    {
        i16MotorCurrent -= i16MotorCurrentZeroOffset;
    782e:	aaee      	sub	A, X

00007830 <.L24>:
			//						temp = l_sAdcAvgObject[C_ADC_TEMP_].u16MovAvg;
			break;
		case C_ADC_CURRENT_:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_CURRENT_], adc_GetRawCurrent());
    7830:	52df      	push	A

00007832 <.LCFI6>:
    7832:	72da 1050 	lod	A, #4176
    7836:	07e2      	jmp	0x77fc <.L28>

00007838 <.L26>:
    }
    else
    {
        i16MotorCurrent = 0;
    7838:	7000      	lod	A, #0

0000783a <.LVL22>:
    783a:	07fa      	jmp	0x7830 <.L24>

0000783c <.L17>:
 * @returns  raw VDDA voltage sample.
 */
static INLINE uint16_t adc_GetRawVdda(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_VDDA];
    783c:	72d8 12ca 	lod	A, 0x12ca <_dBase+0x6>

00007840 <.LBE46>:
			//						temp = l_sAdcAvgObject[C_ADC_CURRENT_].u16MovAvg;
			break;
		case C_ADC_VDDA:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_VDDA], adc_GetRawVdda());
    7840:	52df      	push	A

00007842 <.LCFI8>:
    7842:	72da 105c 	lod	A, #4188
    7846:	07da      	jmp	0x77fc <.L28>

00007848 <.L18>:
 * @returns  raw IO voltage sample.
 */
static INLINE uint16_t adc_GetRawIGN(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_IGN];
    7848:	72d8 12cc 	lod	A, 0x12cc <_dBase+0x8>

0000784c <.LBE48>:
			//						temp = l_sAdcAvgObject[C_ADC_VDDA].u16MovAvg;
			break;
		case C_ADC_IGN:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_IGN], adc_GetRawIGN());
    784c:	52df      	push	A

0000784e <.LCFI10>:
    784e:	72da 1068 	lod	A, #4200
    7852:	07d4      	jmp	0x77fc <.L28>

00007854 <.L19>:
 * @returns  raw IO voltage sample.
 */
static INLINE uint16_t adc_Get_GMR_nCosine(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_GMR_IO1];
    7854:	72d8 12d0 	lod	A, 0x12d0 <_dBase+0xc>

00007858 <.LBE50>:
			//						temp = l_sAdcAvgObject[C_ADC_VREF_].u16MovAvg;
			break;
		case C_ADC_SENSOR_1:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_SENSOR_1], adc_Get_GMR_nCosine());
    7858:	52df      	push	A

0000785a <.LCFI12>:
    785a:	72da 1074 	lod	A, #4212
    785e:	07ce      	jmp	0x77fc <.L28>

00007860 <.L20>:
 * @returns  raw IO voltage sample.
 */
static INLINE uint16_t adc_Get_GMR_nSine(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_GMR_IO2];
    7860:	72d8 12d2 	lod	A, 0x12d2 <_dBase+0xe>

00007864 <.LBE52>:
			//						temp = l_sAdcAvgObject[C_ADC_SENSOR_].u16MovAvg;
			break;
		case C_ADC_SENSOR_2:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_SENSOR_2], adc_Get_GMR_nSine());
    7864:	52df      	push	A

00007866 <.LCFI14>:
    7866:	72da 1080 	lod	A, #4224
    786a:	07c8      	jmp	0x77fc <.L28>

0000786c <.L21>:
 * @returns  raw IO voltage sample.
 */
static INLINE uint16_t adc_Get_GMR_pCosine(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_GMR_IO3];
    786c:	72d8 12d6 	lod	A, 0x12d6 <_dBase+0x12>

00007870 <.LBE54>:
			//						temp = l_sAdcAvgObject[C_ADC_SENSOR_].u16MovAvg;
			break;
		case C_ADC_SENSOR_3:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_SENSOR_3], adc_Get_GMR_pCosine());
    7870:	52df      	push	A

00007872 <.LCFI16>:
    7872:	72da 108c 	lod	A, #4236
    7876:	07c2      	jmp	0x77fc <.L28>

00007878 <.L22>:
 * @returns  raw IO voltage sample.
 */
static INLINE uint16_t adc_Get_GMR_pSine(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_GMR_IO4];
    7878:	72d8 12d8 	lod	A, 0x12d8 <_dBase+0x14>

0000787c <.LBE56>:
			//						temp = l_sAdcAvgObject[C_ADC_SENSOR_].u16MovAvg;
			break;
		case C_ADC_SENSOR_4:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_SENSOR_4], adc_Get_GMR_pSine());
    787c:	52df      	push	A

0000787e <.LCFI18>:
    787e:	72da 1098 	lod	A, #4248
    7882:	07bc      	jmp	0x77fc <.L28>

00007884 <_get_conv_vdda_voltage>:
{
	return (l_sAdcAvgObject[num].u16MovAvg);
}
uint16_t get_conv_vdda_voltage(void)
{
	return adc_ConvertToVoltage(get_sensor_raw_data(C_ADC_VDDA));
    7884:	72d8 105c 	lod	A, 0x105c <.LLST23+0x1>
    7888:	0747      	jmp	0x7718 <_adc_ConvertToVoltage>

0000788a <_get_conv_supply_voltage>:
}
uint16_t get_conv_supply_voltage(void)
{
	return adc_ConvertToVsupply(get_sensor_raw_data(C_ADC_VS_));
    788a:	72d8 1038 	lod	A, 0x1038 <_l_sAdcAvgObject>
    788e:	073f      	jmp	0x770e <_adc_ConvertToVsupply>

00007890 <_get_conv_ic_temperature>:
int16_t get_conv_ic_temperature(void)
{
#if 0
	return adc_ConvertToTchip(get_sensor_raw_data(C_ADC_TEMP_));
#else
	int16_t temperature = adc_ConvertToTchip(get_sensor_raw_data(C_ADC_TEMP_));
    7890:	72d8 1044 	lod	A, 0x1044 <_l_sAdcAvgObject+0xc>
    7894:	173a      	call	0x770a <_adc_ConvertToTchip>

00007896 <.LM71>:
	if (temperature >= 0)
    7896:	ac00      	cmp	A, #0
    7898:	1a82      	jsl	0x789e <.L33>

0000789a <.L36>:
		{
			temperature = 0;
		}
		else
		{
			temperature = (C_TEMP_CONV_OFFSET + temperature);
    789a:	a028      	add	A, #40
    789c:	5401      	ret

0000789e <.L33>:
	{
		temperature += C_TEMP_CONV_OFFSET;
	}
	else
	{
		if (temperature < (-40))
    789e:	acd8      	cmp	A, #-40
    78a0:	1efc      	jsge	0x789a <.L36>

000078a2 <.LM74>:
		{
			temperature = 0;
    78a2:	7000      	lod	A, #0

000078a4 <.LM75>:
		}
	}

	return temperature;
#endif
}
    78a4:	5401      	ret

000078a6 <_get_conv_mot_current>:
uint16_t get_conv_mot_current(void)
{
	return adc_ConvertToCurrent(get_sensor_raw_data(C_ADC_CURRENT_));
    78a6:	72d8 1050 	lod	A, 0x1050 <.LLST35+0x9>
    78aa:	072e      	jmp	0x7708 <_adc_ConvertToCurrent>

000078ac <_get_gmr_sine_output>:
	int16_t cal, offset = C_GMR_OUTPUT_OFFSET;
	int16_t pSin, nSin;
	pSin = get_sensor_raw_data(C_ADC_SENSOR_4) - offset;
	nSin = get_sensor_raw_data(C_ADC_SENSOR_2) - offset;

	cal = pSin - nSin;
    78ac:	72d8 1098 	lod	A, 0x1098 <.LLST26>
    78b0:	aad8 1080 	sub	A, 0x1080 <.LLST24+0x12>

000078b4 <.LM81>:
if (cal<l16_SinNegMaxPeak)
{
l16_SinNegMaxPeak=cal;
}
#endif
	cal = cal - l16_SinOutputOffset;
    78b4:	aad8 12f6 	sub	A, 0x12f6 <_l16_SinOutputOffset>

000078b8 <.LVL44>:
    78b8:	0ea7      	lod	C, ML.7
    78ba:	aeda c001 	cmp	A, #49153
    78be:	1e82      	jsge	0x78c4 <.L39>
    78c0:	72da c001 	lod	A, #49153

000078c4 <.L39>:
		cal = C_GMR_NEGAITIVE_MAX;
	}
	else
	{
	}
	return (cal);
    78c4:	aeda 3fff 	cmp	A, #16383
    78c8:	1b02      	jsle	0x78ce <.L40>
    78ca:	72da 3fff 	lod	A, #16383

000078ce <.L40>:
}
    78ce:	5401      	ret

000078d0 <_get_gmr_cosine_output>:
	int16_t cal, offset = C_GMR_OUTPUT_OFFSET;
	int16_t pCosin, nCosin;
	pCosin = get_sensor_raw_data(C_ADC_SENSOR_3) - offset;
	nCosin = get_sensor_raw_data(C_ADC_SENSOR_1) - offset;

	cal = pCosin - nCosin;
    78d0:	72d8 108c 	lod	A, 0x108c <.Lframe0>
    78d4:	aad8 1074 	sub	A, 0x1074 <.LLST24+0x6>

000078d8 <.LM86>:
if (cal<l16_CosinNegMaxPeak)
{
l16_CosinNegMaxPeak=cal;
}
#endif
	cal = cal - l16_CosinOutputOffset;
    78d8:	aad8 12f8 	sub	A, 0x12f8 <_l16_CosinOutputOffset>

000078dc <.LVL49>:
    78dc:	0ea7      	lod	C, ML.7
    78de:	aeda c001 	cmp	A, #49153
    78e2:	1e82      	jsge	0x78e8 <.L42>
    78e4:	72da c001 	lod	A, #49153

000078e8 <.L42>:
		cal = C_GMR_NEGAITIVE_MAX;
	}
	else
	{
	}
	return (cal);
    78e8:	aeda 3fff 	cmp	A, #16383
    78ec:	1b02      	jsle	0x78f2 <.L43>
    78ee:	72da 3fff 	lod	A, #16383

000078f2 <.L43>:
}
    78f2:	5401      	ret

000078f4 <_calculate_gmr_angle>:
/* ELMOS
u16 loc_rotor_angle_estimated = math_get_angle_unsafe( loc_e_beta_filtered, loc_e_alpha_filtered );
*/

int16_t calculate_gmr_angle(void)
{
    78f4:	5801      	inc	S, #2

000078f6 <.LCFI19>:
	int16_t ang_result;

	ang_result = (int16_t)atan2I16(get_gmr_cosine_output(), get_gmr_sine_output());
    78f6:	17da      	call	0x78ac <_get_gmr_sine_output>
    78f8:	5201      	mov	[S-2], A
    78fa:	17ea      	call	0x78d0 <_get_gmr_cosine_output>
    78fc:	7a01      	lod	Y, [S-2]
    78fe:	5adf      	push	Y

00007900 <.LCFI20>:
    7900:	82db 50ed 	callf	0xa1da <_atan2I16>

00007904 <.LBB60>:
}
/* 0~0xFFFF -> 0~360*10*/
static uint16_t MLX_to_GMR_conv(uint16_t angle)
{
	uint16_t cal, offset;
	if (angle < 0x2000) /* 45*/
    7904:	5c01      	dec	S, #2

00007906 <.LCFI21>:
    7906:	aeda 1fff 	cmp	A, #8191
    790a:	1e01      	jug	0x790e <.LM92>
    790c:	0049      	jmp	0x79a0 <.L54>

0000790e <.LM92>:
	{
		offset = 0;
	}
	else if (angle < 0x4000) /* 90*/
    790e:	aeda 3fff 	cmp	A, #16383
    7912:	1e1a      	jug	0x7948 <.L46>

00007914 <.LM93>:
	{
		angle -= 0x2000;
    7914:	a2da e000 	add	A, #57344

00007918 <.LM94>:
		offset = 450;
    7918:	7eda 01c2 	lod	X, #450

0000791c <.L45>:
	else /* 360*/
	{
		angle -= 0xE000;
		offset = 3150;
	}
	angle = (angle >> 6); /* div 64 */
    791c:	44b2      	lsr	A, #2
    791e:	44b2      	lsr	A, #2
    7920:	44b2      	lsr	A, #2

00007922 <.LM96>:
	cal = (450 * angle) >> 7;
    7922:	4872 01c2 	muls	A, A, #450

00007926 <.LVL58>:
    7926:	4442      	rl	A
    7928:	9401      	and	AL, #1
    792a:	72e4      	swap	A

0000792c <.LM97>:
	cal += offset;
    792c:	a2ee      	add	A, X

0000792e <.LM98>:
	if (cal >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
    792e:	aeda 0e0f 	cmp	A, #3599
    7932:	1a02      	jule	0x7938 <.L52>

00007934 <.LM99>:
	{
		cal -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    7934:	a2da f1f0 	add	A, #61936

00007938 <.L52>:
	}

	cal += l16_SetGmrSensorOffset;
    7938:	a2d8 10bc 	add	A, 0x10bc <_l16_SetGmrSensorOffset>

0000793c <.LM101>:
	if (cal >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
    793c:	aeda 0e0f 	cmp	A, #3599
    7940:	1a02      	jule	0x7946 <.L53>

00007942 <.LM102>:
	{
		cal -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    7942:	a2da f1f0 	add	A, #61936

00007946 <.L53>:

	/* output angle(0~0xFFFF) -> 0~360 degree */
	ang_result = MLX_to_GMR_conv(ang_result);

	return ang_result;
}
    7946:	5403      	ret	#4

00007948 <.L46>:
	else if (angle < 0x4000) /* 90*/
	{
		angle -= 0x2000;
		offset = 450;
	}
	else if (angle < 0x6000) /* 135*/
    7948:	aeda 5fff 	cmp	A, #24575
    794c:	1e05      	jug	0x7958 <.L47>

0000794e <.LM105>:
	{
		angle -= 0x4000;
    794e:	a2da c000 	add	A, #49152

00007952 <.LM106>:
		offset = 900;
    7952:	7eda 0384 	lod	X, #900
    7956:	07e2      	jmp	0x791c <.L45>

00007958 <.L47>:
	}
	else if (angle < 0x8000) /* 180*/
    7958:	ac00      	cmp	A, #0
    795a:	1a85      	jsl	0x7966 <.L48>

0000795c <.LM108>:
	{
		angle -= 0x6000;
    795c:	a2da a000 	add	A, #40960

00007960 <.LM109>:
		offset = 1350;
    7960:	7eda 0546 	lod	X, #1350
    7964:	07db      	jmp	0x791c <.L45>

00007966 <.L48>:
	}
	else if (angle < 0xA000) /* 225*/
    7966:	aeda 9fff 	cmp	A, #40959
    796a:	1e05      	jug	0x7976 <.L49>

0000796c <.LM111>:
	{
		angle -= 0x8000;
    796c:	a2da 8000 	add	A, #32768

00007970 <.LM112>:
		offset = 1800;
    7970:	7eda 0708 	lod	X, #1800
    7974:	07d3      	jmp	0x791c <.L45>

00007976 <.L49>:
	}
	else if (angle < 0xC000) /* 270*/
    7976:	aeda bfff 	cmp	A, #49151
    797a:	1e05      	jug	0x7986 <.L50>

0000797c <.LM114>:
	{
		angle -= 0xA000;
    797c:	a2da 6000 	add	A, #24576

00007980 <.LM115>:
		offset = 2250;
    7980:	7eda 08ca 	lod	X, #2250
    7984:	07cb      	jmp	0x791c <.L45>

00007986 <.L50>:
	}
	else if (angle < 0xE000) /* 315*/
    7986:	aeda dfff 	cmp	A, #57343
    798a:	1e05      	jug	0x7996 <.L51>

0000798c <.LM117>:
	{
		angle -= 0xC000;
    798c:	a2da 4000 	add	A, #16384

00007990 <.LM118>:
		offset = 2700;
    7990:	7eda 0a8c 	lod	X, #2700
    7994:	07c3      	jmp	0x791c <.L45>

00007996 <.L51>:
	}
	else /* 360*/
	{
		angle -= 0xE000;
    7996:	a2da 2000 	add	A, #8192

0000799a <.LM120>:
		offset = 3150;
    799a:	7eda 0c4e 	lod	X, #3150
    799e:	07be      	jmp	0x791c <.L45>

000079a0 <.L54>:
static uint16_t MLX_to_GMR_conv(uint16_t angle)
{
	uint16_t cal, offset;
	if (angle < 0x2000) /* 45*/
	{
		offset = 0;
    79a0:	7c00      	lod	X, #0
    79a2:	07bc      	jmp	0x791c <.L45>

000079a4 <_forward_linear_Interpolation>:

	return ang_result;
}

int16_t forward_linear_Interpolation(int16_t x, int16_t x0, int16_t x1, int16_t y0, int16_t y1)
{
    79a4:	7ae2      	lod	Y, A

000079a6 <.LM123>:
    79a6:	7e07      	lod	X, [S-8]
    79a8:	7209      	lod	A, [S-10]

000079aa <.LM124>:
	int16_t tmp = 0;
	int16_t retVal = 0;

	tmp = (int16_t)(y1 - y0) * (int16_t)(x - x0);
    79aa:	aaee      	sub	A, X

000079ac <.LM125>:

	return ang_result;
}

int16_t forward_linear_Interpolation(int16_t x, int16_t x0, int16_t x1, int16_t y0, int16_t y1)
{
    79ac:	7e03      	lod	X, [S-4]

000079ae <.LM126>:
	int16_t tmp = 0;
	int16_t retVal = 0;

	tmp = (int16_t)(y1 - y0) * (int16_t)(x - x0);
    79ae:	eaee      	sub	Y, X

000079b0 <.LVL80>:
    79b0:	4871      	muls	A, A, Y

000079b2 <.LM127>:

	if ((x1 - x0) != 0)
    79b2:	2e05      	cmp	X, [S-6]
    79b4:	1906      	je	0x79c2 <.L56>

000079b6 <.LM128>:
	{
		tmp /= (int16_t)(x1 - x0);
    79b6:	7e05      	lod	X, [S-6]
    79b8:	2a03      	sub	X, [S-4]
    79ba:	4cf8      	movs	YA, A
    79bc:	4c73      	divs	YA, X
    79be:	4c73      	divs	YA, X
    79c0:	4c7b      	dadjs	YA, X

000079c2 <.L56>:
    79c2:	7e07      	lod	X, [S-8]

000079c4 <.LM129>:
	}

	tmp += (int16_t)y0;
    79c4:	a2ee      	add	A, X

000079c6 <.LM130>:

	retVal = tmp;

	return retVal;
}
    79c6:	5401      	ret

000079c8 <_get_conv_ignition_voltage>:
	{0x15B, 900u},	// 1
	{0x178, 1200u}, // 2
	{0x19B, 1800u}	// 3
};
uint16_t get_conv_ignition_voltage(void)
{
    79c8:	5803      	inc	S, #4

000079ca <.LBB64>:
	}
}

int16_t get_sensor_raw_data(uint16_t num)
{
	return (l_sAdcAvgObject[num].u16MovAvg);
    79ca:	7ad8 1068 	lod	Y, 0x1068 <.LLST23+0xd>

000079ce <.LBE64>:
uint16_t get_conv_ignition_voltage(void)
{
	uint16_t volt = get_sensor_raw_data(C_ADC_IGN);
	uint16_t cal_result = 0, index;

	if (volt < IGNconversionMap[0].actual)
    79ce:	eeda 0131 	cmp	Y, #305
    79d2:	1a27      	jule	0x7a22 <.L60>

000079d4 <.LM134>:
	{
		cal_result = 0;
	}
	else if (volt > IGNconversionMap[3].actual)
    79d4:	eeda 019b 	cmp	Y, #411
    79d8:	1e26      	jug	0x7a26 <.L61>

000079da <.LM135>:
	}
	else
	{
		for (index = 0U; index < (IGN_CONV_MAP_SIZE - 1U); index++)
		{
			if (volt <= IGNconversionMap[index + 1U].actual)
    79da:	eeda 015b 	cmp	Y, #347
    79de:	1a1f      	jule	0x7a1e <.L62>
    79e0:	eeda 0178 	cmp	Y, #376
    79e4:	5cb0      	sug	A
    79e6:	a001      	add	A, #1

000079e8 <.L64>:
	{
		cal_result = 1800u;
	}
	else
	{
		for (index = 0U; index < (IGN_CONV_MAP_SIZE - 1U); index++)
    79e8:	5203      	mov	[S-4], A

000079ea <.LM137>:
				break;
			}
		}
		cal_result = forward_linear_Interpolation(volt,
												  IGNconversionMap[index].actual, IGNconversionMap[index + 1U].actual,
												  IGNconversionMap[index].correction, IGNconversionMap[index + 1U].correction);
    79ea:	44a2      	asl	A, #2
    79ec:	4422      	asl	A
    79ee:	7ee2      	lod	X, A
    79f0:	22da 5d04 	add	X, #23812
    79f4:	5e01      	mov	[S-2], X

000079f6 <.LM138>:
			if (volt <= IGNconversionMap[index + 1U].actual)
			{
				break;
			}
		}
		cal_result = forward_linear_Interpolation(volt,
    79f6:	72fc      	lod	A, [X+4]
    79f8:	52df      	push	A

000079fa <.LCFI23>:
												  IGNconversionMap[index].actual, IGNconversionMap[index + 1U].actual,
												  IGNconversionMap[index].correction, IGNconversionMap[index + 1U].correction);
    79fa:	7205      	lod	A, [S-6]
    79fc:	44a2      	asl	A, #2
    79fe:	4422      	asl	A
    7a00:	a2da 5cfc 	add	A, #23804
    7a04:	5205      	mov	[S-6], A

00007a06 <.LM140>:
			if (volt <= IGNconversionMap[index + 1U].actual)
			{
				break;
			}
		}
		cal_result = forward_linear_Interpolation(volt,
    7a06:	7ee2      	lod	X, A
    7a08:	72fc      	lod	A, [X+4]
    7a0a:	52df      	push	A

00007a0c <.LCFI24>:
    7a0c:	7e05      	lod	X, [S-6]
    7a0e:	72f8      	lod	A, [X]
    7a10:	52df      	push	A

00007a12 <.LCFI25>:
    7a12:	7e09      	lod	X, [S-10]
    7a14:	72f8      	lod	A, [X]
    7a16:	52df      	push	A

00007a18 <.LCFI26>:
    7a18:	72e6      	lod	A, Y
    7a1a:	17c4      	call	0x79a4 <_forward_linear_Interpolation>

00007a1c <.LCFI27>:
    7a1c:	540d      	ret	#14

00007a1e <.L62>:
	{
		cal_result = 1800u;
	}
	else
	{
		for (index = 0U; index < (IGN_CONV_MAP_SIZE - 1U); index++)
    7a1e:	7000      	lod	A, #0
    7a20:	07e3      	jmp	0x79e8 <.L64>

00007a22 <.L60>:
	uint16_t volt = get_sensor_raw_data(C_ADC_IGN);
	uint16_t cal_result = 0, index;

	if (volt < IGNconversionMap[0].actual)
	{
		cal_result = 0;
    7a22:	7000      	lod	A, #0
    7a24:	5405      	ret	#6

00007a26 <.L61>:
	}
	else if (volt > IGNconversionMap[3].actual)
	{
		cal_result = 1800u;
    7a26:	72da 0708 	lod	A, #1800

00007a2a <.LM144>:
												  IGNconversionMap[index].actual, IGNconversionMap[index + 1U].actual,
												  IGNconversionMap[index].correction, IGNconversionMap[index + 1U].correction);
	}

	return (cal_result);
}
    7a2a:	5405      	ret	#6

00007a2c <_conv_clock_error_init>:
int16_t clock_error_SClockHighCal;  /**< CPU clock gain for high temperature range */
int16_t clock_error_OClockCal;  /**< CPU clock offset */

void conv_clock_error_init(void)
{
    clock_error_OTempCal = EE_GET(OTEMPCAL);
    7a2c:	72d8 09b4 	lod	A, 0x9b4 <.LASF1599+0x8>
    7a30:	52d8 12fa 	mov	0x12fa <_clock_error_OTempCal>, A

00007a34 <.LM3>:

    #if (FPLL == 32000) || (FPLL == 16000)
    clock_error_SClockLowCal = EE_GET(SCLOCK32LOWCAL);
    7a34:	72d8 09c4 	lod	A, 0x9c4 <.LASF1600+0xa>
    7a38:	66e0      	lod	YL, AL
    7a3a:	5ce6      	ssex	Y
    7a3c:	5ad8 12fe 	mov	0x12fe <_clock_error_SClockLowCal>, Y

00007a40 <.LM4>:
    clock_error_SClockHighCal = EE_GET(SCLOCK32HIGHCAL);
    7a40:	62e4      	lod	AL, AH
    7a42:	5ce2      	ssex	A
    7a44:	52d8 1300 	mov	0x1300 <_clock_error_SClockHighCal>, A

00007a48 <.LM5>:
    clock_error_OClockCal = EE_GET(OCLOCK32CAL);
    7a48:	62d8 09c6 	lod	AL, 0x9c6 <.LASF1600+0xc>
    7a4c:	5ce2      	ssex	A
    7a4e:	52d8 12fc 	mov	0x12fc <_clock_error_OClockCal>, A

00007a52 <.LM6>:
    #else
    clock_error_SClockLowCal = 0;
    clock_error_SClockHighCal = 0;
    clock_error_OClockCal = 0;
    #endif
}
    7a52:	5401      	ret

00007a54 <_conv_clock_error_speed>:
int16_t conv_clock_error_speed(uint16_t raw_temperature)
{
    int16_t temp;
    int16_t gain;

    temp = (int16_t)raw_temperature - clock_error_OTempCal;
    7a54:	aad8 12fa 	sub	A, 0x12fa <_clock_error_OTempCal>

00007a58 <.LM9>:

    if (temp > 0)
    7a58:	ac00      	cmp	A, #0
    7a5a:	1b0f      	jsle	0x7a7a <.L3>

00007a5c <.LM10>:
    {
        gain = clock_error_SClockLowCal;
    7a5c:	7ed8 12fe 	lod	X, 0x12fe <_clock_error_SClockLowCal>

00007a60 <.L4>:
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI32_I16byI16(int16_t multiplicand, int16_t multiplier)
{
    int32_t result;

    __asm__ __volatile__ (
    7a60:	4833      	muls	YA, A, X

00007a62 <.LBE6>:
    else
    {
        gain = clock_error_SClockHighCal;
    }

    return clock_error_OClockCal + (int16_t)(mulI32_I16byI16(temp, gain) / 64);
    7a62:	4cb2 0000 	cmp	YA, #0
    7a66:	0000 
    7a68:	1e84      	jsge	0x7a72 <.L5>
    7a6a:	4cc0      	mov	D, YA
    7a6c:	4c0a 003f 	addu	D, #63
    7a70:	4c80      	mov	YA, D

00007a72 <.L5>:
    7a72:	48b5      	asr	YA, #6
    7a74:	a2d8 12fc 	add	A, 0x12fc <_clock_error_OClockCal>

00007a78 <.LM13>:
}
    7a78:	5401      	ret

00007a7a <.L3>:
    {
        gain = clock_error_SClockLowCal;
    }
    else
    {
        gain = clock_error_SClockHighCal;
    7a7a:	7ed8 1300 	lod	X, 0x1300 <_clock_error_SClockHighCal>

00007a7e <.LVL5>:
    7a7e:	07f0      	jmp	0x7a60 <.L4>

00007a80 <_conv_clock_error_correct_period>:
    return clock_error_OClockCal + (int16_t)(mulI32_I16byI16(temp, gain) / 64);
}

uint16_t conv_clock_error_correct_period(uint16_t period, int16_t clock_error)
{
    int16_t temp = 2048 + clock_error;
    7a80:	7e03      	lod	X, [S-4]
    7a82:	22da 0800 	add	X, #2048

00007a86 <.LBB8>:
 */
MATHLIB_INLINE_STATIC __inline__ uint32_t mulU32_U16byU16(uint16_t multiplicand, uint16_t multiplier)
{
    uint32_t result;

    __asm__ __volatile__ (
    7a86:	4823      	mulu	YA, A, X

00007a88 <.LBE8>:
    return (uint16_t)(mulU32_U16byU16(period, (uint16_t)temp) / 2048u);
    7a88:	48aa      	lsr	YA, #11

00007a8a <.LM19>:
}
    7a8a:	5401      	ret

00007a8c <_conv_high_voltage_init>:
calib_data_t calib_hvi;

void conv_high_voltage_init(void)
{
#if defined(EE_O_HVI_GET)
    calib_hvi.simple.offset = EE_GET(O_HVI);
    7a8c:	72d8 09d4 	lod	A, 0x9d4 <.LASF2002+0xc>
    7a90:	62e4      	lod	AL, AH
    7a92:	5ce2      	ssex	A
    7a94:	52d8 1302 	mov	0x1302 <_calib_hvi>, A
    7a98:	72d8 09d8 	lod	A, 0x9d8 <.LASF2002+0x10>
    7a9c:	d400      	and	AH, #0

00007a9e <.LM3>:
    calib_hvi.simple.gain = EE_GET(GAIN_HVI);
    7a9e:	52d8 1304 	mov	0x1304 <_calib_hvi+0x2>, A

00007aa2 <.LM4>:
    calib_hvi.gain_low_t = EE_GET(GAINLO_VSMF);
    7aa2:	7ad8 09e2 	lod	Y, 0x9e2 <.Ldebug_abbrev0+0x2>
    7aa6:	46d8 1306 	mov	0x1306 <_calib_hvi+0x4>, YL

00007aaa <.LM5>:
    calib_hvi.gain_high_t = EE_GET(GAINHI_VSMF);
    7aaa:	0ea7      	lod	C, ML.7
    7aac:	4ed8 0713 	mov	0x1307 <_calib_hvi+0x5>, YH

00007ab0 <.LM6>:
    calib_hvi.simple.gain = EE_GET(VS_GAIN);
    calib_hvi.gain_low_t = 0;
    calib_hvi.gain_high_t = 0;
#endif

    if (calib_hvi.simple.gain == 0u)
    7ab0:	ac00      	cmp	A, #0
    7ab2:	1d04      	jne	0x7abc <.L1>

00007ab4 <.LM7>:
    {
        /* gain 0 is not allowed, use the default value */
        calib_hvi.simple.gain = 164u;               /* 2.5V * 21 * 100 * HVI_GAIN_DIV / 1023 */
    7ab4:	72da 00a4 	lod	A, #164
    7ab8:	52d8 1304 	mov	0x1304 <_calib_hvi+0x2>, A

00007abc <.L1>:
    }
}
    7abc:	5401      	ret

00007abe <_conv_high_voltage>:
 * @return  updated measurement.
 */
STATIC INLINE int16_t apply_offset_gain(uint16_t u16ADC_Value, simple_calib_data_t * cal_data, uint8_t divider)
{
    int16_t measurement = (int16_t)u16ADC_Value;
    measurement -= cal_data->offset;
    7abe:	aad8 1302 	sub	A, 0x1302 <_calib_hvi>

00007ac2 <.LBB24>:
 *  @ingroup     math_multiplication_group
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI24_I16byU8(int16_t multiplicand, uint8_t multiplier)
{
    int32_t result;
    int16_t b_16 = (int16_t) multiplier; /* cast to Word */
    7ac2:	7ed8 1304 	lod	X, 0x1304 <_calib_hvi+0x2>
    7ac6:	36da 00ff 	and	X, #255

00007aca <.LM12>:

    __asm__ __volatile__ (
    7aca:	4833      	muls	YA, A, X

00007acc <.LBE24>:
    measurement = (int16_t)(mulI24_I16byU8(measurement, cal_data->gain) / divider);
    7acc:	4cb2 0000 	cmp	YA, #0
    7ad0:	0000 
    7ad2:	1e84      	jsge	0x7adc <.L4>
    7ad4:	4cc0      	mov	D, YA
    7ad6:	4c0a 001f 	addu	D, #31
    7ada:	4c80      	mov	YA, D

00007adc <.L4>:
    7adc:	48b4      	asr	YA, #5

00007ade <.LBE22>:

int16_t conv_high_voltage(uint16_t u16ADC_Value)
{
    /* cHVI = (mHVI - O_HVI_EE) * Gain_HVI_EE / 2^5 */
    return apply_offset_gain(u16ADC_Value, &calib_hvi.simple, HVI_GAIN_DIV);
}
    7ade:	5401      	ret

00007ae0 <_conv_high_voltage_with_tcorrection>:

int16_t conv_high_voltage_with_tcorrection(uint16_t u16ADC_Value, uint16_t u16ADC_Temp)
{
    7ae0:	5805      	inc	S, #6

00007ae2 <.LCFI0>:
     * }else{
     *     tempGain = ((GainHi_VSMF_EE / 2^11) * mTempDiff)/2^7;
     * }
     * cHVIcorr = cHVI * (1 + tempGain)
     */
    return apply_temp_gain(conv_high_voltage(u16ADC_Value), u16ADC_Temp, &calib_hvi);
    7ae2:	17ed      	call	0x7abe <_conv_high_voltage>

00007ae4 <.LVL5>:
    7ae4:	5205      	mov	[S-6], A

00007ae6 <.LBB26>:
 * @return  updated measurement.
 */
STATIC INLINE int16_t apply_temp_gain(uint16_t u16ADC_Value, uint16_t u16ADC_Temp, calib_data_t * cal_data)
{
    int16_t gain;
    int16_t temp_diff = (int16_t)(u16ADC_Temp - EE_GET(OTEMPCAL));
    7ae6:	7e09      	lod	X, [S-10]
    7ae8:	2ad8 09b4 	sub	X, 0x9b4 <.LASF1599+0x8>

00007aec <.LM18>:

    if (temp_diff > 0)
    7aec:	2c00      	cmp	X, #0
    7aee:	1b1b      	jsle	0x7b26 <.L6>

00007af0 <.LBB28>:
 *  @ingroup     math_multiplication_group
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI24_I16byI8(int16_t multiplicand, int8_t multiplier)
{
    int32_t result;
    int16_t b_16 = (int16_t) multiplier; /* cast to Word */
    7af0:	66d8 1306 	lod	YL, 0x1306 <_calib_hvi+0x4>

00007af4 <.L12>:
    7af4:	5ce6      	ssex	Y

00007af6 <.LM20>:

    __asm__ __volatile__ (
    7af6:	72ee      	lod	A, X

00007af8 <.LVL10>:
    7af8:	4811      	muls	D, A, Y
    7afa:	5880      	mov	[S-4], D

00007afc <.LBE30>:
    {
        gain = (int16_t)(mulI24_I16byI8(temp_diff, cal_data->gain_low_t) / 128);
    }
    else
    {
        gain = (int16_t)(mulI24_I16byI8(temp_diff, cal_data->gain_high_t) / 128);
    7afc:	4caa 0000 	cmpu	D, #0
    7b00:	1e83      	jsge	0x7b08 <.L9>

00007b02 <.LVL11>:
    7b02:	4c0a 007f 	addu	D, #127
    7b06:	5880      	mov	[S-4], D

00007b08 <.L9>:
    7b08:	58e0      	mov	YA, [S-4]

00007b0a <.LVL12>:
    7b0a:	48b6      	asr	YA, #7

00007b0c <.LBB33>:
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI32_I16byI16(int16_t multiplicand, int16_t multiplier)
{
    int32_t result;

    __asm__ __volatile__ (
    7b0c:	7e05      	lod	X, [S-6]

00007b0e <.LVL14>:
    7b0e:	4833      	muls	YA, A, X

00007b10 <.LBE33>:
    }

    return (u16ADC_Value + (mulI32_I16byI16(gain, u16ADC_Value) / 2048));
    7b10:	4cb2 0000 	cmp	YA, #0
    7b14:	0000 
    7b16:	1e84      	jsge	0x7b20 <.L10>
    7b18:	4cc0      	mov	D, YA
    7b1a:	4c0a 07ff 	addu	D, #2047
    7b1e:	4c80      	mov	YA, D

00007b20 <.L10>:
    7b20:	48ba      	asr	YA, #11
    7b22:	a205      	add	A, [S-6]

00007b24 <.LBE26>:
}
    7b24:	5407      	ret	#8

00007b26 <.L6>:
 *  @ingroup     math_multiplication_group
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI24_I16byI8(int16_t multiplicand, int8_t multiplier)
{
    int32_t result;
    int16_t b_16 = (int16_t) multiplier; /* cast to Word */
    7b26:	66d8 1307 	lod	YL, 0x1307 <_calib_hvi+0x5>
    7b2a:	07e4      	jmp	0x7af4 <.L12>

00007b2c <_conv_low_voltage_init>:
calib_data_t calib_lvi;

void conv_low_voltage_init(void)
{
#if defined(EE_O_LVI_GET)
    calib_lvi.simple.offset = EE_GET(O_LVI);
    7b2c:	72d8 09d6 	lod	A, 0x9d6 <.LASF2002+0xe>
    7b30:	7ee2      	lod	X, A
    7b32:	54e4      	mov	Cx, #4
    7b34:	44fe      	asr	X, #2
    7b36:	1ffe      	djnz	Cx, 0x7b34 <_conv_low_voltage_init+0x8>
    7b38:	5ed8 1308 	mov	0x1308 <_calib_lvi>, X
    7b3c:	d400      	and	AH, #0

00007b3e <.LM3>:
    calib_lvi.simple.gain = EE_GET(GAIN_LVI);
    7b3e:	52d8 130a 	mov	0x130a <_calib_lvi+0x2>, A

00007b42 <.LM4>:
    calib_lvi.gain_low_t = EE_GET(GAINLO_LVI);
    7b42:	7ad8 09da 	lod	Y, 0x9da <.LASF2132+0x1>
    7b46:	46d8 130c 	mov	0x130c <_calib_lvi+0x4>, YL

00007b4a <.LM5>:
    calib_lvi.gain_high_t = EE_GET(GAINHI_LVI);
    7b4a:	0ea7      	lod	C, ML.7
    7b4c:	4ed8 0d13 	mov	0x130d <.LLST12>, YH

00007b50 <.LM6>:
    calib_lvi.simple.gain = 213u;                   /* 2.5V * 1.36 * 1000 * LVI_GAIN_DIV / 1023 */
    calib_lvi.gain_low_t = 0;
    calib_lvi.gain_high_t = 0;
#endif

    if (calib_lvi.simple.gain == 0u)
    7b50:	ac00      	cmp	A, #0
    7b52:	1d04      	jne	0x7b5c <.L1>

00007b54 <.LM7>:
    {
        /* gain 0 is not allowed, use the default value */
        calib_lvi.simple.gain = 213u;               /* 2.5V * 1.36 * 1000 * LVI_GAIN_DIV / 1023 */
    7b54:	72da 00d5 	lod	A, #213
    7b58:	52d8 130a 	mov	0x130a <_calib_lvi+0x2>, A

00007b5c <.L1>:
    }
}
    7b5c:	5401      	ret

00007b5e <_conv_motor_voltage_init>:
calib_data_t calib_vsm;
/** VSM filtered calibration data */
calib_data_t calib_vsmf;

void conv_motor_voltage_init(void)
{
    7b5e:	5805      	inc	S, #6

00007b60 <.LCFI0>:
#if defined(EE_O_HVI_GET)
    calib_vsm.simple.offset = EE_GET(O_HVI);
    7b60:	72d8 09d4 	lod	A, 0x9d4 <.LASF2002+0xc>
    7b64:	7ae2      	lod	Y, A
    7b66:	66ec      	lod	YL, YH
    7b68:	5ce6      	ssex	Y
    7b6a:	5a03      	mov	[S-4], Y
    7b6c:	5ad8 1314 	mov	0x1314 <_calib_vsm>, Y
    7b70:	d400      	and	AH, #0

00007b72 <.LM3>:
    calib_vsm.simple.gain = EE_GET(GAIN_VSMF);
    7b72:	52d8 1316 	mov	0x1316 <_calib_vsm+0x2>, A

00007b76 <.LM4>:
    calib_vsm.gain_low_t = EE_GET(GAINLO_VSMF);
    7b76:	66d8 09e2 	lod	YL, 0x9e2 <.Ldebug_abbrev0+0x2>
    7b7a:	5ce6      	ssex	Y
    7b7c:	5a05      	mov	[S-6], Y
    7b7e:	46d8 1318 	mov	0x1318 <_calib_vsm+0x4>, YL

00007b82 <.LM5>:
    calib_vsm.gain_high_t = EE_GET(GAINHI_VSMF);
    7b82:	7ad8 09e2 	lod	Y, 0x9e2 <.Ldebug_abbrev0+0x2>
    7b86:	66ec      	lod	YL, YH
    7b88:	5ce6      	ssex	Y
    7b8a:	5a01      	mov	[S-2], Y
    7b8c:	46d8 1319 	mov	0x1319 <_calib_vsm+0x5>, YL

00007b90 <.LM6>:
    calib_vsm.simple.gain = EE_GET(VSM_GAIN);
    calib_vsm.gain_low_t = 0;
    calib_vsm.gain_high_t = 0;
#endif

    if (calib_vsm.simple.gain == 0u)
    7b90:	ac00      	cmp	A, #0
    7b92:	1d04      	jne	0x7b9c <.L2>

00007b94 <.LM7>:
    {
        /* gain 0 is not allowed, use the default value */
        calib_vsm.simple.gain = 164u;               /* 2.5V * 21 * 100 * HVI_GAIN_DIV / 1023 */
    7b94:	7eda 00a4 	lod	X, #164
    7b98:	5ed8 1316 	mov	0x1316 <_calib_vsm+0x2>, X

00007b9c <.L2>:
    }

#if defined(EE_O_HVI_GET)
    calib_vsmf.simple.offset = EE_GET(O_HVI) + EE_GET(O_VSMF);
    7b9c:	7ed8 09d8 	lod	X, 0x9d8 <.LASF2002+0x10>
    7ba0:	54e4      	mov	Cx, #4
    7ba2:	44fe      	asr	X, #2
    7ba4:	1ffe      	djnz	Cx, 0x7ba2 <.L2+0x6>
    7ba6:	2203      	add	X, [S-4]
    7ba8:	5ed8 130e 	mov	0x130e <_calib_vsmf>, X

00007bac <.LM9>:
    calib_vsmf.simple.gain = EE_GET(GAIN_VSMF);
    7bac:	52d8 1310 	mov	0x1310 <_calib_vsmf+0x2>, A

00007bb0 <.LM10>:
    calib_vsmf.gain_low_t = EE_GET(GAINLO_VSMF);
    7bb0:	6605      	lod	YL, [S-6]
    7bb2:	46d8 1312 	mov	0x1312 <_calib_vsmf+0x4>, YL

00007bb6 <.LM11>:
    calib_vsmf.gain_high_t = EE_GET(GAINHI_VSMF);
    7bb6:	6601      	lod	YL, [S-2]
    7bb8:	46d8 1313 	mov	0x1313 <_calib_vsmf+0x5>, YL

00007bbc <.LM12>:
    calib_vsmf.simple.gain = EE_GET(VSM_FILT_GAIN);
    calib_vsmf.gain_low_t = 0;
    calib_vsmf.gain_high_t = 0;
#endif

    if (calib_vsmf.simple.gain == 0u)
    7bbc:	ac00      	cmp	A, #0
    7bbe:	1d04      	jne	0x7bc8 <.L1>

00007bc0 <.LM13>:
    {
        /* gain 0 is not allowed, use the default value */
        calib_vsmf.simple.gain = 164u;              /* 2.5V * 21 * 100 * HVI_GAIN_DIV / 1023 */
    7bc0:	72da 00a4 	lod	A, #164
    7bc4:	52d8 1310 	mov	0x1310 <_calib_vsmf+0x2>, A

00007bc8 <.L1>:
    }
}
    7bc8:	5407      	ret	#8

00007bca <_conv_shunt_current_init>:
calib_data_t calib_current;

void conv_shunt_current_init(void)
{
#if defined(EE_O_CURR_GET)
    calib_current.simple.offset = EE_GET(O_CURR) + 512;
    7bca:	72d8 09dc 	lod	A, 0x9dc <.LASF2132+0x3>
    7bce:	7ee2      	lod	X, A
    7bd0:	54e4      	mov	Cx, #4
    7bd2:	44fe      	asr	X, #2
    7bd4:	1ffe      	djnz	Cx, 0x7bd2 <_conv_shunt_current_init+0x8>
    7bd6:	22da 0200 	add	X, #512
    7bda:	5ed8 131a 	mov	0x131a <_calib_current>, X

00007bde <.LM3>:
    calib_current.simple.gain = EE_GET(GAIN_CURR);
    7bde:	d400      	and	AH, #0
    7be0:	52d8 131c 	mov	0x131c <_calib_current+0x2>, A

00007be4 <.LM4>:
    calib_current.gain_low_t = EE_GET(GAINLO_CURR);
    7be4:	72d8 09e0 	lod	A, 0x9e0 <.Ldebug_abbrev0>
    7be8:	42d8 131e 	mov	0x131e <_calib_current+0x4>, AL

00007bec <.LM5>:
    calib_current.gain_high_t = EE_GET(GAINHI_CURR);
    7bec:	0ea7      	lod	C, ML.7
    7bee:	4ad8 1f13 	mov	0x131f <.LASF1850>, AH

00007bf2 <.LM6>:
    calib_current.simple.offset = EE_GET(CURR_OFFS) + 512;
    calib_current.simple.gain = EE_GET(CURR_GAIN);
    calib_current.gain_low_t = 0;
    calib_current.gain_high_t = 0;
#endif
}
    7bf2:	5401      	ret

00007bf4 <_conv_shunt_current>:
 * @return  updated measurement.
 */
STATIC INLINE int16_t apply_offset_gain(uint16_t u16ADC_Value, simple_calib_data_t * cal_data, uint8_t divider)
{
    int16_t measurement = (int16_t)u16ADC_Value;
    measurement -= cal_data->offset;
    7bf4:	aad8 131a 	sub	A, 0x131a <_calib_current>

00007bf8 <.LBB16>:
 *  @ingroup     math_multiplication_group
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI24_I16byU8(int16_t multiplicand, uint8_t multiplier)
{
    int32_t result;
    int16_t b_16 = (int16_t) multiplier; /* cast to Word */
    7bf8:	7ed8 131c 	lod	X, 0x131c <_calib_current+0x2>
    7bfc:	36da 00ff 	and	X, #255

00007c00 <.LM10>:

    __asm__ __volatile__ (
    7c00:	4833      	muls	YA, A, X

00007c02 <.LBE16>:
    measurement = (int16_t)(mulI24_I16byU8(measurement, cal_data->gain) / divider);
    7c02:	4cb2 0000 	cmp	YA, #0
    7c06:	0000 
    7c08:	1e84      	jsge	0x7c12 <.L4>
    7c0a:	4cc0      	mov	D, YA
    7c0c:	4c0a 001f 	addu	D, #31
    7c10:	4c80      	mov	YA, D

00007c12 <.L4>:
    7c12:	48b4      	asr	YA, #5

00007c14 <.LBE14>:
{
    /* MLX81330: cCur = (mCur - (O_Curr_EE + 512)) * Gain_Curr_EE / 2^6
     * MLX81332: cCur = (mCur - (O_Curr_EE + 512)) * Gain_Curr_EE / 2^5
     */
    return apply_offset_gain(u16ADC_Value, &calib_current.simple, CURR_GAIN_DIV);
}
    7c14:	5401      	ret

00007c16 <_Mot_dirChange_check>:
int16_t SensorGetDelta(void)
{
	return sensor.delta;
}
static uint16_t Mot_dirChange_check(void)
{
    7c16:	72d8 1290 	lod	A, 0x1290 <.LASF1024+0x2>

00007c1a <.LM2>:
	uint16_t flag = 0;
#if C_MOT_POLE_POLAR == 0
	if (motor.direction == C_DIR_CW)
#else
	if (motor.direction == C_DIR_CCW)
    7c1a:	7ed8 1282 	lod	X, 0x1282 <.LASF1845+0x6>
    7c1e:	2c02      	cmp	X, #2
    7c20:	1d03      	jne	0x7c28 <.L2>

00007c22 <.LBB28>:
#endif
	{
		if (motor.pos.Delta < 0)
    7c22:	4442      	rl	A
    7c24:	b401      	and	A, #1
    7c26:	5401      	ret

00007c28 <.L2>:
			flag = 1;
    7c28:	ac00      	cmp	A, #0
    7c2a:	5cb2      	ssg	A

00007c2c <.LBE28>:
	{
		if (motor.pos.Delta > 0)
			flag = 1;
	}
	return (flag);
}
    7c2c:	5401      	ret

00007c2e <_MotRequestHardStop>:

uint16_t test[350] = {0,}, i=0;

void MotRequestHardStop(void)
{
	motor.requestStop = 1;
    7c2e:	7001      	lod	A, #1
    7c30:	52d8 127e 	mov	0x127e <.LASF1845+0x2>, A

00007c34 <.LM8>:
}
    7c34:	5401      	ret

00007c36 <_MotClearHardStop>:
void MotClearHardStop(void)
{
	motor.requestStop = 0;
    7c36:	7000      	lod	A, #0
    7c38:	52d8 127e 	mov	0x127e <.LASF1845+0x2>, A

00007c3c <.LM11>:
}
    7c3c:	5401      	ret

00007c3e <_MotSetTargetPosition>:
	if (targetPos > (360 * C_GMR_ANGLE_SCALE_FACTOR))
	{
		targetPos -= (360 * C_GMR_ANGLE_SCALE_FACTOR);
	}
#endif
	motor.pos.target = targetPos;
    7c3e:	52d8 128c 	mov	0x128c <.Lframe0+0x4>, A

00007c42 <.LM14>:
	if (motor.pos.target >= motor.pos.current)
    7c42:	7ed8 128a 	lod	X, 0x128a <.Lframe0+0x2>
    7c46:	2ee2      	cmp	X, A
    7c48:	1f0f      	jsg	0x7c68 <.L7>

00007c4a <.LM15>:
	{
		diff = motor.pos.target - motor.pos.current;
    7c4a:	7ae2      	lod	Y, A
    7c4c:	eaee      	sub	Y, X
    7c4e:	7ee6      	lod	X, Y

00007c50 <.L8>:
	}
	else
	{
		diff = motor.pos.current - motor.pos.target;
	}
	if ((motor.pos.target != motor.pos.lastTarget) || (diff > (int16_t)C_MOT_ON_HYSTERISYS))
    7c50:	7ad8 128e 	lod	Y, 0x128e <.LASF1024>
    7c54:	eee2      	cmp	Y, A
    7c56:	1d02      	jne	0x7c5c <.L9>

00007c58 <.LM17>:
    7c58:	2c0a      	cmp	X, #10
    7c5a:	1b05      	jsle	0x7c66 <.L6>

00007c5c <.L9>:
	{
		motor.pos.newTarget = 1;
    7c5c:	6401      	lod	YL, #1
    7c5e:	46d8 1292 	mov	0x1292 <.LASF1024+0x4>, YL

00007c62 <.LM19>:
		motor.pos.lastTarget = motor.pos.target;
    7c62:	52d8 128e 	mov	0x128e <.LASF1024>, A

00007c66 <.L6>:
	}
}
    7c66:	5401      	ret

00007c68 <.L7>:
	{
		diff = motor.pos.target - motor.pos.current;
	}
	else
	{
		diff = motor.pos.current - motor.pos.target;
    7c68:	2ae2      	sub	X, A

00007c6a <.LVL5>:
    7c6a:	07f2      	jmp	0x7c50 <.L8>

00007c6c <_MotGetCurrentPosition>:
	return motor.pos.target;
}
int16_t MotGetCurrentPosition(void)
{
	return motor.pos.current;
}
    7c6c:	72d8 128a 	lod	A, 0x128a <.Lframe0+0x2>
    7c70:	5401      	ret

00007c72 <_MotClearStallFlag>:
}
/*
type 0 : all clear
*/
void MotClearStallFlag(uint16_t type)
{
    7c72:	7ae2      	lod	Y, A

00007c74 <.LM41>:
	if (type == 0)
    7c74:	1d03      	jne	0x7c7c <.L18>

00007c76 <.LM42>:
	{
		motor.stall.flag = 0;
    7c76:	42d8 12ac 	mov	0x12ac <.LASF1639+0x1>, AL
    7c7a:	5401      	ret

00007c7c <.L18>:
    7c7c:	62d8 12ac 	lod	AL, 0x12ac <.LASF1639+0x1>

00007c80 <.LM43>:
	}
	else if (type == 1)
    7c80:	ec01      	cmp	Y, #1
    7c82:	1d04      	jne	0x7c8c <.L20>

00007c84 <.LM44>:
	{
		motor.stall.flag &= (~STALL_MASK_TEMPORARY);
    7c84:	94fe      	and	AL, #-2

00007c86 <.L21>:
	}
	else
	{
		motor.stall.flag &= (~STALL_MASK_PERMENT);
    7c86:	42d8 12ac 	mov	0x12ac <.LASF1639+0x1>, AL

00007c8a <.LM46>:
	}
}
    7c8a:	5401      	ret

00007c8c <.L20>:
	{
		motor.stall.flag &= (~STALL_MASK_TEMPORARY);
	}
	else
	{
		motor.stall.flag &= (~STALL_MASK_PERMENT);
    7c8c:	94fd      	and	AL, #-3
    7c8e:	07fb      	jmp	0x7c86 <.L21>

00007c90 <_MotClearFaultFlag>:
/*
type 0 : all clear
*/
void MotClearFaultFlag(uint16_t type)
{
	if (type == 0)
    7c90:	ac00      	cmp	A, #0
    7c92:	1d07      	jne	0x7ca2 <.L23>

00007c94 <.LM50>:
	{
		motor.fault.flag = 0;
    7c94:	42d8 12b8 	mov	0x12b8 <.LLST9+0x9>, AL

00007c98 <.LM51>:
		g_e8OverCurrent = 0;
    7c98:	42d8 11b5 	mov	0x11b5 <_g_e8OverCurrent>, AL

00007c9c <.LM52>:
		g_e8ShortOcc = 0;
    7c9c:	52d8 11b6 	mov	0x11b6 <_g_e8ShortOcc>, A
    7ca0:	5401      	ret

00007ca2 <.L23>:
	}
	else if (type == 1)
    7ca2:	ac01      	cmp	A, #1
    7ca4:	1d06      	jne	0x7cb2 <.L25>

00007ca6 <.LM54>:
	{
		motor.fault.flag &= (~FAULT_MASK_PHASE_A_OPEN);
    7ca6:	62d8 12b8 	lod	AL, 0x12b8 <.LLST9+0x9>

00007caa <.LVL14>:
    7caa:	94fe      	and	AL, #-2

00007cac <.L27>:
		motor.fault.flag &= (~FAULT_MASK_PHASE_A_SHORT);
	}
	else if (type == 3)
	{
		g_e8OverCurrent = 0;
		motor.fault.flag &= (~FAULT_MASK_OVER_CURRENT);
    7cac:	42d8 12b8 	mov	0x12b8 <.LLST9+0x9>, AL

00007cb0 <.L22>:
	}
	else
	{
	}
}
    7cb0:	5401      	ret

00007cb2 <.L25>:
	}
	else if (type == 1)
	{
		motor.fault.flag &= (~FAULT_MASK_PHASE_A_OPEN);
	}
	else if (type == 2)
    7cb2:	ac02      	cmp	A, #2
    7cb4:	1d07      	jne	0x7cc4 <.L26>

00007cb6 <.LM58>:
	{
		g_e8ShortOcc = 0;
    7cb6:	7000      	lod	A, #0

00007cb8 <.LVL16>:
    7cb8:	52d8 11b6 	mov	0x11b6 <_g_e8ShortOcc>, A

00007cbc <.LM59>:
		motor.fault.flag &= (~FAULT_MASK_PHASE_A_SHORT);
    7cbc:	62d8 12b8 	lod	AL, 0x12b8 <.LLST9+0x9>
    7cc0:	94ef      	and	AL, #-17
    7cc2:	07f4      	jmp	0x7cac <.L27>

00007cc4 <.L26>:
	}
	else if (type == 3)
    7cc4:	ac03      	cmp	A, #3
    7cc6:	1d74      	jne	0x7cb0 <.L22>

00007cc8 <.LM61>:
	{
		g_e8OverCurrent = 0;
    7cc8:	6000      	lod	AL, #0

00007cca <.LVL18>:
    7cca:	42d8 11b5 	mov	0x11b5 <_g_e8OverCurrent>, AL

00007cce <.LM62>:
		motor.fault.flag &= (~FAULT_MASK_OVER_CURRENT);
    7cce:	62d8 12b8 	lod	AL, 0x12b8 <.LLST9+0x9>
    7cd2:	94bf      	and	AL, #-65
    7cd4:	07eb      	jmp	0x7cac <.L27>

00007cd6 <_MotGetState>:
	}
}
tMotState MotGetState(void)
{
	return motor.state;
}
    7cd6:	72d8 1276 	lod	A, 0x1276 <_motor>
    7cda:	5401      	ret

00007cdc <_MotGetStallState>:
uint8_t MotGetStallState(void)
{
	return motor.stall.flag;
    7cdc:	62d8 12ac 	lod	AL, 0x12ac <.LASF1639+0x1>
    7ce0:	5cf2      	usex	A

00007ce2 <.LM67>:
}
    7ce2:	5401      	ret

00007ce4 <_MotGetFaultState>:

uint8_t MotGetFaultState(void)
{
	return motor.fault.flag;
    7ce4:	62d8 12b8 	lod	AL, 0x12b8 <.LLST9+0x9>
    7ce8:	5cf2      	usex	A

00007cea <.LM70>:
}
    7cea:	5401      	ret

00007cec <_SensorGetState>:
uint8_t SensorGetState(void)
{
	return sensor.moving;
    7cec:	72d8 126a 	lod	A, 0x126a <_sensor>
    7cf0:	5cf2      	usex	A

00007cf2 <.LM73>:
}
    7cf2:	5401      	ret

00007cf4 <_app_mot_init>:
}

void app_mot_init(void)
{

	motor.state = MOTION_STOPPED;
    7cf4:	7801      	lod	Y, #1
    7cf6:	5ad8 1276 	mov	0x1276 <_motor>, Y

00007cfa <.LM87>:
	motor.lastState = MOTION_STOPPED;
    7cfa:	5ad8 1278 	mov	0x1278 <_motor+0x2>, Y

00007cfe <.LM88>:
	motor.initStatus = 1;
    7cfe:	0ea7      	lod	C, ML.7
    7d00:	5ad8 127a 	mov	0x127a <_motor+0x4>, Y

00007d04 <.LM89>:
	motor.elapsedTime = 0;
    7d04:	7000      	lod	A, #0
    7d06:	52d8 127c 	mov	0x127c <.LASF1845>, A

00007d0a <.LM90>:
	motor.direction = C_DIR_NONE;
    7d0a:	0ea7      	lod	C, ML.7
    7d0c:	52d8 1282 	mov	0x1282 <.LASF1845+0x6>, A

00007d10 <.LM91>:
	motor.lastDirection = C_DIR_NONE;
    7d10:	52d8 1284 	mov	0x1284 <.LASF1845+0x8>, A

00007d14 <.LM92>:
	motor.runTimeOut = (5 * 1000);
    7d14:	7eda 1388 	lod	X, #5000
    7d18:	0ea7      	lod	C, ML.7
    7d1a:	5ed8 1286 	mov	0x1286 <.LLST8+0x1>, X

00007d1e <.LM93>:
	motor.pos.target = 0;
    7d1e:	52d8 128c 	mov	0x128c <.Lframe0+0x4>, A

00007d22 <.LM94>:
	motor.pos.lastTarget = 0;
    7d22:	52d8 128e 	mov	0x128e <.LASF1024>, A

00007d26 <.LM95>:
	motor.pos.current = 0;
    7d26:	0ea7      	lod	C, ML.7
    7d28:	52d8 128a 	mov	0x128a <.Lframe0+0x2>, A

00007d2c <.LM96>:
	motor.pos.newTarget = 0;
    7d2c:	52d8 1292 	mov	0x1292 <.LASF1024+0x4>, A

00007d30 <.LM97>:
	motor.pos.posReached = 0;
    7d30:	5ad8 1294 	mov	0x1294 <.LASF1024+0x6>, Y

00007d34 <.LM98>:
	motor.out.enable = 0;
	motor.out.duty = 0;
	motor.out.maxDuty = C_MOT_MAXDUTY_SET;
	motor.out.minDuty = C_MOT_MINDUTY_SET;
	motor.softStart.enable = 1u;
    7d34:	0ea7      	lod	C, ML.7
    7d36:	7eda 0733 	lod	X, #1843
    7d3a:	5ed8 1296 	mov	0x1296 <.LASF1024+0x8>, X

00007d3e <.LM99>:
	motor.softStart.outThreshold = (C_MOT_MAXDUTY_SET * 0.9f);
    7d3e:	7c66      	lod	X, #102
    7d40:	0ea7      	lod	C, ML.7
    7d42:	5ed8 1298 	mov	0x1298 <.LASF1024+0xa>, X

00007d46 <.LM100>:
//	motor.softStart.accDuty=(C_MOT_MAXDUTY_SET * 0.0027f);/*300ms=6*/
//	motor.softStart.accDuty=(C_MOT_MAXDUTY_SET * 0.002f);/*400ms=4*/
//	motor.softStart.accDuty=(C_MOT_MAXDUTY_SET * 0.0016f);/*500ms=3*/
//	motor.softStart.accDuty=(C_MOT_MAXDUTY_SET * 0.0015f);/*533ms*/
#else
	motor.softStart.accDuty = (C_MOT_MAXDUTY_SET * 0.05f);
    7d46:	5ad8 129a 	mov	0x129a <.LASF1024+0xc>, Y

00007d4a <.LM101>:
#endif
	motor.softStop.enable = 1u;
	motor.softStop.completed = 0;
    7d4a:	7c28      	lod	X, #40
    7d4c:	0ea7      	lod	C, ML.7
    7d4e:	5ed8 129c 	mov	0x129c <.LASF1024+0xe>, X

00007d52 <.LM102>:
	motor.softStop.inThreshold = (4 * C_GMR_ANGLE_SCALE_FACTOR);
    7d52:	7c14      	lod	X, #20
    7d54:	5ed8 129e 	mov	0x129e <.LASF1024+0x10>, X

00007d58 <.LM103>:
	motor.softStop.dccDuty = (C_MOT_MAXDUTY_SET * 0.01f);
    7d58:	0ea7      	lod	C, ML.7
    7d5a:	52d8 12a0 	mov	0x12a0 <.LASF2051+0x1>, A

00007d5e <.LM104>:
	motor.pos.target = 0;
	motor.pos.lastTarget = 0;
	motor.pos.current = 0;
	motor.pos.newTarget = 0;
	motor.pos.posReached = 0;
	motor.out.enable = 0;
    7d5e:	52d8 12a2 	mov	0x12a2 <.LASF2051+0x3>, A

00007d62 <.LM105>:
	motor.out.duty = 0;
    7d62:	7eda 0800 	lod	X, #2048
    7d66:	0ea7      	lod	C, ML.7
    7d68:	5ed8 12a4 	mov	0x12a4 <.LASF2051+0x5>, X

00007d6c <.LM106>:
	motor.out.maxDuty = C_MOT_MAXDUTY_SET;
    7d6c:	7eda 0200 	lod	X, #512
    7d70:	5ed8 12a6 	mov	0x12a6 <.LASF2063+0x1>, X

00007d74 <.LM107>:
	motor.softStop.enable = 1u;
	motor.softStop.completed = 0;
	motor.softStop.inThreshold = (4 * C_GMR_ANGLE_SCALE_FACTOR);
	motor.softStop.dccDuty = (C_MOT_MAXDUTY_SET * 0.01f);

	motor.stall.flag = 0;
    7d74:	0ea7      	lod	C, ML.7
    7d76:	7eda 0100 	lod	X, #256
    7d7a:	5ed8 12ac 	mov	0x12ac <.LASF1639+0x1>, X

00007d7e <.LM108>:
	motor.stall.enable = 1;
    7d7e:	52d8 12ae 	mov	0x12ae <.LASF1639+0x3>, A

00007d82 <.LM109>:
	motor.stall.maskTimer = 0;
	motor.stall.threshold = 800; /* 1000mA -> 800mA */
    7d82:	0ea7      	lod	C, ML.7
    7d84:	7eda 0320 	lod	X, #800
    7d88:	5ed8 12b4 	mov	0x12b4 <.LLST9+0x5>, X

00007d8c <.LM110>:

	motor.fault.flag = 0;
    7d8c:	7eda 0100 	lod	X, #256
    7d90:	0ea7      	lod	C, ML.7
    7d92:	5ed8 12b8 	mov	0x12b8 <.LLST9+0x9>, X

00007d96 <.LM111>:
	motor.fault.openEnable = 1;
	motor.fault.ocEnable = 1;
    7d96:	46d8 12ba 	mov	0x12ba <.LLST9+0xb>, YL

00007d9a <.LM112>:
	motor.fault.ocDetectCnt = 0;
    7d9a:	52d8 12be 	mov	0x12be <.LLST9+0xf>, A

00007d9e <.LM113>:
	motor.fault.openDetectCheck = 0;
    7d9e:	0ea7      	lod	C, ML.7
    7da0:	42d8 12c0 	mov	0x12c0 <.LLST9+0x11>, AL

00007da4 <.LM114>:
	motor.fault.openDetectCnt = 0;
    7da4:	52d8 12c2 	mov	0x12c2 <.LLST10>, A

00007da8 <.LM115>:

	sensor.delay = 0;
    7da8:	42d8 126c 	mov	0x126c <_sensor+0x2>, AL

00007dac <.LM116>:
	sensor.delta = 0;
    7dac:	0ea7      	lod	C, ML.7
    7dae:	52d8 1270 	mov	0x1270 <_sensor+0x6>, A

00007db2 <.LM117>:
	sensor.moving = C_STATUS_OFF_;
    7db2:	52d8 126a 	mov	0x126a <_sensor>, A

00007db6 <.LM118>:
	sensor.lastDeg = 0;
    7db6:	52d8 1274 	mov	0x1274 <.LLST7+0x2>, A

00007dba <.LM119>:
}
    7dba:	5401      	ret

00007dbc <_app_motor_task>:

/* called by every 1ms */
void app_motor_task(void)
{
    7dbc:	5803      	inc	S, #4

00007dbe <.LCFI0>:
	tMotState next_state = motor.state;
	uint16_t voltage = get_valve_voltage();
    7dbe:	82db 3361 	callf	0x66c2 <_get_valve_voltage>

00007dc2 <.LVL24>:
    7dc2:	5203      	mov	[S-4], A

00007dc4 <.LM122>:

	/*** state machine control ***/
	switch (motor.state)
    7dc4:	7eda 1276 	lod	X, #4726
    7dc8:	72f8      	lod	A, [X]

00007dca <.LVL26>:
    7dca:	ac07      	cmp	A, #7
    7dcc:	1e0d      	jug	0x7de8 <.L92>
    7dce:	4422      	asl	A
    7dd0:	7ae2      	lod	Y, A
    7dd2:	e2da 5d1c 	add	Y, #23836
    7dd6:	7ed8 127a 	lod	X, 0x127a <_motor+0x4>
    7dda:	76f0      	jmp	[Y]

00007ddc <.L40>:
}

static tMotState motor_state_INIT(void)
{
	tMotState next_state = MOTION_INIT;
	if (motor.initStatus)
    7ddc:	2c00      	cmp	X, #0
    7dde:	1d01      	jne	0x7de2 <.LM124>
    7de0:	0151      	jmp	0x8084 <.L49>

00007de2 <.LM124>:
	{
		motor.initStatus = 0;
    7de2:	7000      	lod	A, #0
    7de4:	52d8 127a 	mov	0x127a <_motor+0x4>, A

00007de8 <.L92>:
	{
		next_state = motor_state_FAULT();
		break;
	}
	default:
		next_state = MOTION_STOPPED;
    7de8:	7001      	lod	A, #1
    7dea:	0024      	jmp	0x7e34 <.L39>

00007dec <.L42>:
    7dec:	7000      	lod	A, #0

00007dee <.LBB47>:

static tMotState motor_state_STOPPED(void)
{
	tMotState next_state = MOTION_STOPPED;
	uint16_t rState = 0;
	if (motor.initStatus)
    7dee:	2c00      	cmp	X, #0
    7df0:	1902      	je	0x7df6 <.L50>

00007df2 <.LM127>:
	{
		motor.initStatus = 0;
    7df2:	52d8 127a 	mov	0x127a <_motor+0x4>, A

00007df6 <.L50>:
	}

	motor.out.enable = 0;
    7df6:	52d8 12a0 	mov	0x12a0 <.LASF2051+0x1>, A

00007dfa <.LM129>:
	motor.out.duty = 0;
    7dfa:	52d8 12a2 	mov	0x12a2 <.LASF2051+0x3>, A

00007dfe <.LM130>:
	motor.pos.posReached = 0;
    7dfe:	42d8 1293 	mov	0x1293 <.LASF1024+0x5>, AL

00007e02 <.LM131>:
	if (motor.requestStop != 0)
    7e02:	0ea7      	lod	C, ML.7
    7e04:	7ad8 127e 	lod	Y, 0x127e <.LASF1845+0x2>
    7e08:	1901      	je	0x7e0c <.LM132>
    7e0a:	00e5      	jmp	0x7fd6 <.L51>

00007e0c <.LM132>:
	{
	}
	else if (motor.pos.newTarget)
    7e0c:	62d8 1292 	lod	AL, 0x1292 <.LASF1024+0x4>
    7e10:	1d01      	jne	0x7e14 <.LM133>
    7e12:	00e1      	jmp	0x7fd6 <.L51>

00007e14 <.LM133>:
	{
		motor.pos.newTarget = 0;
    7e14:	46d8 1292 	mov	0x1292 <.LASF1024+0x4>, YL

00007e18 <.LM134>:
#if C_MOT_POLE_POLAR == 0
		if (motor.pos.Delta > 0)
#else
		if (motor.pos.Delta < 0)
    7e18:	72d8 1290 	lod	A, 0x1290 <.LASF1024+0x2>
    7e1c:	1981      	jn	0x7e20 <.LM135>
    7e1e:	0072      	jmp	0x7f04 <.L52>

00007e20 <.LM135>:
#endif
		{
			motor.direction = C_DIR_CW;
    7e20:	7001      	lod	A, #1

00007e22 <.L135>:
		}
		else
		{
			motor.direction = C_DIR_CCW;
    7e22:	52d8 1282 	mov	0x1282 <.LASF1845+0x6>, A

00007e26 <.LM137>:
	{
	}

	if (rState != 0)
	{
		pwm_Start(motor.direction, 0u);
    7e26:	5cf2      	usex	A
    7e28:	54ca 0000 	pushw	#0

00007e2c <.LCFI1>:
    7e2c:	82db 4d4d 	callf	0x9a9a <_pwm_Start>
    7e30:	5c01      	dec	S, #2

00007e32 <.L60>:
motor.softStart.outThreshold = 90%
ACC duration = (90-10)/5/1ms = 16ms
*/
static tMotState motor_state_ACC(void) /*20250714*/
{
	tMotState next_state = MOTION_ACC;
    7e32:	7002      	lod	A, #2

00007e34 <.L39>:
	}
	default:
		next_state = MOTION_STOPPED;
		break;
	}
	if (next_state != motor.state)
    7e34:	7ed8 1276 	lod	X, 0x1276 <_motor>
    7e38:	2ee2      	cmp	X, A
    7e3a:	1d01      	jne	0x7e3e <.L91>
    7e3c:	00cc      	jmp	0x7fd6 <.L51>

00007e3e <.L91>:
	{
		motor.lastState = motor.state;
    7e3e:	5ed8 1278 	mov	0x1278 <_motor+0x2>, X

00007e42 <.LM141>:
		motor.state = next_state;
    7e42:	52d8 1276 	mov	0x1276 <_motor>, A

00007e46 <.LM142>:
		motor.initStatus = 1u;
    7e46:	7001      	lod	A, #1

00007e48 <.LVL36>:
    7e48:	0ea7      	lod	C, ML.7
    7e4a:	52d8 127a 	mov	0x127a <_motor+0x4>, A

00007e4e <.LM143>:
		motor.elapsedTime = 0;
    7e4e:	7000      	lod	A, #0

00007e50 <.L136>:
	}
	else
	{
		if (motor.elapsedTime < 0xFFFFu)
			motor.elapsedTime += 1u;
    7e50:	52d8 127c 	mov	0x127c <.LASF1845>, A

00007e54 <.L73>:
	}
	if (motor.out.enable != 0)
    7e54:	72d8 12a0 	lod	A, 0x12a0 <.LASF2051+0x1>
    7e58:	1d01      	jne	0x7e5c <.LM146>
    7e5a:	0199      	jmp	0x818e <.L74>

00007e5c <.LM146>:
	{
		if (sensor.delay > 0)
    7e5c:	62d8 126c 	lod	AL, 0x126c <_sensor+0x2>
    7e60:	1903      	je	0x7e68 <.L75>

00007e62 <.LM147>:
		{
			sensor.delay -= 1;
    7e62:	80ff      	add	AL, #-1
    7e64:	42d8 126c 	mov	0x126c <_sensor+0x2>, AL

00007e68 <.L75>:
		}
		if (sensor.delay == 0)
    7e68:	62d8 126c 	lod	AL, 0x126c <_sensor+0x2>
    7e6c:	1d05      	jne	0x7e78 <.L76>

00007e6e <.LM149>:
		{
			sensor.filterPeriod += 1;
    7e6e:	62d8 126d 	lod	AL, 0x126d <_sensor+0x3>
    7e72:	8001      	add	AL, #1
    7e74:	42d8 126d 	mov	0x126d <_sensor+0x3>, AL

00007e78 <.L76>:
		}

		if (voltage <= 950)
    7e78:	7203      	lod	A, [S-4]
    7e7a:	aeda 03b6 	cmp	A, #950
    7e7e:	1a01      	jule	0x7e82 <.LM151>
    7e80:	0126      	jmp	0x80ce <.L77>

00007e82 <.LM151>:
		{
			sensor.thd = 10;
    7e82:	700a      	lod	A, #10
    7e84:	52d8 1272 	mov	0x1272 <.LLST7>, A

00007e88 <.LM152>:
			motor.stall.halfThd = 550;
    7e88:	72da 0226 	lod	A, #550
    7e8c:	0ea7      	lod	C, ML.7
    7e8e:	52d8 12b2 	mov	0x12b2 <.LLST9+0x3>, A

00007e92 <.LM153>:
			motor.stall.threshold = 650;
    7e92:	72da 028a 	lod	A, #650
    7e96:	52d8 12b4 	mov	0x12b4 <.LLST9+0x5>, A

00007e9a <.LM154>:
			motor.out.minDuty = (C_MOT_MAXDUTY_SET * 0.35);
    7e9a:	0ea7      	lod	C, ML.7
    7e9c:	72da 02cc 	lod	A, #716

00007ea0 <.L137>:
		else if (voltage <= 1050)
		{
			sensor.thd = 11;
			motor.stall.halfThd = 600;
			motor.stall.threshold = 700;
			motor.out.minDuty = (C_MOT_MAXDUTY_SET * 0.32);
    7ea0:	52d8 12a6 	mov	0x12a6 <.LASF2063+0x1>, A

00007ea4 <.L78>:
		sensor.delta = 0;
		sensor.moving = C_STATUS_OFF_;
		sensor.lastDeg = motor.pos.current;
	}

	if (sensor.filterPeriod >= 20) /*20msec*/
    7ea4:	62d8 126d 	lod	AL, 0x126d <_sensor+0x3>
    7ea8:	8c13      	cmp	AL, #19
    7eaa:	1f01      	jsg	0x7eae <.LM157>
    7eac:	0196      	jmp	0x81da <.L38>

00007eae <.LM157>:
	{

		sensor.filterPeriod = 0;
    7eae:	6000      	lod	AL, #0
    7eb0:	42d8 126d 	mov	0x126d <_sensor+0x3>, AL

00007eb4 <.LM158>:
		if (motor.pos.current > sensor.lastDeg)
    7eb4:	7ed8 128a 	lod	X, 0x128a <.Lframe0+0x2>
    7eb8:	0ea7      	lod	C, ML.7
    7eba:	72d8 1274 	lod	A, 0x1274 <.LLST7+0x2>
    7ebe:	2ee2      	cmp	X, A
    7ec0:	1f01      	jsg	0x7ec4 <.LM159>
    7ec2:	0176      	jmp	0x81b0 <.L85>

00007ec4 <.LM159>:
		{
			sensor.delta = motor.pos.current - sensor.lastDeg;
    7ec4:	7aee      	lod	Y, X
    7ec6:	eae2      	sub	Y, A
    7ec8:	72e6      	lod	A, Y

00007eca <.L138>:
		}
		else
		{
			sensor.delta = sensor.lastDeg - motor.pos.current;
    7eca:	52d8 1270 	mov	0x1270 <_sensor+0x6>, A

00007ece <.LM161>:
		}

		sensor.lastDeg = motor.pos.current;
    7ece:	5ed8 1274 	mov	0x1274 <.LLST7+0x2>, X
    7ed2:	62d8 126e 	lod	AL, 0x126e <_sensor+0x4>
    7ed6:	5ce2      	ssex	A

00007ed8 <.LM162>:

		if (sensor.delta >= sensor.thd)
    7ed8:	7ed8 1270 	lod	X, 0x1270 <_sensor+0x6>
    7edc:	2ed8 1272 	cmp	X, 0x1272 <.LLST7>
    7ee0:	1e81      	jsge	0x7ee4 <.LM163>
    7ee2:	0168      	jmp	0x81b4 <.L87>

00007ee4 <.LM163>:
		{
			if (sensor.filterCnt < 3)
    7ee4:	ac02      	cmp	A, #2
    7ee6:	1f03      	jsg	0x7eee <.L88>

00007ee8 <.LM164>:
				sensor.filterCnt++;
    7ee8:	8001      	add	AL, #1

00007eea <.L139>:
		}
		else
		{
			if (sensor.filterCnt > -3)
				sensor.filterCnt--;
    7eea:	42d8 126e 	mov	0x126e <_sensor+0x4>, AL

00007eee <.L88>:
		}
		if (sensor.filterCnt >= 2)
    7eee:	7eda 126a 	lod	X, #4714
    7ef2:	62d8 126e 	lod	AL, 0x126e <_sensor+0x4>
    7ef6:	5ce2      	ssex	A
    7ef8:	ac01      	cmp	A, #1
    7efa:	1f01      	jsg	0x7efe <.LM167>
    7efc:	0160      	jmp	0x81be <.L89>

00007efe <.LM167>:
		{
			sensor.moving = C_STATUS_RUN;
    7efe:	7001      	lod	A, #1

00007f00 <.L140>:
		}
		else if (sensor.filterCnt <= -2)
		{

			sensor.moving = C_STATUS_STOP;
    7f00:	52f8      	mov	[X], A

00007f02 <.LM169>:
		}
		else
		{
		}
	}
}
    7f02:	5405      	ret	#6

00007f04 <.L52>:
		{
			motor.direction = C_DIR_CW;
		}
		else
		{
			motor.direction = C_DIR_CCW;
    7f04:	7002      	lod	A, #2
    7f06:	078d      	jmp	0x7e22 <.L135>

00007f08 <.L43>:
*/
static tMotState motor_state_ACC(void) /*20250714*/
{
	tMotState next_state = MOTION_ACC;
	uint16_t u16diff;
	if (motor.initStatus)
    7f08:	2c00      	cmp	X, #0
    7f0a:	190b      	je	0x7f22 <.L54>

00007f0c <.LM172>:
	{
		motor.initStatus = 0;
    7f0c:	7000      	lod	A, #0
    7f0e:	52d8 127a 	mov	0x127a <_motor+0x4>, A

00007f12 <.LM173>:
		motor.out.enable = 1;
    7f12:	7001      	lod	A, #1
    7f14:	0ea7      	lod	C, ML.7
    7f16:	52d8 12a0 	mov	0x12a0 <.LASF2051+0x1>, A

00007f1a <.LM174>:
		motor.out.duty = C_MOT_STARTDUTY_SET;
    7f1a:	72da 00cc 	lod	A, #204
    7f1e:	52d8 12a2 	mov	0x12a2 <.LASF2051+0x3>, A

00007f22 <.L54>:
	}

	if ((motor.requestStop != 0) || (motor.pos.posReached != 0))
    7f22:	72d8 127e 	lod	A, 0x127e <.LASF1845+0x2>
    7f26:	1901      	je	0x7f2a <.LASF1585+0x3>
    7f28:	00ad      	jmp	0x8084 <.L49>
    7f2a:	62d8 1293 	lod	AL, 0x1293 <.LASF1024+0x5>
    7f2e:	1901      	je	0x7f32 <.LM176>
    7f30:	00a9      	jmp	0x8084 <.L49>

00007f32 <.LM176>:
	{
		next_state = MOTION_STOPPED;
	}
	else
	{
		if (motor.pos.Delta >= 0)
    7f32:	72d8 1290 	lod	A, 0x1290 <.LASF1024+0x2>

00007f36 <.LM177>:
		{
			u16diff = motor.pos.Delta;
    7f36:	1d81      	jnn	0x7f3a <.L141>
    7f38:	5cc2      	neg	A

00007f3a <.L141>:
    7f3a:	7ed8 129c 	lod	X, 0x129c <.LASF1024+0xe>

00007f3e <.LM178>:
		}
		else
		{
			u16diff = -motor.pos.Delta;
		}
		if (motor.softStart.enable)
    7f3e:	7ad8 1294 	lod	Y, 0x1294 <.LASF1024+0x6>
    7f42:	1918      	je	0x7f74 <.L57>
    7f44:	7ad8 1298 	lod	Y, 0x1298 <.LASF1024+0xa>
    7f48:	e2d8 12a2 	add	Y, 0x12a2 <.LASF2051+0x3>

00007f4c <.LM179>:
		{
			if (u16diff <= motor.softStop.inThreshold)
			{
				motor.out.duty += motor.softStart.accDuty;
    7f4c:	5ad8 12a2 	mov	0x12a2 <.LASF2051+0x3>, Y

00007f50 <.LM180>:
		{
			u16diff = -motor.pos.Delta;
		}
		if (motor.softStart.enable)
		{
			if (u16diff <= motor.softStop.inThreshold)
    7f50:	aeee      	cmp	A, X
    7f52:	1e09      	jug	0x7f66 <.L58>

00007f54 <.LM181>:
			{
				motor.out.duty += motor.softStart.accDuty;
				if (motor.out.duty >= motor.out.minDuty)
    7f54:	72d8 12a6 	lod	A, 0x12a6 <.LASF2063+0x1>

00007f58 <.LVL41>:
    7f58:	aee6      	cmp	A, Y
    7f5a:	1a01      	jule	0x7f5e <.L59>
    7f5c:	076a      	jmp	0x7e32 <.L60>

00007f5e <.L59>:
	}
	default:
		next_state = MOTION_STOPPED;
		break;
	}
	if (next_state != motor.state)
    7f5e:	7ed8 1276 	lod	X, 0x1276 <_motor>

00007f62 <.LM183>:
			if (u16diff <= motor.softStop.inThreshold)
			{
				motor.out.duty += motor.softStart.accDuty;
				if (motor.out.duty >= motor.out.minDuty)
				{
					next_state = MOTION_DEC;
    7f62:	7004      	lod	A, #4
    7f64:	076c      	jmp	0x7e3e <.L91>

00007f66 <.L58>:
				}
			}
			else
			{
				motor.out.duty += motor.softStart.accDuty;
				if (motor.out.duty >= motor.softStart.outThreshold)
    7f66:	72d8 1296 	lod	A, 0x1296 <.LASF1024+0x8>

00007f6a <.LVL44>:
    7f6a:	aee6      	cmp	A, Y
    7f6c:	1a01      	jule	0x7f70 <.LM185>
    7f6e:	0761      	jmp	0x7e32 <.L60>

00007f70 <.LM185>:
				{
					next_state = MOTION_RUNNING;
    7f70:	7003      	lod	A, #3
    7f72:	0760      	jmp	0x7e34 <.L39>

00007f74 <.L57>:
			}
		}
		else
		{

			if (u16diff <= motor.softStop.inThreshold)
    7f74:	aeee      	cmp	A, X
    7f76:	1a01      	jule	0x7f7a <.LM187>
    7f78:	0126      	jmp	0x81c6 <.L61>

00007f7a <.LM187>:
			{
				motor.out.duty += motor.softStart.accDuty;
    7f7a:	72d8 12a2 	lod	A, 0x12a2 <.LASF2051+0x3>

00007f7e <.LVL46>:
    7f7e:	a2d8 1298 	add	A, 0x1298 <.LASF1024+0xa>
    7f82:	52d8 12a2 	mov	0x12a2 <.LASF2051+0x3>, A

00007f86 <.LM188>:
				if (motor.out.duty >= motor.softStart.outThreshold)
    7f86:	0ea7      	lod	C, ML.7
    7f88:	aed8 1296 	cmp	A, 0x1296 <.LASF1024+0x8>
    7f8c:	1c68      	jnc	0x7f5e <.L59>
    7f8e:	0751      	jmp	0x7e32 <.L60>

00007f90 <.L44>:
}
static tMotState motor_state_RUNNING(void)
{
	tMotState next_state = MOTION_RUNNING;
	uint16_t u16diff;
	if (motor.initStatus)
    7f90:	2c00      	cmp	X, #0
    7f92:	1907      	je	0x7fa2 <.L62>

00007f94 <.LM190>:
	{
		motor.initStatus = 0;
    7f94:	7000      	lod	A, #0
    7f96:	52d8 127a 	mov	0x127a <_motor+0x4>, A

00007f9a <.LM191>:
		motor.out.enable = 1;
    7f9a:	7001      	lod	A, #1
    7f9c:	0ea7      	lod	C, ML.7
    7f9e:	52d8 12a0 	mov	0x12a0 <.LASF2051+0x1>, A

00007fa2 <.L62>:
	}
#if DUTY_ADJUST_ENABLE == 0
	motor.out.duty = C_MOT_MAXDUTY_SET;
    7fa2:	72da 0800 	lod	A, #2048
    7fa6:	52d8 12a2 	mov	0x12a2 <.LASF2051+0x3>, A

00007faa <.LM193>:
#else
	motor.out.duty = motor.out.maxDuty;
#endif
	if ((motor.requestStop != 0) || (motor.pos.posReached != 0))
    7faa:	72d8 127e 	lod	A, 0x127e <.LASF1845+0x2>
    7fae:	1901      	je	0x7fb2 <.LASF1138+0x2>
    7fb0:	0069      	jmp	0x8084 <.L49>
    7fb2:	62d8 1293 	lod	AL, 0x1293 <.LASF1024+0x5>
    7fb6:	1901      	je	0x7fba <.LM194>
    7fb8:	0065      	jmp	0x8084 <.L49>

00007fba <.LM194>:
	{

		next_state = MOTION_STOPPED;
	}
	else if (Mot_dirChange_check() != 0)
    7fba:	162d      	call	0x7c16 <_Mot_dirChange_check>
    7fbc:	ac00      	cmp	A, #0
    7fbe:	1901      	je	0x7fc2 <.LM195>
    7fc0:	0107      	jmp	0x81d0 <.L63>

00007fc2 <.LM195>:
	}
#endif
	else
	{

		if (motor.softStop.enable)
    7fc2:	62d8 129a 	lod	AL, 0x129a <.LASF1024+0xc>
    7fc6:	1907      	je	0x7fd6 <.L51>

00007fc8 <.LM196>:
			}
			else
			{
				u16diff = -motor.pos.Delta;
			}
			if (u16diff <= motor.softStop.inThreshold)
    7fc8:	72d8 1290 	lod	A, 0x1290 <.LASF1024+0x2>
    7fcc:	1d81      	jnn	0x7fd0 <.L142>
    7fce:	5cc2      	neg	A

00007fd0 <.L142>:
    7fd0:	aed8 129c 	cmp	A, 0x129c <.LASF1024+0xe>
    7fd4:	1a44      	jule	0x7f5e <.L59>

00007fd6 <.L51>:
		motor.initStatus = 1u;
		motor.elapsedTime = 0;
	}
	else
	{
		if (motor.elapsedTime < 0xFFFFu)
    7fd6:	72d8 127c 	lod	A, 0x127c <.LASF1845>
    7fda:	acff      	cmp	A, #-1
    7fdc:	1d01      	jne	0x7fe0 <.LM198>
    7fde:	073a      	jmp	0x7e54 <.L73>

00007fe0 <.LM198>:
			motor.elapsedTime += 1u;
    7fe0:	a001      	add	A, #1
    7fe2:	0736      	jmp	0x7e50 <.L136>

00007fe4 <.L45>:
}
static tMotState motor_state_DCC(void)
{
	tMotState next_state = MOTION_DEC;
	uint16_t u16diff = 0;
	if (motor.initStatus)
    7fe4:	2c00      	cmp	X, #0
    7fe6:	1909      	je	0x7ffa <.L66>

00007fe8 <.LM200>:
	{
		motor.initStatus = 0;
    7fe8:	7000      	lod	A, #0
    7fea:	52d8 127a 	mov	0x127a <_motor+0x4>, A

00007fee <.LM201>:
		motor.out.enable = 1;
    7fee:	7c01      	lod	X, #1
    7ff0:	0ea7      	lod	C, ML.7
    7ff2:	5ed8 12a0 	mov	0x12a0 <.LASF2051+0x1>, X

00007ff6 <.LM202>:
		motor.softStop.completed = 0;
    7ff6:	42d8 129b 	mov	0x129b <.LASF1024+0xd>, AL

00007ffa <.L66>:
	}

	if ((motor.requestStop != 0) || (motor.pos.posReached != 0))
    7ffa:	72d8 127e 	lod	A, 0x127e <.LASF1845+0x2>
    7ffe:	1901      	je	0x8002 <.L66+0x8>
    8000:	0041      	jmp	0x8084 <.L49>
    8002:	62d8 1293 	lod	AL, 0x1293 <.LASF1024+0x5>
    8006:	1901      	je	0x800a <.LM204>
    8008:	003d      	jmp	0x8084 <.L49>

0000800a <.LM204>:
	{

		next_state = MOTION_STOPPED;
	}
	else if (Mot_dirChange_check() != 0)
    800a:	1605      	call	0x7c16 <_Mot_dirChange_check>
    800c:	7ae2      	lod	Y, A
    800e:	1901      	je	0x8012 <.LM205>
    8010:	00df      	jmp	0x81d0 <.L63>

00008012 <.LM205>:
	{
		next_state = MOTION_PAUSE;
	}
	else
	{
		if (motor.softStop.completed == 0)
    8012:	62d8 129b 	lod	AL, 0x129b <.LASF1024+0xd>
    8016:	1d16      	jne	0x8044 <.L67>

00008018 <.LM206>:
			{
				motor.out.duty = motor.out.minDuty;

			}
#else
			if (motor.pos.Delta >= 0)
    8018:	7ad8 1290 	lod	Y, 0x1290 <.LASF1024+0x2>

0000801c <.LM207>:
			{
				u16diff = motor.pos.Delta;
    801c:	1d81      	jnn	0x8020 <.L143>
    801e:	5cc6      	neg	Y

00008020 <.L143>:
			}
			else
			{
				u16diff = -motor.pos.Delta;
			}
			motor.out.duty -= ((u16diff >> 1) + motor.softStop.dccDuty);
    8020:	72d8 12a2 	lod	A, 0x12a2 <.LASF2051+0x3>
    8024:	aad8 129e 	sub	A, 0x129e <.LASF1024+0x10>
    8028:	5201      	mov	[S-2], A
    802a:	72e6      	lod	A, Y
    802c:	4432      	lsr	A
    802e:	7ee2      	lod	X, A
    8030:	7201      	lod	A, [S-2]
    8032:	aaee      	sub	A, X
    8034:	52d8 12a2 	mov	0x12a2 <.LASF2051+0x3>, A

00008038 <.LM209>:
			if (motor.out.duty < motor.out.minDuty)
    8038:	7ed8 12a6 	lod	X, 0x12a6 <.LASF2063+0x1>
    803c:	aeee      	cmp	A, X
    803e:	1c02      	jnc	0x8044 <.L67>

00008040 <.LM210>:
			{
				motor.out.duty = motor.out.minDuty;
    8040:	5ed8 12a2 	mov	0x12a2 <.LASF2051+0x3>, X

00008044 <.L67>:
			}
#endif
		}
		if (sensor.moving == C_STATUS_STOP)
    8044:	72d8 126a 	lod	A, 0x126a <_sensor>
    8048:	ac02      	cmp	A, #2
    804a:	1d0c      	jne	0x8064 <.L94>

0000804c <.LM212>:
		{

			motor.softStop.completed = 1;
    804c:	6001      	lod	AL, #1
    804e:	42d8 129b 	mov	0x129b <.LASF1024+0xd>, AL

00008052 <.LM213>:
			motor.out.duty += ((u16diff >> 1) + motor.softStop.dccDuty);
    8052:	72d8 12a2 	lod	A, 0x12a2 <.LASF2051+0x3>
    8056:	0ea7      	lod	C, ML.7
    8058:	a2d8 129e 	add	A, 0x129e <.LASF1024+0x10>
    805c:	4436      	lsr	Y

0000805e <.LVL56>:
    805e:	e2e2      	add	Y, A
    8060:	5ad8 12a2 	mov	0x12a2 <.LASF2051+0x3>, Y

00008064 <.L94>:

	return next_state;
}
static tMotState motor_state_DCC(void)
{
	tMotState next_state = MOTION_DEC;
    8064:	7004      	lod	A, #4
    8066:	06e6      	jmp	0x7e34 <.L39>

00008068 <.L46>:
    8068:	7000      	lod	A, #0

0000806a <.LBB63>:
}
static tMotState motor_state_PAUSE(void)
{
	tMotState next_state = MOTION_PAUSE;

	if (motor.initStatus)
    806a:	2c00      	cmp	X, #0
    806c:	1904      	je	0x8076 <.L70>

0000806e <.LM216>:
	{
		motor.initStatus = 0;
    806e:	52d8 127a 	mov	0x127a <_motor+0x4>, A

00008072 <.LM217>:
		motor.out.enable = 0;
    8072:	52d8 12a0 	mov	0x12a0 <.LASF2051+0x1>, A

00008076 <.L70>:
	}
	motor.out.duty = 0;
    8076:	52d8 12a2 	mov	0x12a2 <.LASF2051+0x3>, A

0000807a <.LM219>:
	if (motor.elapsedTime > 100u)
    807a:	72d8 127c 	lod	A, 0x127c <.LASF1845>
    807e:	ac64      	cmp	A, #100
    8080:	1e01      	jug	0x8084 <.L49>
    8082:	07a9      	jmp	0x7fd6 <.L51>

00008084 <.L49>:
	}
	default:
		next_state = MOTION_STOPPED;
		break;
	}
	if (next_state != motor.state)
    8084:	7ada 1276 	lod	Y, #4726
    8088:	7ef0      	lod	X, [Y]

0000808a <.LM221>:
		motor.out.enable = 0;
	}
	motor.out.duty = 0;
	if (motor.elapsedTime > 100u)
	{
		next_state = MOTION_STOPPED;
    808a:	7001      	lod	A, #1
    808c:	06d8      	jmp	0x7e3e <.L91>

0000808e <.L47>:
    808e:	7000      	lod	A, #0

00008090 <.LBB67>:

static tMotState motor_state_STALLED(void)
{
	tMotState next_state = MOTION_STALL;

	if (motor.initStatus)
    8090:	2c00      	cmp	X, #0
    8092:	1904      	je	0x809c <.L71>

00008094 <.LM223>:
	{
		motor.initStatus = 0;
    8094:	52d8 127a 	mov	0x127a <_motor+0x4>, A

00008098 <.LM224>:
		motor.out.enable = 0;
    8098:	52d8 12a0 	mov	0x12a0 <.LASF2051+0x1>, A

0000809c <.L71>:
	}
	motor.holdTime = 0;
    809c:	52d8 1288 	mov	0x1288 <.Lframe0>, A

000080a0 <.LM226>:
	motor.out.duty = 0;
    80a0:	52d8 12a2 	mov	0x12a2 <.LASF2051+0x3>, A

000080a4 <.LM227>:
	if (motor.stall.flag == 0u)
    80a4:	62d8 12ac 	lod	AL, 0x12ac <.LASF1639+0x1>
    80a8:	196d      	je	0x8084 <.L49>

000080aa <.LM228>:
	return next_state;
}

static tMotState motor_state_STALLED(void)
{
	tMotState next_state = MOTION_STALL;
    80aa:	7006      	lod	A, #6
    80ac:	06c3      	jmp	0x7e34 <.L39>

000080ae <.L48>:
    80ae:	7000      	lod	A, #0

000080b0 <.LBB69>:
}
static tMotState motor_state_FAULT(void)
{
	tMotState next_state = MOTION_FAULT;

	if (motor.initStatus)
    80b0:	2c00      	cmp	X, #0
    80b2:	1904      	je	0x80bc <.L72>

000080b4 <.LM230>:
	{
		motor.initStatus = 0;
    80b4:	52d8 127a 	mov	0x127a <_motor+0x4>, A

000080b8 <.LM231>:
		motor.out.enable = 0;
    80b8:	52d8 12a0 	mov	0x12a0 <.LASF2051+0x1>, A

000080bc <.L72>:
	}
	motor.out.duty = 0;
    80bc:	52d8 12a2 	mov	0x12a2 <.LASF2051+0x3>, A

000080c0 <.LM233>:
	if (motor.fault.flag == 0u)
    80c0:	62d8 12b8 	lod	AL, 0x12b8 <.LLST9+0x9>
    80c4:	1d02      	jne	0x80ca <.L95>

000080c6 <.LM234>:
	{
		DIAGNOSTIC_Reset();
    80c6:	1263      	call	0x858e <_DIAGNOSTIC_Reset>
    80c8:	068f      	jmp	0x7de8 <.L92>

000080ca <.L95>:

	return next_state;
}
static tMotState motor_state_FAULT(void)
{
	tMotState next_state = MOTION_FAULT;
    80ca:	7007      	lod	A, #7
    80cc:	06b3      	jmp	0x7e34 <.L39>

000080ce <.L77>:
			sensor.thd = 10;
			motor.stall.halfThd = 550;
			motor.stall.threshold = 650;
			motor.out.minDuty = (C_MOT_MAXDUTY_SET * 0.35);
		}
		else if (voltage <= 1050)
    80ce:	7203      	lod	A, [S-4]
    80d0:	aeda 041a 	cmp	A, #1050
    80d4:	1e10      	jug	0x80f6 <.L79>

000080d6 <.LM237>:
		{
			sensor.thd = 11;
    80d6:	700b      	lod	A, #11
    80d8:	52d8 1272 	mov	0x1272 <.LLST7>, A

000080dc <.LM238>:
			motor.stall.halfThd = 600;
    80dc:	72da 0258 	lod	A, #600
    80e0:	0ea7      	lod	C, ML.7
    80e2:	52d8 12b2 	mov	0x12b2 <.LLST9+0x3>, A

000080e6 <.LM239>:
			motor.stall.threshold = 700;
    80e6:	72da 02bc 	lod	A, #700
    80ea:	52d8 12b4 	mov	0x12b4 <.LLST9+0x5>, A

000080ee <.LM240>:
			motor.out.minDuty = (C_MOT_MAXDUTY_SET * 0.32);
    80ee:	0ea7      	lod	C, ML.7
    80f0:	72da 028f 	lod	A, #655
    80f4:	06d5      	jmp	0x7ea0 <.L137>

000080f6 <.L79>:
		}
		else if (voltage <= 1150)
    80f6:	7203      	lod	A, [S-4]
    80f8:	aeda 047e 	cmp	A, #1150
    80fc:	1e10      	jug	0x811e <.L80>

000080fe <.LM242>:
		{
			sensor.thd = 12;
    80fe:	700c      	lod	A, #12
    8100:	52d8 1272 	mov	0x1272 <.LLST7>, A

00008104 <.LM243>:
			motor.stall.halfThd = 650;
    8104:	72da 028a 	lod	A, #650
    8108:	0ea7      	lod	C, ML.7
    810a:	52d8 12b2 	mov	0x12b2 <.LLST9+0x3>, A

0000810e <.LM244>:
			motor.stall.threshold = 750;
    810e:	72da 02ee 	lod	A, #750
    8112:	52d8 12b4 	mov	0x12b4 <.LLST9+0x5>, A

00008116 <.LM245>:
			motor.out.minDuty = (C_MOT_MAXDUTY_SET * 0.29);
    8116:	0ea7      	lod	C, ML.7
    8118:	72da 0251 	lod	A, #593
    811c:	06c1      	jmp	0x7ea0 <.L137>

0000811e <.L80>:
		}
		else if (voltage <= 1250)
    811e:	7203      	lod	A, [S-4]
    8120:	aeda 04e2 	cmp	A, #1250
    8124:	1e10      	jug	0x8146 <.L81>

00008126 <.LM247>:
		{
			sensor.thd = 14;
    8126:	700e      	lod	A, #14
    8128:	52d8 1272 	mov	0x1272 <.LLST7>, A

0000812c <.LM248>:
			motor.stall.halfThd = 700;
    812c:	72da 02bc 	lod	A, #700
    8130:	0ea7      	lod	C, ML.7
    8132:	52d8 12b2 	mov	0x12b2 <.LLST9+0x3>, A

00008136 <.LM249>:
			motor.stall.threshold = 800;
    8136:	72da 0320 	lod	A, #800
    813a:	52d8 12b4 	mov	0x12b4 <.LLST9+0x5>, A

0000813e <.LM250>:
			motor.out.minDuty = (C_MOT_MAXDUTY_SET * 0.25);
    813e:	0ea7      	lod	C, ML.7
    8140:	72da 0200 	lod	A, #512
    8144:	06ad      	jmp	0x7ea0 <.L137>

00008146 <.L81>:
		}
		else if (voltage <= 1450)
    8146:	7203      	lod	A, [S-4]
    8148:	aeda 05aa 	cmp	A, #1450
    814c:	1e10      	jug	0x816e <.L82>

0000814e <.LM252>:
		{
			sensor.thd = 16;
    814e:	7010      	lod	A, #16
    8150:	52d8 1272 	mov	0x1272 <.LLST7>, A

00008154 <.LM253>:
			motor.stall.halfThd = 800;
    8154:	72da 0320 	lod	A, #800
    8158:	0ea7      	lod	C, ML.7
    815a:	52d8 12b2 	mov	0x12b2 <.LLST9+0x3>, A

0000815e <.LM254>:
			motor.stall.threshold = 900;
    815e:	72da 0384 	lod	A, #900
    8162:	52d8 12b4 	mov	0x12b4 <.LLST9+0x5>, A

00008166 <.LM255>:
			motor.out.minDuty = (C_MOT_MAXDUTY_SET * 0.21);
    8166:	0ea7      	lod	C, ML.7
    8168:	72da 01ae 	lod	A, #430
    816c:	0699      	jmp	0x7ea0 <.L137>

0000816e <.L82>:
		}
		else
		{
			sensor.thd = 17;
    816e:	7011      	lod	A, #17
    8170:	52d8 1272 	mov	0x1272 <.LLST7>, A

00008174 <.LM257>:
			motor.stall.halfThd = 900;
    8174:	72da 0384 	lod	A, #900
    8178:	0ea7      	lod	C, ML.7
    817a:	52d8 12b2 	mov	0x12b2 <.LLST9+0x3>, A

0000817e <.LM258>:
			motor.stall.threshold = 1000;
    817e:	72da 03e8 	lod	A, #1000
    8182:	52d8 12b4 	mov	0x12b4 <.LLST9+0x5>, A

00008186 <.LM259>:
			motor.out.minDuty = (C_MOT_MAXDUTY_SET * 0.18);
    8186:	0ea7      	lod	C, ML.7
    8188:	72da 0170 	lod	A, #368
    818c:	0689      	jmp	0x7ea0 <.L137>

0000818e <.L74>:
		}
	}
	else
	{
		sensor.delay = 50;
    818e:	7eda 0a32 	lod	X, #2610
    8192:	5ed8 126c 	mov	0x126c <_sensor+0x2>, X

00008196 <.LM261>:
		sensor.filterPeriod = 10;
    8196:	42d8 126e 	mov	0x126e <_sensor+0x4>, AL

0000819a <.LM262>:
		sensor.filterCnt = 0;
		sensor.delta = 0;
    819a:	0ea7      	lod	C, ML.7
    819c:	52d8 1270 	mov	0x1270 <_sensor+0x6>, A

000081a0 <.LM263>:
		sensor.moving = C_STATUS_OFF_;
    81a0:	52d8 126a 	mov	0x126a <_sensor>, A

000081a4 <.LM264>:
		sensor.lastDeg = motor.pos.current;
    81a4:	72d8 128a 	lod	A, 0x128a <.Lframe0+0x2>
    81a8:	0ea7      	lod	C, ML.7
    81aa:	52d8 1274 	mov	0x1274 <.LLST7+0x2>, A
    81ae:	067a      	jmp	0x7ea4 <.L78>

000081b0 <.L85>:
		{
			sensor.delta = motor.pos.current - sensor.lastDeg;
		}
		else
		{
			sensor.delta = sensor.lastDeg - motor.pos.current;
    81b0:	aaee      	sub	A, X
    81b2:	068b      	jmp	0x7eca <.L138>

000081b4 <.L87>:
			if (sensor.filterCnt < 3)
				sensor.filterCnt++;
		}
		else
		{
			if (sensor.filterCnt > -3)
    81b4:	acfe      	cmp	A, #-2
    81b6:	1e81      	jsge	0x81ba <.LM267>
    81b8:	069a      	jmp	0x7eee <.L88>

000081ba <.LM267>:
				sensor.filterCnt--;
    81ba:	80ff      	add	AL, #-1
    81bc:	0696      	jmp	0x7eea <.L139>

000081be <.L89>:
		}
		if (sensor.filterCnt >= 2)
		{
			sensor.moving = C_STATUS_RUN;
		}
		else if (sensor.filterCnt <= -2)
    81be:	acff      	cmp	A, #-1
    81c0:	1e8c      	jsge	0x81da <.L38>

000081c2 <.LM269>:
		{

			sensor.moving = C_STATUS_STOP;
    81c2:	7002      	lod	A, #2
    81c4:	069d      	jmp	0x7f00 <.L140>

000081c6 <.L61>:
	}
	default:
		next_state = MOTION_STOPPED;
		break;
	}
	if (next_state != motor.state)
    81c6:	7ada 1276 	lod	Y, #4726
    81ca:	7ef0      	lod	X, [Y]

000081cc <.LM271>:
					next_state = MOTION_DEC;
				}
			}
			else
			{
				next_state = MOTION_RUNNING;
    81cc:	7003      	lod	A, #3

000081ce <.LVL65>:
    81ce:	0637      	jmp	0x7e3e <.L91>

000081d0 <.L63>:
	}
	default:
		next_state = MOTION_STOPPED;
		break;
	}
	if (next_state != motor.state)
    81d0:	7ada 1276 	lod	Y, #4726
    81d4:	7ef0      	lod	X, [Y]

000081d6 <.LM273>:

		next_state = MOTION_STOPPED;
	}
	else if (Mot_dirChange_check() != 0)
	{
		next_state = MOTION_PAUSE;
    81d6:	7005      	lod	A, #5
    81d8:	0632      	jmp	0x7e3e <.L91>

000081da <.L38>:
		}
		else
		{
		}
	}
}
    81da:	5405      	ret	#6

000081dc <_motor_ctrl_handler>:

/* called by every 100us */
void motor_ctrl_handler(void)
{
    81dc:	5807      	inc	S, #8

000081de <.LCFI3>:
	uint16_t diff;

	adc_raw_update();
    81de:	82db 3bed 	callf	0x77da <_adc_raw_update>

000081e2 <.LM277>:
	motor.pos.current = calculate_gmr_angle();
    81e2:	82db 3c7a 	callf	0x78f4 <_calculate_gmr_angle>
    81e6:	52d8 128a 	mov	0x128a <.Lframe0+0x2>, A

000081ea <.LM278>:

	motor.pos.Delta = (int16_t)(motor.pos.target - motor.pos.current);
    81ea:	7ed8 128c 	lod	X, 0x128c <.Lframe0+0x4>
    81ee:	2ae2      	sub	X, A
    81f0:	72ee      	lod	A, X
    81f2:	5ed8 1290 	mov	0x1290 <.LASF1024+0x2>, X

000081f6 <.LM279>:
	if (motor.pos.Delta >= 0)
	{
		diff = motor.pos.Delta;
    81f6:	ac00      	cmp	A, #0
    81f8:	1d81      	jnn	0x81fc <.L217>
    81fa:	5cc2      	neg	A

000081fc <.L217>:
	else
	{
		diff = -motor.pos.Delta;
	}

	if (diff <= (int16_t)C_MOT_OFF_HYSTERISYS)
    81fc:	ac03      	cmp	A, #3
    81fe:	1e08      	jug	0x8210 <.L147>

00008200 <.LM281>:
	{
		motor.out.enable = 0;
    8200:	7000      	lod	A, #0

00008202 <.LVL71>:
    8202:	52d8 12a0 	mov	0x12a0 <.LASF2051+0x1>, A

00008206 <.LM282>:
		motor.pos.posReached = 1;
		motor.pos.newTarget = 0;
    8206:	72da 0100 	lod	A, #256
    820a:	0ea7      	lod	C, ML.7
    820c:	52d8 1292 	mov	0x1292 <.LASF1024+0x4>, A

00008210 <.L147>:
	}
	else
	{
	}
	/* motor stall diagnostics */
	if (motor.out.enable)
    8210:	72d8 12a0 	lod	A, 0x12a0 <.LASF2051+0x1>
    8214:	1d01      	jne	0x8218 <.LBB101>
    8216:	0103      	jmp	0x841e <.L148>

00008218 <.LBB101>:
 *
 * \return fault flag
 */
static void MotorStallDiag(void) /*100usec */
{
	uint16_t current = get_valve_motCurrent();
    8218:	82db 3367 	callf	0x66ce <_get_valve_motCurrent>
    821c:	7ae2      	lod	Y, A

0000821e <.LM285>:
	{
		motor.stall.maskTimer++;
	}
		*/

	if (motor.stall.maskTimer >= STALL_DETECT_TIMEOUT) /*100msec*/
    821e:	72d8 12ae 	lod	A, 0x12ae <.LASF1639+0x3>

00008222 <.LVL74>:
    8222:	ac63      	cmp	A, #99
    8224:	1e01      	jug	0x8228 <.LVL74+0x6>
    8226:	00f4      	jmp	0x8410 <.L149>
    8228:	72d8 12b6 	lod	A, 0x12b6 <.LLST9+0x7>

0000822c <.LM286>:
	{
		if ((current >= motor.stall.halfThd) && (sensor.delta < sensor.thd) && (sensor.delta > 3))
    822c:	eed8 12b2 	cmp	Y, 0x12b2 <.LLST9+0x3>
    8230:	1c01      	jnc	0x8234 <.LM286+0x8>
    8232:	00e4      	jmp	0x83fc <.L150>
    8234:	7ed8 1270 	lod	X, 0x1270 <_sensor+0x6>
    8238:	2ed8 1272 	cmp	X, 0x1272 <.LLST7>
    823c:	1a81      	jsl	0x8240 <.LASF1016+0x9>
    823e:	00de      	jmp	0x83fc <.L150>
    8240:	2c03      	cmp	X, #3
    8242:	1f01      	jsg	0x8246 <.LM287>
    8244:	00db      	jmp	0x83fc <.L150>

00008246 <.LM287>:
		{

			motor.stall.obstrCnt += 1;
    8246:	a001      	add	A, #1

00008248 <.L214>:
		}
		else
		{

			if (motor.stall.obstrCnt > 0)
				motor.stall.obstrCnt -= 1;
    8248:	52d8 12b6 	mov	0x12b6 <.LLST9+0x7>, A

0000824c <.L151>:
		}
		if (motor.stall.obstrCnt >= 3000u)
    824c:	72d8 12b6 	lod	A, 0x12b6 <.LLST9+0x7>
    8250:	aeda 0bb7 	cmp	A, #2999
    8254:	1a1f      	jule	0x8294 <.L153>

00008256 <.LM290>:
		{
			if ((motor.stall.enable) && (get_valve_mode() != VALVE_CALIBRATION))
    8256:	62d8 12ad 	lod	AL, 0x12ad <.LASF1639+0x2>
    825a:	191c      	je	0x8294 <.L153>
    825c:	5a03      	mov	[S-4], Y
    825e:	82db 335e 	callf	0x66bc <_get_valve_mode>

00008262 <.LVL75>:
    8262:	7a03      	lod	Y, [S-4]
    8264:	ac05      	cmp	A, #5
    8266:	1916      	je	0x8294 <.L153>

00008268 <.LM291>:
			{
				motor.stall.flag |= STALL_MASK_TEMPORARY;
    8268:	62d8 12ac 	lod	AL, 0x12ac <.LASF1639+0x1>
    826c:	8401      	or	AL, #1
    826e:	42d8 12ac 	mov	0x12ac <.LASF1639+0x1>, AL

00008272 <.LM292>:

				u16EventState = MOT_ABSTALL_ERROR;
    8272:	7005      	lod	A, #5
    8274:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

00008278 <.LM293>:
				u16EventValue = (uint16_t)(current >> 3);
				u16EventValue |= (uint16_t)((motor.elapsedTime >> 8) << 8);
    8278:	0ea7      	lod	C, ML.7
    827a:	7ed8 127c 	lod	X, 0x127c <.LASF1845>
    827e:	36da ff00 	and	X, #65280
    8282:	5e05      	mov	[S-6], X

00008284 <.LM294>:
			if ((motor.stall.enable) && (get_valve_mode() != VALVE_CALIBRATION))
			{
				motor.stall.flag |= STALL_MASK_TEMPORARY;

				u16EventState = MOT_ABSTALL_ERROR;
				u16EventValue = (uint16_t)(current >> 3);
    8284:	72e6      	lod	A, Y
    8286:	44b2      	lsr	A, #2
    8288:	4432      	lsr	A
    828a:	7ee2      	lod	X, A

0000828c <.LM295>:
				u16EventValue |= (uint16_t)((motor.elapsedTime >> 8) << 8);
    828c:	7205      	lod	A, [S-6]
    828e:	a6ee      	or	A, X
    8290:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

00008294 <.L153>:
    8294:	72d8 12b0 	lod	A, 0x12b0 <.LLST9+0x1>

00008298 <.LM296>:
			}
		}

		if ((current >= motor.stall.threshold) && (sensor.moving == C_STATUS_STOP))
    8298:	eed8 12b4 	cmp	Y, 0x12b4 <.LLST9+0x5>
    829c:	1c01      	jnc	0x82a0 <.LASF1219>
    829e:	00b3      	jmp	0x8406 <.L155>
    82a0:	7ed8 126a 	lod	X, 0x126a <_sensor>
    82a4:	2c02      	cmp	X, #2
    82a6:	1901      	je	0x82aa <.LM297>
    82a8:	00ae      	jmp	0x8406 <.L155>

000082aa <.LM297>:
		{

			motor.stall.stallCnt += 1;
    82aa:	a001      	add	A, #1

000082ac <.L215>:
		}
		else
		{

			if (motor.stall.stallCnt > 0)
				motor.stall.stallCnt -= 1;
    82ac:	52d8 12b0 	mov	0x12b0 <.LLST9+0x1>, A

000082b0 <.L156>:
		}
		if (motor.stall.stallCnt >= 5000u)
    82b0:	72d8 12b0 	lod	A, 0x12b0 <.LLST9+0x1>
    82b4:	aeda 1387 	cmp	A, #4999
    82b8:	1a14      	jule	0x82e2 <.L157>

000082ba <.LM300>:
		{
			if (motor.stall.enable)
    82ba:	62d8 12ad 	lod	AL, 0x12ad <.LASF1639+0x2>
    82be:	1911      	je	0x82e2 <.L157>

000082c0 <.LM301>:
			{
				motor.stall.flag |= STALL_MASK_PERMENT;
    82c0:	62d8 12ac 	lod	AL, 0x12ac <.LASF1639+0x1>
    82c4:	8402      	or	AL, #2
    82c6:	42d8 12ac 	mov	0x12ac <.LASF1639+0x1>, AL

000082ca <.LM302>:

				u16EventState = MOT_STALL_FAULT;
    82ca:	700a      	lod	A, #10
    82cc:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

000082d0 <.LM303>:
				u16EventValue = (uint16_t)(current >> 3);
				u16EventValue |= (uint16_t)((motor.elapsedTime >> 8) << 8);
    82d0:	0ea7      	lod	C, ML.7
    82d2:	72d8 127c 	lod	A, 0x127c <.LASF1845>
    82d6:	9400      	and	AL, #0

000082d8 <.LM304>:
			if (motor.stall.enable)
			{
				motor.stall.flag |= STALL_MASK_PERMENT;

				u16EventState = MOT_STALL_FAULT;
				u16EventValue = (uint16_t)(current >> 3);
    82d8:	44b6      	lsr	Y, #2
    82da:	4436      	lsr	Y

000082dc <.LM305>:
				u16EventValue |= (uint16_t)((motor.elapsedTime >> 8) << 8);
    82dc:	e6e2      	or	Y, A
    82de:	5ad8 10b4 	mov	0x10b4 <_u16EventValue>, Y

000082e2 <.L157>:
	}
	else
	{
		motor.stall.maskTimer = 0;
	}
	if (motor.stall.flag != 0u)
    82e2:	7ada 1276 	lod	Y, #4726
    82e6:	62d8 12ac 	lod	AL, 0x12ac <.LASF1639+0x1>
    82ea:	1911      	je	0x830e <.L159>

000082ec <.LM307>:
	{

		motor.out.enable = 0;
    82ec:	7c00      	lod	X, #0
    82ee:	5ed8 12a0 	mov	0x12a0 <.LASF2051+0x1>, X

000082f2 <.LM308>:
		if (motor.state != MOTION_STALL)
    82f2:	72f0      	lod	A, [Y]
    82f4:	5205      	mov	[S-6], A
    82f6:	ac06      	cmp	A, #6
    82f8:	190a      	je	0x830e <.L159>

000082fa <.LM309>:
		{
			motor.initStatus = 1u;
    82fa:	7001      	lod	A, #1
    82fc:	52d8 127a 	mov	0x127a <_motor+0x4>, A

00008300 <.LM310>:
			motor.elapsedTime = 0;
    8300:	5ed8 127c 	mov	0x127c <.LASF1845>, X

00008304 <.LM311>:
			motor.lastState = motor.state;
    8304:	7205      	lod	A, [S-6]
    8306:	52d8 1278 	mov	0x1278 <_motor+0x2>, A

0000830a <.LM312>:
			motor.state = MOTION_STALL;
    830a:	7006      	lod	A, #6
    830c:	52f0      	mov	[Y], A

0000830e <.L159>:
	}
}

static void MotorFaultDiag(void)
{
	uint16_t current = get_valve_motCurrent();
    830e:	82db 3367 	callf	0x66ce <_get_valve_motCurrent>
    8312:	7ae2      	lod	Y, A

00008314 <.LM314>:
	/* open check */
	if (motor.state == MOTION_RUNNING)
    8314:	7ed8 1276 	lod	X, 0x1276 <_motor>
    8318:	5e05      	mov	[S-6], X
    831a:	2c03      	cmp	X, #3
    831c:	1901      	je	0x8320 <.LM315>
    831e:	0088      	jmp	0x8430 <.L166>

00008320 <.LM315>:
	{
		if (!(motor.fault.flag & FAULT_MASK_PHASE_A_OPEN))
    8320:	62d8 12b8 	lod	AL, 0x12b8 <.LLST9+0x9>

00008324 <.LVL78>:
    8324:	4207      	mov	[S-8], AL
    8326:	9401      	and	AL, #1
    8328:	1901      	je	0x832c <.LM316>
    832a:	0082      	jmp	0x8430 <.L166>

0000832c <.LM316>:
		{
			if (!motor.fault.openDetectCheck)
    832c:	62d8 12c0 	lod	AL, 0x12c0 <.LLST9+0x11>
    8330:	4206      	mov	[S-7], AL
    8332:	6206      	lod	AL, [S-7]
    8334:	1901      	je	0x8338 <.LASF2103+0x2>
    8336:	0076      	jmp	0x8424 <.L162>
    8338:	5cf2      	usex	A
    833a:	7ee2      	lod	X, A

0000833c <.LM317>:
			{
				if ((current <= OPEN_DETECT_CURRENT) && (sensor.moving == C_STATUS_STOP))
    833c:	ec14      	cmp	Y, #20
    833e:	1a01      	jule	0x8342 <.LASF1990>
    8340:	007a      	jmp	0x8436 <.L216>
    8342:	72d8 126a 	lod	A, 0x126a <_sensor>
    8346:	ac02      	cmp	A, #2
    8348:	1901      	je	0x834c <.LBB106>
    834a:	0075      	jmp	0x8436 <.L216>

0000834c <.LBB106>:
void setFaultDetect(uint8_t tFault, uint8_t tDetectCheck, uint8_t tDetectCnt)
{
	switch (tFault)
	{
	case FAULT_OPEN :
		motor.fault.openDetectCheck = tDetectCheck;
    834c:	6001      	lod	AL, #1
    834e:	42d8 12c0 	mov	0x12c0 <.LLST9+0x11>, AL

00008352 <.LM319>:
		motor.fault.openDetectCnt = tDetectCnt;
    8352:	5ed8 12c2 	mov	0x12c2 <.LLST10>, X

00008356 <.L164>:
	{
		setFaultDetect(FAULT_OPEN, CLEAR, CLEAR);
	}

	/* overcurrent check */
	if (motor.out.enable)
    8356:	72d8 12a0 	lod	A, 0x12a0 <.LASF2051+0x1>
    835a:	1d01      	jne	0x835e <.L164+0x8>
    835c:	0092      	jmp	0x8482 <.L172>
    835e:	62d8 12b8 	lod	AL, 0x12b8 <.LLST9+0x9>
    8362:	4207      	mov	[S-8], AL

00008364 <.LM321>:
	{
		if (!(motor.fault.flag & FAULT_MASK_OVER_CURRENT))
    8364:	9440      	and	AL, #64
    8366:	1901      	je	0x836a <.LM322>
    8368:	008c      	jmp	0x8482 <.L172>

0000836a <.LM322>:
		{
			if (!motor.fault.ocDetectCheck)
    836a:	62d8 12bc 	lod	AL, 0x12bc <.LLST9+0xd>
    836e:	4206      	mov	[S-7], AL
    8370:	6206      	lod	AL, [S-7]
    8372:	1901      	je	0x8376 <.LASF1489+0x6>
    8374:	0083      	jmp	0x847c <.L168>
    8376:	5cf2      	usex	A
    8378:	7ee2      	lod	X, A

0000837a <.LM323>:
			{
				if(current >= OVER_CURRNET_DETECT_CURRENT)	
    837a:	eeda 044b 	cmp	Y, #1099
    837e:	1a03      	jule	0x8386 <.L169>

00008380 <.LBB108>:
		motor.fault.openDetectCheck = tDetectCheck;
		motor.fault.openDetectCnt = tDetectCnt;
		break;

	case FAULT_OC :
		motor.fault.ocDetectCheck = tDetectCheck;
    8380:	6001      	lod	AL, #1
    8382:	42d8 12bc 	mov	0x12bc <.LLST9+0xd>, AL

00008386 <.L169>:
		motor.fault.ocDetectCnt = tDetectCnt;
    8386:	5ed8 12be 	mov	0x12be <.LLST9+0xf>, X

0000838a <.L170>:
	{
		setFaultDetect(FAULT_OC, CLEAR, CLEAR);
	}

	/* short/oc check */
	if (g_e8ShortOcc == C_ERR_SHORT_VDS)
    838a:	72d8 11b6 	lod	A, 0x11b6 <_g_e8ShortOcc>
    838e:	ac02      	cmp	A, #2
    8390:	1d11      	jne	0x83b4 <.L173>

00008392 <.LM327>:
	{
		motor.fault.flag |= FAULT_MASK_PHASE_A_SHORT;
    8392:	62d8 12b8 	lod	AL, 0x12b8 <.LLST9+0x9>
    8396:	8410      	or	AL, #16
    8398:	42d8 12b8 	mov	0x12b8 <.LLST9+0x9>, AL

0000839c <.LM328>:

		u16EventState = MOT_SHORT_FAULT;
    839c:	700b      	lod	A, #11
    839e:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

000083a2 <.LM329>:
		u16EventValue = (uint16_t)(current >> 3);
		u16EventValue |= (uint16_t)((motor.elapsedTime >> 8) << 8);
    83a2:	0ea7      	lod	C, ML.7
    83a4:	72d8 127c 	lod	A, 0x127c <.LASF1845>
    83a8:	9400      	and	AL, #0

000083aa <.LM330>:
	if (g_e8ShortOcc == C_ERR_SHORT_VDS)
	{
		motor.fault.flag |= FAULT_MASK_PHASE_A_SHORT;

		u16EventState = MOT_SHORT_FAULT;
		u16EventValue = (uint16_t)(current >> 3);
    83aa:	44b6      	lsr	Y, #2
    83ac:	4436      	lsr	Y

000083ae <.LM331>:
		u16EventValue |= (uint16_t)((motor.elapsedTime >> 8) << 8);
    83ae:	a6e6      	or	A, Y
    83b0:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

000083b4 <.L173>:
			motor.state = MOTION_STALL;
		}
	}
	/* motor fault diagnostics */
	MotorFaultDiag();
	if (motor.fault.flag != 0)
    83b4:	62d8 12b8 	lod	AL, 0x12b8 <.LLST9+0x9>
    83b8:	1914      	je	0x83e2 <.L174>

000083ba <.LM333>:
	{
		motor.holdTime = 0;
    83ba:	7000      	lod	A, #0
    83bc:	52d8 1288 	mov	0x1288 <.Lframe0>, A

000083c0 <.LM334>:
		motor.out.enable = 0;
    83c0:	52d8 12a0 	mov	0x12a0 <.LASF2051+0x1>, A

000083c4 <.LM335>:
		if (motor.state != MOTION_FAULT)
    83c4:	7e05      	lod	X, [S-6]
    83c6:	2c07      	cmp	X, #7
    83c8:	1d01      	jne	0x83cc <.LM336>
    83ca:	0082      	jmp	0x84d0 <.L175>

000083cc <.LM336>:
		{
			motor.initStatus = 1u;
    83cc:	7c01      	lod	X, #1
    83ce:	5ed8 127a 	mov	0x127a <_motor+0x4>, X

000083d2 <.LM337>:
			motor.elapsedTime = 0;
    83d2:	52d8 127c 	mov	0x127c <.LASF1845>, A

000083d6 <.LM338>:
			motor.lastState = motor.state;
    83d6:	7e05      	lod	X, [S-6]
    83d8:	5ed8 1278 	mov	0x1278 <_motor+0x2>, X

000083dc <.LM339>:
			motor.state = MOTION_FAULT;
    83dc:	7007      	lod	A, #7
    83de:	52d8 1276 	mov	0x1276 <_motor>, A

000083e2 <.L174>:
		}
	}

	if (motor.out.enable)
    83e2:	72d8 12a0 	lod	A, 0x12a0 <.LASF2051+0x1>
    83e6:	1d01      	jne	0x83ea <.LM341>
    83e8:	0073      	jmp	0x84d0 <.L175>

000083ea <.LM341>:
	{
		/* 16384 = 0% */
		pwm_SetDutyCycle(motor.direction, motor.out.duty);
    83ea:	72d8 1282 	lod	A, 0x1282 <.LASF1845+0x6>
    83ee:	5cf2      	usex	A
    83f0:	7ed8 12a2 	lod	X, 0x12a2 <.LASF2051+0x3>
    83f4:	5edf      	push	X

000083f6 <.LCFI4>:
    83f6:	82db 4d2c 	callf	0x9a58 <_pwm_SetDutyCycle>

000083fa <.LCFI5>:
    83fa:	540b      	ret	#12

000083fc <.L150>:
			motor.stall.obstrCnt += 1;
		}
		else
		{

			if (motor.stall.obstrCnt > 0)
    83fc:	ac00      	cmp	A, #0
    83fe:	1d01      	jne	0x8402 <.LM343>
    8400:	0725      	jmp	0x824c <.L151>

00008402 <.LM343>:
				motor.stall.obstrCnt -= 1;
    8402:	a0ff      	add	A, #-1
    8404:	0721      	jmp	0x8248 <.L214>

00008406 <.L155>:
			motor.stall.stallCnt += 1;
		}
		else
		{

			if (motor.stall.stallCnt > 0)
    8406:	ac00      	cmp	A, #0
    8408:	1d01      	jne	0x840c <.LM345>
    840a:	0752      	jmp	0x82b0 <.L156>

0000840c <.LM345>:
				motor.stall.stallCnt -= 1;
    840c:	a0ff      	add	A, #-1
    840e:	074e      	jmp	0x82ac <.L215>

00008410 <.L149>:
			}
		}
	}
	else
	{
		motor.stall.stallCnt = 0;
    8410:	7000      	lod	A, #0
    8412:	52d8 12b0 	mov	0x12b0 <.LLST9+0x1>, A

00008416 <.LM347>:
		motor.stall.obstrCnt = 0;
    8416:	52d8 12b6 	mov	0x12b6 <.LLST9+0x7>, A
    841a:	0ea7      	lod	C, ML.7
    841c:	0762      	jmp	0x82e2 <.L157>

0000841e <.L148>:
	{
		MotorStallDiag();
	}
	else
	{
		motor.stall.maskTimer = 0;
    841e:	52d8 12ae 	mov	0x12ae <.LASF1639+0x3>, A
    8422:	075f      	jmp	0x82e2 <.L157>

00008424 <.L162>:
					setFaultDetect(FAULT_OPEN, CLEAR, CLEAR);
				}
			}
			else
			{
				if ((current > OPEN_DETECT_CURRENT) || (sensor.moving != C_STATUS_STOP))
    8424:	ec14      	cmp	Y, #20
    8426:	1e04      	jug	0x8430 <.L166>
    8428:	72d8 126a 	lod	A, 0x126a <_sensor>
    842c:	ac02      	cmp	A, #2
    842e:	1907      	je	0x843e <.L165>

00008430 <.L166>:
void setFaultDetect(uint8_t tFault, uint8_t tDetectCheck, uint8_t tDetectCnt)
{
	switch (tFault)
	{
	case FAULT_OPEN :
		motor.fault.openDetectCheck = tDetectCheck;
    8430:	6000      	lod	AL, #0
    8432:	42d8 12c0 	mov	0x12c0 <.LLST9+0x11>, AL

00008436 <.L216>:
		motor.fault.openDetectCnt = tDetectCnt;
    8436:	7000      	lod	A, #0
    8438:	52d8 12c2 	mov	0x12c2 <.LLST10>, A
    843c:	078c      	jmp	0x8356 <.L164>

0000843e <.L165>:
				{
					setFaultDetect(FAULT_OPEN, CLEAR, CLEAR);
				}
				else
				{
					if (motor.fault.openDetectCnt >= OPEN_DETECT_TIMEOUT)
    843e:	72d8 12c2 	lod	A, 0x12c2 <.LLST10>
    8442:	aeda 01f3 	cmp	A, #499
    8446:	1e01      	jug	0x844a <.LM353>
    8448:	0786      	jmp	0x8356 <.L164>

0000844a <.LM353>:
					{
						if (motor.fault.openEnable)
    844a:	62d8 12ba 	lod	AL, 0x12ba <.LLST9+0xb>
    844e:	1970      	je	0x8430 <.L166>

00008450 <.LM354>:
						{
							motor.fault.flag |= FAULT_MASK_PHASE_A_OPEN;
    8450:	6207      	lod	AL, [S-8]
    8452:	8401      	or	AL, #1
    8454:	42d8 12b8 	mov	0x12b8 <.LLST9+0x9>, AL

00008458 <.LM355>:
							u16EventState = MOT_OPEN_FAULT;
    8458:	700c      	lod	A, #12
    845a:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

0000845e <.LM356>:
							u16EventValue = (uint16_t)(current >> 3);
							u16EventValue |= (uint16_t)((motor.elapsedTime >> 8) << 8);
    845e:	0ea7      	lod	C, ML.7
    8460:	7ed8 127c 	lod	X, 0x127c <.LASF1845>
    8464:	36da ff00 	and	X, #65280
    8468:	5e01      	mov	[S-2], X

0000846a <.LM357>:
					{
						if (motor.fault.openEnable)
						{
							motor.fault.flag |= FAULT_MASK_PHASE_A_OPEN;
							u16EventState = MOT_OPEN_FAULT;
							u16EventValue = (uint16_t)(current >> 3);
    846a:	72e6      	lod	A, Y
    846c:	44b2      	lsr	A, #2
    846e:	4432      	lsr	A
    8470:	7ee2      	lod	X, A

00008472 <.LM358>:
							u16EventValue |= (uint16_t)((motor.elapsedTime >> 8) << 8);
    8472:	7201      	lod	A, [S-2]
    8474:	a6ee      	or	A, X
    8476:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A
    847a:	07da      	jmp	0x8430 <.L166>

0000847c <.L168>:
					setFaultDetect(FAULT_OC, CLEAR, CLEAR);
				}
			}
			else
			{
				if(current < OVER_CURRNET_DETECT_CURRENT)
    847c:	eeda 044b 	cmp	Y, #1099
    8480:	1e08      	jug	0x8492 <.L171>

00008482 <.L172>:
		motor.fault.openDetectCheck = tDetectCheck;
		motor.fault.openDetectCnt = tDetectCnt;
		break;

	case FAULT_OC :
		motor.fault.ocDetectCheck = tDetectCheck;
    8482:	6000      	lod	AL, #0
    8484:	42d8 12bc 	mov	0x12bc <.LLST9+0xd>, AL

00008488 <.LM361>:
		motor.fault.ocDetectCnt = tDetectCnt;
    8488:	7000      	lod	A, #0
    848a:	0ea7      	lod	C, ML.7
    848c:	52d8 12be 	mov	0x12be <.LLST9+0xf>, A
    8490:	077c      	jmp	0x838a <.L170>

00008492 <.L171>:
				{
					setFaultDetect(FAULT_OC, CLEAR, CLEAR);
				}
				else
				{
					if (motor.fault.ocDetectCnt >= OVER_CURRNET_DETECT_TIMEOUT)
    8492:	72d8 12be 	lod	A, 0x12be <.LLST9+0xf>
    8496:	aeda 012b 	cmp	A, #299
    849a:	1e01      	jug	0x849e <.LM363>
    849c:	0776      	jmp	0x838a <.L170>

0000849e <.LM363>:
					{
						if(motor.fault.ocEnable)
    849e:	62d8 12b9 	lod	AL, 0x12b9 <.LLST9+0xa>
    84a2:	196f      	je	0x8482 <.L172>

000084a4 <.LM364>:
						{
							motor.fault.flag |= FAULT_MASK_OVER_CURRENT;
    84a4:	6207      	lod	AL, [S-8]
    84a6:	8440      	or	AL, #64
    84a8:	42d8 12b8 	mov	0x12b8 <.LLST9+0x9>, AL

000084ac <.LM365>:
							u16EventState = MOT_OC_ERROR;
    84ac:	7004      	lod	A, #4
    84ae:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

000084b2 <.LM366>:
							u16EventValue = (uint16_t)(current >> 3);
							u16EventValue |= (uint16_t)((motor.elapsedTime >> 8) << 8);
    84b2:	0ea7      	lod	C, ML.7
    84b4:	7ed8 127c 	lod	X, 0x127c <.LASF1845>
    84b8:	36da ff00 	and	X, #65280
    84bc:	5e01      	mov	[S-2], X

000084be <.LM367>:
					{
						if(motor.fault.ocEnable)
						{
							motor.fault.flag |= FAULT_MASK_OVER_CURRENT;
							u16EventState = MOT_OC_ERROR;
							u16EventValue = (uint16_t)(current >> 3);
    84be:	72e6      	lod	A, Y
    84c0:	44b2      	lsr	A, #2
    84c2:	4432      	lsr	A
    84c4:	7ee2      	lod	X, A

000084c6 <.LM368>:
							u16EventValue |= (uint16_t)((motor.elapsedTime >> 8) << 8);
    84c6:	7201      	lod	A, [S-2]
    84c8:	a6ee      	or	A, X
    84ca:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A
    84ce:	07d9      	jmp	0x8482 <.L172>

000084d0 <.L175>:
		/* 16384 = 0% */
		pwm_SetDutyCycle(motor.direction, motor.out.duty);
	}
	else
	{
		if (motor.elapsedTime >= 1000u)
    84d0:	72d8 127c 	lod	A, 0x127c <.LASF1845>
    84d4:	aeda 03e7 	cmp	A, #999
    84d8:	1a03      	jule	0x84e0 <.L177>

000084da <.LM370>:
		{
			pwm_Off();
    84da:	82db 4d66 	callf	0x9acc <_pwm_Off>
    84de:	5409      	ret	#10

000084e0 <.L177>:
		}
		else
		{
			pwm_Stop();
    84e0:	82db 4d56 	callf	0x9aac <_pwm_Stop>

000084e4 <.LM372>:
		}
	}
}
    84e4:	5409      	ret	#10

000084e6 <_diagnostic_Init>:
void diagnostic_Init(void)
{
    /* Disable hardware protection for over-temperature, under-voltage
     * Hardware protection is enabled in case of OC, VDS(LS), VDS(HS), OV_VS, OVT
     */
    IO_SET(PORT_DRV1_PROT, DIS_UV_VDDA, 1u, DIS_UV_VDDAF, 1u, DIS_UV_VS, 1u);
    84e6:	72d8 0218 	lod	A, 0x218 <_PORT_DRV1_PROT>
    84ea:	a6da 02a0 	or	A, #672
    84ee:	52d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, A

000084f2 <.LM5>:

    /*
     * Connect the phase to GND in case of VDS(HS),
     */
    IO_SET(PORT_DRV1_PROT,
    84f2:	0ea7      	lod	C, ML.7
    84f4:	72d8 0218 	lod	A, 0x218 <_PORT_DRV1_PROT>
    84f8:	b6da abfa 	and	A, #44026
    84fc:	c404      	or	AH, #4
    84fe:	52d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, A

00008502 <.LM6>:
           0, /* high */
           OC_PM,
           PROTECTION_MODE_TRISTATE);

    /* Set/enable UV & OV debounce circuitry */
    IO_SET(PORT_SUPP_CFG, UV_VS_FILT_SEL, 1u); /* 0 : 1-2us filtering, 1 : 100-110us filtering */
    8502:	62d8 01e4 	lod	AL, 0x1e4 <_PORT_SUPP_CFG>
    8506:	8408      	or	AL, #8
    8508:	42d8 01e4 	mov	0x1e4 <_PORT_SUPP_CFG>, AL

0000850c <.LM7>:
    IO_SET(PORT_SUPP_CFG, OV_VS_FILT_SEL, 1u); /* 0 : 1-2us filtering, 1 : 100-110us filtering */
    850c:	62d8 01e4 	lod	AL, 0x1e4 <_PORT_SUPP_CFG>
    8510:	8410      	or	AL, #16
    8512:	42d8 01e4 	mov	0x1e4 <_PORT_SUPP_CFG>, AL

00008516 <.LM8>:

    /* Under/Over voltage detection levels */
    IO_SET(PORT_MISC_OUT, PRUV_VS, vsuv6V);
    8516:	72d8 01f2 	lod	A, 0x1f2 <_PORT_MISC_OUT>
    851a:	b6da fe3f 	and	A, #65087
    851e:	8480      	or	AL, #-128
    8520:	52d8 01f2 	mov	0x1f2 <_PORT_MISC_OUT>, A

00008524 <.LM9>:
    //    IO_SET(PORT_MISC_OUT, PRUV_VS, vsuv9V);
    //    IO_SET(PORT_MISC_OUT, PROV_VS, vsov22V);
    IO_SET(PORT_MISC_OUT, PROV_VS, vsov24V);
    8524:	62d8 01f3 	lod	AL, 0x1f3 <_PORT_MISC_OUT+0x1>
    8528:	94f9      	and	AL, #-7
    852a:	8402      	or	AL, #2
    852c:	42d8 01f3 	mov	0x1f3 <_PORT_MISC_OUT+0x1>, AL

00008530 <.LM10>:

    uint16_t u16trim_high = EE_GET(TRIM_CSA_CL_HIGH); // 2A Threshold from calibration data
    uint16_t u16trim_low = EE_GET(TRIM_CSA_CL_LOW);   // 1.5A Trheshold from calibration data

    IO_SET(TRIM3_DRV, TRIM_CSA_CL, u16trim_high); // HW OC threshold ,2A
    8530:	62d8 09f0 	lod	AL, 0x9f0 <.LASF1746+0x7>
    8534:	42d8 020c 	mov	0x20c <_TRIM3_DRV>, AL

00008538 <.LM11>:
			STEP2_INC , 1U) ; 	/* STEP_INC = 1 */
    IO_SET (PORT_SSCM2_CONF , SSCM2_EN , 1u ) ; /* Enable the spread spectrum modulation */
#endif
    // VDDA output voltage level
    // Default : 3.3V output
    IO_SET(PORT_MISC_OUT, SWITCH_VDDA_TO_5V, VDDA_OUTPUT_LEVEL); /* 5V output*/
    8538:	0ea7      	lod	C, ML.7
    853a:	62d8 01f2 	lod	AL, 0x1f2 <_PORT_MISC_OUT>
    853e:	94df      	and	AL, #-33
    8540:	42d8 01f2 	mov	0x1f2 <_PORT_MISC_OUT>, AL

00008544 <.LM12>:
    Itc_Enable(UV_VS);		//Under Voltage_ISR Enable
    Itc_Enable(OV_VS);		//Over Voltage Enable
    Itc_Enable(OVC);		//Over Current_ISR Enable
    Itc_Enable(OVT);		//Over Temperature_ISR Enable
#endif
}
    8544:	5401      	ret

00008546 <_diagnostic_Start>:
/**
 * Clear over current, VDS and OV pending flag(s)
 */
void diagnostic_Start(void)
{
    IO_SET(PORT_DRV1_PROT, DIS_OC, 1u); /* clear MEM flag */
    8546:	62d8 0219 	lod	AL, 0x219 <.LLST20>
    854a:	8408      	or	AL, #8
    854c:	42d8 0219 	mov	0x219 <.LLST20>, AL

00008550 <.LM22>:
    //IO_SET(PORT_DRV1_PROT, DIS_OC, 0u); /* re-enable hardware protection */

    IO_SET(PORT_DRV1_PROT, DIS_UV_VS, 1u); /* clear MEM flag */
    8550:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    8554:	8420      	or	AL, #32
    8556:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

0000855a <.LM23>:
    IO_SET(PORT_DRV1_PROT, DIS_UV_VS, 0u); /* re-enable hardware protection */
    855a:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    855e:	94df      	and	AL, #-33
    8560:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

00008564 <.LM24>:

    IO_SET(PORT_DRV1_PROT, DIS_OV_VS, 1u); /* clear MEM flag */
    8564:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    8568:	8408      	or	AL, #8
    856a:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

0000856e <.LM25>:
    IO_SET(PORT_DRV1_PROT, DIS_OV_VS, 0u); /* re-enable hardware protection */
    856e:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    8572:	94f7      	and	AL, #-9
    8574:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

00008578 <.LM26>:

    IO_SET(PORT_DRV1_PROT, DIS_OVT, 1u); /* clear MEM flag */
    8578:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    857c:	8402      	or	AL, #2
    857e:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

00008582 <.LM27>:
    IO_SET(PORT_DRV1_PROT, DIS_OVT, 0u); /* re-enable hardware protection */
    8582:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    8586:	94fd      	and	AL, #-3
    8588:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

0000858c <.LM28>:
}
    858c:	5401      	ret

0000858e <_DIAGNOSTIC_Reset>:
/**
 * Clear over current, VDS and OC pending flag(s)
 */
void DIAGNOSTIC_Reset(void)
{
    IO_SET(PORT_DRV1_PROT, DIS_OC, 1u); /* clear OVC_MEM flag */
    858e:	62d8 0219 	lod	AL, 0x219 <.LLST20>
    8592:	8408      	or	AL, #8
    8594:	42d8 0219 	mov	0x219 <.LLST20>, AL

00008598 <.LM31>:
    IO_SET(PORT_DRV1_PROT, DIS_OC, 0u); /* re-enable OVC hardware protection */
    8598:	62d8 0219 	lod	AL, 0x219 <.LLST20>
    859c:	94f7      	and	AL, #-9
    859e:	42d8 0219 	mov	0x219 <.LLST20>, AL

000085a2 <.LM32>:

    IO_SET(PORT_DRV1_PROT, DIS_OV_HS_VDS, 1u); /* clear OV_HS_VDS_MEM flag */
    85a2:	62d8 0219 	lod	AL, 0x219 <.LLST20>
    85a6:	8420      	or	AL, #32
    85a8:	42d8 0219 	mov	0x219 <.LLST20>, AL

000085ac <.LM33>:
    IO_SET(PORT_DRV1_PROT, DIS_OV_HS_VDS, 0u); /* re-enable HS-VDS hardware protection */
    85ac:	62d8 0219 	lod	AL, 0x219 <.LLST20>
    85b0:	94df      	and	AL, #-33
    85b2:	42d8 0219 	mov	0x219 <.LLST20>, AL

000085b6 <.LM34>:
}
    85b6:	5401      	ret

000085b8 <_diagnostic_IsUVPending>:
 */
bool diagnostic_IsUVPending(void)
{
    bool bRetVal;

    bRetVal = IO_GET(PORT_SUPP_IN, UV_VS_IT) ? true : false;
    85b8:	72d8 01e0 	lod	A, 0x1e0 <_PORT_SUPP_IN>

000085bc <.LM37>:
        ENTER_SECTION(ATOMIC_SYSTEM_MODE);
        Itc_Enable(UV_VS);
        EXIT_SECTION();
    }
#endif
    return bRetVal;
    85bc:	9404      	and	AL, #4
    85be:	5ca2      	sne	A

000085c0 <.LM38>:
}
    85c0:	5401      	ret

000085c2 <_diagnostic_IsOVPending>:
 */
bool diagnostic_IsOVPending(void)
{
    bool bRetVal;

    bRetVal = IO_GET(PORT_DIAG_IN, OV_VS_MEM) ? true : false;
    85c2:	72d8 021e 	lod	A, 0x21e <_PORT_DIAG_IN>

000085c6 <.LM41>:
    {
        IO_SET(PORT_DRV1_PROT, DIS_OV_VS, 1u);  /* clear MEM flag */
        IO_SET(PORT_DRV1_PROT, DIS_OV_VS, 0u);  /* re-enable hardware protection */
    }
#endif
    return bRetVal;
    85c6:	9402      	and	AL, #2
    85c8:	5ca2      	sne	A

000085ca <.LM42>:
}
    85ca:	5401      	ret

000085cc <_diagnostic_IsOVTPending>:
 */
bool diagnostic_IsOVTPending(void)
{
    bool bRetVal;

    bRetVal = IO_GET(PORT_DIAG_IN, OVT_MEM) ? true : false;
    85cc:	72d8 021e 	lod	A, 0x21e <_PORT_DIAG_IN>

000085d0 <.LM45>:
    {
        IO_SET(PORT_DRV1_PROT, DIS_OVT, 1u);  /* clear MEM flag */
        IO_SET(PORT_DRV1_PROT, DIS_OVT, 0u);  /* re-enable hardware protection */
    }
#endif
    return bRetVal;
    85d0:	b401      	and	A, #1

000085d2 <.LM46>:
}
    85d2:	5401      	ret

000085d4 <_diagnostic_IsVDSPending>:
 */
bool diagnostic_IsVDSPending(void)
{
    bool bRetVal;

    bRetVal = (IO_GET(PORT_DIAG_IN, OV_HS_VDS_MEM) || IO_GET(PORT_DIAG_IN, OV_LS_VDS_MEM)) ? true : false;
    85d4:	72d8 021e 	lod	A, 0x21e <_PORT_DIAG_IN>
    85d8:	b6da 03c0 	and	A, #960
    85dc:	1d06      	jne	0x85ea <.L12>

000085de <.LM53>:
    85de:	72d8 021e 	lod	A, 0x21e <_PORT_DIAG_IN>
    85e2:	b6da 3c00 	and	A, #15360
    85e6:	5ca2      	sne	A
    85e8:	5401      	ret

000085ea <.L12>:
    85ea:	7001      	lod	A, #1

000085ec <.LM55>:

    return bRetVal;
}
    85ec:	5401      	ret

000085ee <__UV_VS_INT>:

/**
 * Under voltage interrupt
 */
INTERRUPT void _UV_VS_INT(void)
{
    85ee:	5edf      	push	X

000085f0 <.LCFI0>:
    85f0:	5adf      	push	Y

000085f2 <.LCFI1>:
    85f2:	52df      	push	A

000085f4 <.LCFI2>:
    85f4:	4c83      	push	D

000085f6 <.LCFI3>:
    /* Disable the interrupt, otherwise the interrupt will be called continuously */
    Itc_Disable(UV_VS);
    85f6:	62d8 006c 	lod	AL, 0x6c <__mlx4_cst_tables_ram_size+0xe>
    85fa:	947f      	and	AL, #127
    85fc:	42d8 006c 	mov	0x6c <__mlx4_cst_tables_ram_size+0xe>, AL

00008600 <.LM58>:

    /* Call application callback (save data to EEPROM, log error, etc) */
    EVENT_UnderVoltage();
    8600:	82db 4c13 	callf	0x9826 <_EVENT_UnderVoltage>

00008604 <.LM59>:
}
    8604:	4cc3      	pop	D

00008606 <.LCFI4>:
    8606:	72cf      	pop	A

00008608 <.LCFI5>:
    8608:	7acf      	pop	Y

0000860a <.LCFI6>:
    860a:	7ecf      	pop	X

0000860c <.LCFI7>:
    860c:	72cb      	pop	M
    860e:	5401      	ret

00008610 <__OV_VS_INT>:

/**
 * Over voltage interrupt
 */
INTERRUPT void _OV_VS_INT(void)
{
    8610:	52df      	push	A

00008612 <.LCFI8>:

    /* Disable the interrupt, otherwise the interrupt will be called continuously */
    Itc_Disable(OV_VS);
    8612:	62d8 0071 	lod	AL, 0x71 <__mlx4_cst_tables_ram_size+0x13>
    8616:	94fb      	and	AL, #-5
    8618:	42d8 0071 	mov	0x71 <__mlx4_cst_tables_ram_size+0x13>, AL

0000861c <.LM62>:

    /* Call application callback (save data to EEPROM, log error, etc) */
    //    EVENT_OverVoltage();
}
    861c:	72cf      	pop	A

0000861e <.LCFI9>:
    861e:	72cb      	pop	M
    8620:	5401      	ret

00008622 <__OVT_INT>:

/**
 * Over Temperature interrupt
 */
INTERRUPT void _OVT_INT(void)
{
    8622:	52df      	push	A

00008624 <.LCFI10>:

    /* Disable the interrupt, otherwise the interrupt will be called continuously */
    Itc_Disable(OVT);
    8624:	62d8 006d 	lod	AL, 0x6d <__mlx4_cst_tables_ram_size+0xf>
    8628:	94fb      	and	AL, #-5
    862a:	42d8 006d 	mov	0x6d <__mlx4_cst_tables_ram_size+0xf>, AL

0000862e <.LM65>:
}
    862e:	72cf      	pop	A

00008630 <.LCFI11>:
    8630:	72cb      	pop	M
    8632:	5401      	ret

00008634 <__OVC_INT>:

/**
 * Over Current interrupt
 */
INTERRUPT void _OVC_INT(void)
{
    8634:	52df      	push	A

00008636 <.LCFI12>:

    /* Disable the interrupt, otherwise the interrupt will be called continuously */
    Itc_Disable(OVC);
    8636:	62d8 006d 	lod	AL, 0x6d <__mlx4_cst_tables_ram_size+0xf>
    863a:	94f7      	and	AL, #-9
    863c:	42d8 006d 	mov	0x6d <__mlx4_cst_tables_ram_size+0xf>, AL

00008640 <.LM68>:
}
    8640:	72cf      	pop	A

00008642 <.LCFI13>:
    8642:	72cb      	pop	M
    8644:	5401      	ret

00008646 <_eeprom_Init>:

/**
 * Module initialization
 */
bool eeprom_Init(void)
{
    8646:	5801      	inc	S, #2

00008648 <.LCFI0>:
    bool retval = true;

    unirom_Init();
    8648:	82db 4f35 	callf	0x9e6a <_unirom_Init>

0000864c <.LM3>:

    if (!unirom_LoadUserConfig())
    864c:	82db 4f36 	callf	0x9e6c <_unirom_LoadUserConfig>
    8650:	7ae2      	lod	Y, A
    8652:	1d06      	jne	0x8660 <.L2>

00008654 <.LM4>:
    {
        (void)unirom_ResetUserConfig(&eeprom_defaults);
    8654:	72da 5d2c 	lod	A, #23852
    8658:	5a01      	mov	[S-2], Y
    865a:	82db 4f93 	callf	0x9f26 <_unirom_ResetUserConfig>
    865e:	7a01      	lod	Y, [S-2]

00008660 <.L2>:

        retval = false;
    }

    return retval;
}
    8660:	72e6      	lod	A, Y
    8662:	5403      	ret	#4

00008664 <_eeprom_ReadLINconfig>:
 * @param[in]  length  the number of configuration words to read
 * @retval  true  valid configuration found in eeprom.
 * @retval  false  otherwise.
 */
bool eeprom_ReadLINconfig(uint8_t *config, uint8_t length)
{
    8664:	6603      	lod	YL, [S-4]
    8666:	5cf6      	usex	Y

00008668 <.LM7>:
    bool retval = false;
    retval = unirom_ReadPage(0u, config, length);
    8668:	5adf      	push	Y

0000866a <.LCFI1>:
    866a:	52df      	push	A

0000866c <.LCFI2>:
    866c:	7000      	lod	A, #0

0000866e <.LVL7>:
    866e:	82db 5006 	callf	0xa00c <_unirom_ReadPage>

00008672 <.LCFI3>:

    return retval;
}
    8672:	5405      	ret	#6

00008674 <_eeprom_ReadValveConfig>:
 * @param[out]  position  the position
 * @retval  true  valid position found in eeprom.
 * @retval  false  otherwise.
 */
bool eeprom_ReadValveConfig(valve_config_t *config)
{
    8674:	5809      	inc	S, #10

00008676 <.LCFI7>:
    8676:	7ae2      	lod	Y, A

00008678 <.LM18>:
    bool retval = false;
    uint8_t bytes[sizeof(valve_config_t)];
    (void)unirom_ReadPage(1u, &bytes[0], sizeof(valve_config_t));
    8678:	54ca 0006 	pushw	#6

0000867c <.LCFI8>:
    867c:	72ef      	lod	A, S

0000867e <.LVL18>:
    867e:	a0f4      	add	A, #-12
    8680:	52df      	push	A

00008682 <.LCFI9>:
    8682:	7001      	lod	A, #1
    8684:	5a07      	mov	[S-8], Y
    8686:	82db 5006 	callf	0xa00c <_unirom_ReadPage>

0000868a <.LM19>:

    config->E1DATA0 = (uint16_t)(bytes[0] + ((uint16_t)bytes[1] << 8));
    868a:	620c      	lod	AL, [S-13]
    868c:	6800      	lod	AH, #0
    868e:	72e4      	swap	A
    8690:	5205      	mov	[S-6], A
    8692:	620d      	lod	AL, [S-14]
    8694:	5cf2      	usex	A
    8696:	7ee2      	lod	X, A
    8698:	7205      	lod	A, [S-6]
    869a:	a2ee      	add	A, X
    869c:	7a07      	lod	Y, [S-8]
    869e:	52f0      	mov	[Y], A

000086a0 <.LM20>:
    config->E1DATA1 = (uint16_t)(bytes[2] + ((uint16_t)bytes[3] << 8));
    86a0:	620a      	lod	AL, [S-11]
    86a2:	6800      	lod	AH, #0
    86a4:	72e4      	swap	A
    86a6:	5205      	mov	[S-6], A
    86a8:	620b      	lod	AL, [S-12]
    86aa:	5cf2      	usex	A
    86ac:	7ee2      	lod	X, A
    86ae:	7205      	lod	A, [S-6]
    86b0:	a2ee      	add	A, X
    86b2:	52f2      	mov	[Y+2], A

000086b4 <.LM21>:
    config->E1DATA2 = (uint16_t)(bytes[4] + ((uint16_t)bytes[5] << 8));
    86b4:	6208      	lod	AL, [S-9]
    86b6:	6800      	lod	AH, #0
    86b8:	72e4      	swap	A
    86ba:	5205      	mov	[S-6], A
    86bc:	6209      	lod	AL, [S-10]
    86be:	5cf2      	usex	A
    86c0:	7ee2      	lod	X, A
    86c2:	7205      	lod	A, [S-6]
    86c4:	a2ee      	add	A, X
    86c6:	52f4      	mov	[Y+4], A

000086c8 <.LM22>:

    retval = true;

    return retval;
}
    86c8:	7001      	lod	A, #1

000086ca <.LCFI10>:
    86ca:	540f      	ret	#16

000086cc <_eeprom_WriteValveConfig>:
 * @param[out]  config  the configuration array to be stored
 * @retval  true  the configuration is correctly stored
 * @retval  false  otherwise
 */
bool eeprom_WriteValveConfig(valve_config_t *config)
{
    86cc:	5805      	inc	S, #6

000086ce <.LCFI11>:
    86ce:	7ee2      	lod	X, A

000086d0 <.LM24>:
    bool retval = true;
    uint8_t bytes[sizeof(valve_config_t)];

    bytes[0] = (uint8_t)((uint16_t)config->E1DATA0 & 0xFF);
    86d0:	7af8      	lod	Y, [X]
    86d2:	4605      	mov	[S-6], YL

000086d4 <.LM25>:
    bytes[1] = (uint8_t)(((uint16_t)config->E1DATA0 >> 8) & 0xFF);
    86d4:	4e04      	mov	[S-5], YH

000086d6 <.LM26>:
    bytes[2] = (uint8_t)((uint16_t)config->E1DATA1 & 0xFF);
    86d6:	7afa      	lod	Y, [X+2]
    86d8:	4603      	mov	[S-4], YL

000086da <.LM27>:
    bytes[3] = (uint8_t)(((uint16_t)config->E1DATA1 >> 8) & 0xFF);
    86da:	4e02      	mov	[S-3], YH

000086dc <.LM28>:
    bytes[4] = (uint8_t)((uint16_t)config->E1DATA2 & 0xFF);
    86dc:	72fc      	lod	A, [X+4]

000086de <.LVL23>:
    86de:	4201      	mov	[S-2], AL

000086e0 <.LM29>:
    bytes[5] = (uint8_t)(((uint16_t)config->E1DATA2 >> 8) & 0xFF);
    86e0:	4a00      	mov	[S-1], AH

000086e2 <.LM30>:

    (void)unirom_WritePage(1u, &bytes[0], sizeof(valve_config_t));
    86e2:	54ca 0006 	pushw	#6

000086e6 <.LCFI12>:
    86e6:	72ef      	lod	A, S
    86e8:	a0f8      	add	A, #-8
    86ea:	52df      	push	A

000086ec <.LCFI13>:
    86ec:	7001      	lod	A, #1
    86ee:	82db 4fcc 	callf	0x9f98 <_unirom_WritePage>

000086f2 <.LM31>:
    return retval;
}
    86f2:	7001      	lod	A, #1

000086f4 <.LCFI14>:
    86f4:	540b      	ret	#12

000086f6 <_eeprom_ReadDiagConfig>:
 *
 * @retval  true  valid position found in eeprom.
 * @retval  false  otherwise.
 */
bool eeprom_ReadDiagConfig(valve_config_t *config)
{
    86f6:	5809      	inc	S, #10

000086f8 <.LCFI15>:
    86f8:	7ae2      	lod	Y, A

000086fa <.LM33>:
    bool retval = false;
    uint8_t bytes[sizeof(valve_config_t)];
    (void)unirom_ReadPage(2u, &bytes[0], sizeof(valve_config_t));
    86fa:	54ca 0006 	pushw	#6

000086fe <.LCFI16>:
    86fe:	72ef      	lod	A, S

00008700 <.LVL27>:
    8700:	a0f4      	add	A, #-12
    8702:	52df      	push	A

00008704 <.LCFI17>:
    8704:	7002      	lod	A, #2
    8706:	5a07      	mov	[S-8], Y
    8708:	82db 5006 	callf	0xa00c <_unirom_ReadPage>

0000870c <.LM34>:

    config->E1DATA0 = (uint16_t)(bytes[0] + ((uint16_t)bytes[1] << 8));
    870c:	620c      	lod	AL, [S-13]
    870e:	6800      	lod	AH, #0
    8710:	72e4      	swap	A
    8712:	5205      	mov	[S-6], A
    8714:	620d      	lod	AL, [S-14]
    8716:	5cf2      	usex	A
    8718:	7ee2      	lod	X, A
    871a:	7205      	lod	A, [S-6]
    871c:	a2ee      	add	A, X
    871e:	7a07      	lod	Y, [S-8]
    8720:	52f0      	mov	[Y], A

00008722 <.LM35>:
    config->E1DATA1 = (uint16_t)(bytes[2] + ((uint16_t)bytes[3] << 8));
    8722:	620a      	lod	AL, [S-11]
    8724:	6800      	lod	AH, #0
    8726:	72e4      	swap	A
    8728:	5205      	mov	[S-6], A
    872a:	620b      	lod	AL, [S-12]
    872c:	5cf2      	usex	A
    872e:	7ee2      	lod	X, A
    8730:	7205      	lod	A, [S-6]
    8732:	a2ee      	add	A, X
    8734:	52f2      	mov	[Y+2], A

00008736 <.LM36>:
    config->E1DATA2 = (uint16_t)(bytes[4] + ((uint16_t)bytes[5] << 8));
    8736:	6208      	lod	AL, [S-9]
    8738:	6800      	lod	AH, #0
    873a:	72e4      	swap	A
    873c:	5205      	mov	[S-6], A
    873e:	6209      	lod	AL, [S-10]
    8740:	5cf2      	usex	A
    8742:	7ee2      	lod	X, A
    8744:	7205      	lod	A, [S-6]
    8746:	a2ee      	add	A, X
    8748:	52f4      	mov	[Y+4], A

0000874a <.LM37>:

    retval = true;

    return retval;
}
    874a:	7001      	lod	A, #1

0000874c <.LCFI18>:
    874c:	540f      	ret	#16

0000874e <_eeprom_WriteDiagConfig>:
bool eeprom_WriteDiagConfig(valve_config_t *config)
{
    874e:	5805      	inc	S, #6

00008750 <.LCFI19>:
    8750:	7ee2      	lod	X, A

00008752 <.LM39>:
    bool retval = true;
    uint8_t bytes[sizeof(valve_config_t)];

    bytes[0] = (uint8_t)((uint16_t)config->E1DATA0 & 0xFF);
    8752:	7af8      	lod	Y, [X]
    8754:	4605      	mov	[S-6], YL

00008756 <.LM40>:
    bytes[1] = (uint8_t)(((uint16_t)config->E1DATA0 >> 8) & 0xFF);
    8756:	4e04      	mov	[S-5], YH

00008758 <.LM41>:
    bytes[2] = (uint8_t)((uint16_t)config->E1DATA1 & 0xFF);
    8758:	7afa      	lod	Y, [X+2]
    875a:	4603      	mov	[S-4], YL

0000875c <.LM42>:
    bytes[3] = (uint8_t)(((uint16_t)config->E1DATA1 >> 8) & 0xFF);
    875c:	4e02      	mov	[S-3], YH

0000875e <.LM43>:
    bytes[4] = (uint8_t)((uint16_t)config->E1DATA2 & 0xFF);
    875e:	72fc      	lod	A, [X+4]

00008760 <.LVL32>:
    8760:	4201      	mov	[S-2], AL

00008762 <.LM44>:
    bytes[5] = (uint8_t)(((uint16_t)config->E1DATA2 >> 8) & 0xFF);
    8762:	4a00      	mov	[S-1], AH

00008764 <.LM45>:

    (void)unirom_WritePage(2u, &bytes[0], sizeof(valve_config_t));
    8764:	54ca 0006 	pushw	#6

00008768 <.LCFI20>:
    8768:	72ef      	lod	A, S
    876a:	a0f8      	add	A, #-8
    876c:	52df      	push	A

0000876e <.LCFI21>:
    876e:	7002      	lod	A, #2
    8770:	82db 4fcc 	callf	0x9f98 <_unirom_WritePage>

00008774 <.LM46>:
    return retval;
}
    8774:	7001      	lod	A, #1

00008776 <.LCFI22>:
    8776:	540b      	ret	#12

00008778 <_valve_gmr_write>:
    {
    }
}
void valve_gmr_write(uint16_t data1, uint16_t data2, uint16_t data3)
{
    valve_gmr_data.E1DATA0 = data1;
    8778:	7eda 1326 	lod	X, #4902
    877c:	52f8      	mov	[X], A

0000877e <.LM55>:
    else
    {
    }
}
void valve_gmr_write(uint16_t data1, uint16_t data2, uint16_t data3)
{
    877e:	7203      	lod	A, [S-4]

00008780 <.LM56>:
    valve_gmr_data.E1DATA0 = data1;
    valve_gmr_data.E1DATA1 = data2;
    8780:	52d8 1328 	mov	0x1328 <.Lframe0>, A

00008784 <.LM57>:
    else
    {
    }
}
void valve_gmr_write(uint16_t data1, uint16_t data2, uint16_t data3)
{
    8784:	7205      	lod	A, [S-6]

00008786 <.LM58>:
    valve_gmr_data.E1DATA0 = data1;
    valve_gmr_data.E1DATA1 = data2;
    valve_gmr_data.E1DATA2 = data3;
    8786:	52d8 132a 	mov	0x132a <.Lframe0+0x2>, A

0000878a <.LM59>:
    (void)eeprom_WriteValveConfig(&valve_gmr_data);
    878a:	72ee      	lod	A, X
    878c:	179f      	call	0x86cc <_eeprom_WriteValveConfig>

0000878e <.LBB6>:
}
void eeprom_StoreUserDataConfig(uint16_t index)
{
    if (index == 1)
    {
        (void)unirom_StorePage(1u);
    878e:	7001      	lod	A, #1
    8790:	76da 4fa8 	jmpf	0x9f50 <_unirom_StorePage>

00008794 <_valve_diag_write>:
    (void)eeprom_WriteValveConfig(&valve_gmr_data);
    eeprom_StoreUserDataConfig(1);
}
void valve_diag_write(uint16_t data1, uint16_t data2, uint16_t data3)
{
    valve_diag_data.E1DATA0 = data1;
    8794:	7eda 1320 	lod	X, #4896
    8798:	52f8      	mov	[X], A

0000879a <.LM64>:
    valve_gmr_data.E1DATA2 = data3;
    (void)eeprom_WriteValveConfig(&valve_gmr_data);
    eeprom_StoreUserDataConfig(1);
}
void valve_diag_write(uint16_t data1, uint16_t data2, uint16_t data3)
{
    879a:	7203      	lod	A, [S-4]

0000879c <.LM65>:
    valve_diag_data.E1DATA0 = data1;
    valve_diag_data.E1DATA1 = data2;
    879c:	52d8 1322 	mov	0x1322 <_valve_diag_data+0x2>, A

000087a0 <.LM66>:
    valve_gmr_data.E1DATA2 = data3;
    (void)eeprom_WriteValveConfig(&valve_gmr_data);
    eeprom_StoreUserDataConfig(1);
}
void valve_diag_write(uint16_t data1, uint16_t data2, uint16_t data3)
{
    87a0:	7205      	lod	A, [S-6]

000087a2 <.LM67>:
    valve_diag_data.E1DATA0 = data1;
    valve_diag_data.E1DATA1 = data2;
    valve_diag_data.E1DATA2 = data3;
    87a2:	52d8 1324 	mov	0x1324 <_valve_diag_data+0x4>, A

000087a6 <.LM68>:
    (void)eeprom_WriteDiagConfig(&valve_diag_data);
    87a6:	72ee      	lod	A, X
    87a8:	17d2      	call	0x874e <_eeprom_WriteDiagConfig>

000087aa <.LBB8>:
    {
        (void)unirom_StorePage(1u);
    }
    else if (index == 2)
    {
        (void)unirom_StorePage(2u);
    87aa:	7002      	lod	A, #2
    87ac:	76da 4fa8 	jmpf	0x9f50 <_unirom_StorePage>

000087b0 <_FILTER_AVG_CalcMovAvg>:
 * @brief add a value in the AVG buffer and calculates the moving average
 * @param a_pHandler The handle (pointer to FILTER_AVG_Object_t structure) to the FILTER_AVG object
 * @param a_u16NewValue A new value to add to the moving-average buffer
 */
void FILTER_AVG_CalcMovAvg(FILTER_AVG_Object_t* const a_pHandler, uint16_t a_u16NewValue)
{
    87b0:	580d      	inc	S, #14

000087b2 <.LCFI1>:
    87b2:	5205      	mov	[S-6], A

000087b4 <.LM13>:
    uint16_t *pu16Element = &a_pHandler->pu16Raw[a_pHandler->u16RawIdx];
    87b4:	7ae2      	lod	Y, A
    87b6:	e00a      	add	Y, #10
    87b8:	72f0      	lod	A, [Y]

000087ba <.LVL5>:
    87ba:	4422      	asl	A
    87bc:	7e05      	lod	X, [S-6]
    87be:	7efe      	lod	X, [X+6]
    87c0:	22e2      	add	X, A
    87c2:	5e07      	mov	[S-8], X

000087c4 <.LM14>:
    a_pHandler->u16RawIdx = (a_pHandler->u16RawIdx + 1u) & (a_pHandler->u16Size - 1u);  /* Increment index */
    87c4:	7e05      	lod	X, [S-6]

000087c6 <.LVL7>:
    87c6:	2008      	add	X, #8
    87c8:	5e0d      	mov	[S-14], X
    87ca:	72f8      	lod	A, [X]
    87cc:	5201      	mov	[S-2], A
    87ce:	a0ff      	add	A, #-1
    87d0:	7ef0      	lod	X, [Y]
    87d2:	2001      	add	X, #1
    87d4:	b6ee      	and	A, X
    87d6:	52f0      	mov	[Y], A

000087d8 <.LM15>:
 * @brief add a value in the AVG buffer and calculates the moving average
 * @param a_pHandler The handle (pointer to FILTER_AVG_Object_t structure) to the FILTER_AVG object
 * @param a_u16NewValue A new value to add to the moving-average buffer
 */
void FILTER_AVG_CalcMovAvg(FILTER_AVG_Object_t* const a_pHandler, uint16_t a_u16NewValue)
{
    87d8:	7211      	lod	A, [S-18]

000087da <.LM16>:
    uint16_t *pu16Element = &a_pHandler->pu16Raw[a_pHandler->u16RawIdx];
    a_pHandler->u16RawIdx = (a_pHandler->u16RawIdx + 1u) & (a_pHandler->u16Size - 1u);  /* Increment index */
    uint16_t u16Oldest = *pu16Element;
    a_pHandler->u32MovAvgxN -= u16Oldest;  /* Subtract oldest raw element */
    a_pHandler->u32MovAvgxN += (uint32_t)a_u16NewValue;  /* Add newest raw element */
    87da:	4cc8      	movu	D, A
    87dc:	7a05      	lod	Y, [S-6]
    87de:	72f2      	lod	A, [Y+2]
    87e0:	7af4      	lod	Y, [Y+4]
    87e2:	4c00      	add	D, YA

000087e4 <.LM17>:
void FILTER_AVG_CalcMovAvg(FILTER_AVG_Object_t* const a_pHandler, uint16_t a_u16NewValue)
{
    uint16_t *pu16Element = &a_pHandler->pu16Raw[a_pHandler->u16RawIdx];
    a_pHandler->u16RawIdx = (a_pHandler->u16RawIdx + 1u) & (a_pHandler->u16Size - 1u);  /* Increment index */
    uint16_t u16Oldest = *pu16Element;
    a_pHandler->u32MovAvgxN -= u16Oldest;  /* Subtract oldest raw element */
    87e4:	7a07      	lod	Y, [S-8]
    87e6:	4ced      	movu	YA, [Y]

000087e8 <.LM18>:
    a_pHandler->u32MovAvgxN += (uint32_t)a_u16NewValue;  /* Add newest raw element */
    87e8:	4c10      	sub	D, YA
    87ea:	7e05      	lod	X, [S-6]
    87ec:	2002      	add	X, #2
    87ee:	4c87      	mov	[X], D

000087f0 <.LM19>:
    *pu16Element = (uint16_t)a_u16NewValue;  /* Overwrite oldest with newest element */
    87f0:	7211      	lod	A, [S-18]

000087f2 <.LVL10>:
    87f2:	7a07      	lod	Y, [S-8]

000087f4 <.LVL11>:
    87f4:	52f0      	mov	[Y], A

000087f6 <.LBB4>:
MATHLIB_INLINE_STATIC __inline__ uint16_t divU16_U32byU16(uint32_t dividend, uint16_t divisor)
{
    uint16_t result;
    uint16_t result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    87f6:	7e0d      	lod	X, [S-14]
    87f8:	7ef8      	lod	X, [X]
    87fa:	5e07      	mov	[S-8], X
    87fc:	4c80      	mov	YA, D
    87fe:	4c63      	divu	YA, X
    8800:	4c63      	divu	YA, X

00008802 <.LBE4>:
    a_pHandler->u16MovAvg = divU16_U32byU16(a_pHandler->u32MovAvgxN, a_pHandler->u16Size);
    8802:	7a05      	lod	Y, [S-6]
    8804:	52f0      	mov	[Y], A

00008806 <.LM22>:
}
    8806:	540f      	ret	#16

00008808 <_Generic_INT>:
}

#ifndef HAS_SW_EXPLICIT_FAIL_INFO
/* Generic interrupt handler */
WEAK_INTERRUPT void Generic_INT(void)
{
    8808:	5edf      	push	X

0000880a <.LCFI0>:
    880a:	5adf      	push	Y

0000880c <.LCFI1>:
    880c:	52df      	push	A

0000880e <.LCFI2>:
    880e:	4c83      	push	D

00008810 <.LBB8>:
}

STATIC INLINE void ErrH_FatalInformed(ErrH_Identifier information)
{
    UNUSED(information);
    _fatal();
    8810:	82db 1b23 	callf	0x3646 <__fatal>

00008814 <_fw_mls_ErrorDetected>:

    plinEventTable->ldt_ErrorDetected = fw_mls_ErrorDetected;
}

void fw_mls_ErrorDetected(ml_LinError_t error)
{
    8814:	5803      	inc	S, #4

00008816 <.LCFI0>:
    8816:	5203      	mov	[S-4], A

00008818 <.LBB76>:
    for (uint8_t cnt = 0; cnt < ld_ErrorDetectedMultipleHandler.eventsCount; cnt++) {
    8818:	62d8 13d1 	lod	AL, 0x13d1 <.LLST14+0x2>

0000881c <.LVL2>:
    881c:	1915      	je	0x8848 <.L2>
    881e:	7000      	lod	A, #0
    8820:	5201      	mov	[S-2], A

00008822 <.L3>:
        ld_ErrorDetectedMultipleHandler.eventHandlerBuffer[cnt](error);
    8822:	7201      	lod	A, [S-2]
    8824:	4422      	asl	A
    8826:	7ed8 13ce 	lod	X, 0x13ce <_ld_ErrorDetectedMultipleHandler>
    882a:	22e2      	add	X, A
    882c:	7203      	lod	A, [S-4]
    882e:	7af8      	lod	Y, [X]
    8830:	0001      	jmp	0x8834 <.L13>

00008832 <.L12>:
    8832:	76e6      	jmp	Y

00008834 <.L13>:
    8834:	17fe      	call	0x8832 <.L12>

00008836 <.LM4>:
    plinEventTable->ldt_ErrorDetected = fw_mls_ErrorDetected;
}

void fw_mls_ErrorDetected(ml_LinError_t error)
{
    for (uint8_t cnt = 0; cnt < ld_ErrorDetectedMultipleHandler.eventsCount; cnt++) {
    8836:	6201      	lod	AL, [S-2]
    8838:	8001      	add	AL, #1
    883a:	66e0      	lod	YL, AL

0000883c <.LVL5>:
    883c:	5cf2      	usex	A

0000883e <.LVL6>:
    883e:	5201      	mov	[S-2], A
    8840:	62d8 13d1 	lod	AL, 0x13d1 <.LLST14+0x2>
    8844:	8ee8      	cmp	AL, YL
    8846:	1e6d      	jug	0x8822 <.L3>

00008848 <.L2>:
        ld_ErrorDetectedMultipleHandler.eventHandlerBuffer[cnt](error);
    }
	if (g_u8LinErrorCnt < 0xFFu)
    8848:	62d8 1187 	lod	AL, 0x1187 <_g_u8LinErrorCnt>
    884c:	66e0      	lod	YL, AL
    884e:	5cf6      	usex	Y
    8850:	eeda 00ff 	cmp	Y, #255
    8854:	1903      	je	0x885c <.L4>

00008856 <.LM6>:
	{
		g_u8LinErrorCnt++;
    8856:	8001      	add	AL, #1
    8858:	42d8 1187 	mov	0x1187 <_g_u8LinErrorCnt>, AL

0000885c <.L4>:
	}
	g_u8LinErrorCode=error;
    885c:	6603      	lod	YL, [S-4]
    885e:	46d8 1186 	mov	0x1186 <_g_u8LinErrorCode>, YL

00008862 <.LM8>:
}
    8862:	5405      	ret	#6

00008864 <_fw_mls_Init>:
#include "io.h"

/** Set the MLX4 clock divider on top of MLX16 clock */
STATIC INLINE void mls_SetMlx4ClockDivider(void)
{
    IO_SET(COLIN, SPEED, (uint16_t)LIN_CLK_DIV);
    8864:	62d8 01bc 	lod	AL, 0x1bc <.LASF1352+0x7>
    8868:	94f8      	and	AL, #-8
    886a:	42d8 01bc 	mov	0x1bc <.LASF1352+0x7>, AL

0000886e <.LBE77>:

void fw_mls_Init(void)
{
    mls_SetMlx4ClockDivider();
#if ML_HAS_LIN_EVENT_TABLE_IN_RAM == 0
    ml_InitLinEventTable(&fwlinEventTable);
    886e:	72da 1168 	lod	A, #4456
    8872:	82db 20b9 	callf	0x4172 <_ml_InitLinEventTable>

00008876 <.LM12>:
#endif /* ML_HAS_LIN_EVENT_TABLE_IN_RAM == 0 */

    /* Initialize LIN TL */
    ld_RequestMultipleHandler.eventHandlerBuffer = ld_RequestMHBuffer;
    8876:	72da 1162 	lod	A, #4450
    887a:	0ea7      	lod	C, ML.7
    887c:	52d8 13c6 	mov	0x13c6 <_ld_RequestMultipleHandler>, A

00008880 <.LM13>:
    ld_RequestMultipleHandler.eventsMaxLength = MLS_TL_MAX_NUMBER_OF_SUBSCRIBERS;
    8880:	7003      	lod	A, #3
    8882:	52d8 13c8 	mov	0x13c8 <_ld_RequestMultipleHandler+0x2>, A

00008886 <.LM14>:
    ld_RequestMultipleHandler.eventsCount = 0u;
    ld_ResponseTransmittedMultipleHandler.eventHandlerBuffer = ld_ResponseTransmittedMHBuffer;
    8886:	0ea7      	lod	C, ML.7
    8888:	7eda 115c 	lod	X, #4444
    888c:	5ed8 13c2 	mov	0x13c2 <_ld_ResponseTransmittedMultipleHandler>, X

00008890 <.LM15>:
    ld_ResponseTransmittedMultipleHandler.eventsMaxLength = MLS_TL_MAX_NUMBER_OF_SUBSCRIBERS;
    8890:	52d8 13c4 	mov	0x13c4 <_ld_ResponseTransmittedMultipleHandler+0x2>, A

00008894 <.LM16>:
    ld_ResponseTransmittedMultipleHandler.eventsCount = 0u;
    ld_FunctionalRequestMultipleHandler.eventHandlerBuffer = ld_FunctionalRequestMHBuffer;
    8894:	0ea7      	lod	C, ML.7
    8896:	7eda 1156 	lod	X, #4438
    889a:	5ed8 13ca 	mov	0x13ca <_ld_FunctionalRequestMultipleHandler>, X

0000889e <.LM17>:
    ld_FunctionalRequestMultipleHandler.eventsMaxLength = MLS_TL_MAX_NUMBER_OF_SUBSCRIBERS;
    889e:	52d8 13cc 	mov	0x13cc <_ld_FunctionalRequestMultipleHandler+0x2>, A

000088a2 <.LM18>:
    ld_FunctionalRequestMultipleHandler.eventsCount = 0u;
    ld_ErrorDetectedMultipleHandler.eventHandlerBuffer = ld_ErrorDetectedMHBuffer;
    88a2:	0ea7      	lod	C, ML.7
    88a4:	7eda 1150 	lod	X, #4432
    88a8:	5ed8 13ce 	mov	0x13ce <_ld_ErrorDetectedMultipleHandler>, X

000088ac <.LM19>:
    ld_ErrorDetectedMultipleHandler.eventsMaxLength = MLS_TL_MAX_NUMBER_OF_SUBSCRIBERS;
    88ac:	52d8 13d0 	mov	0x13d0 <.LLST14+0x1>, A

000088b0 <.LM20>:
    ld_ErrorDetectedMultipleHandler.eventsCount = 0u;

    Itc_Clear(COLIN_LIN);
    88b0:	0ea7      	lod	C, ML.7
    88b2:	6002      	lod	AL, #2
    88b4:	42d8 0055 	mov	0x55 <.Lframe0+0x1>, AL

000088b8 <.LM21>:
    Itc_SetPrio(COLIN_LIN, MLS_IRQ_PRIO);
    88b8:	62d8 008d 	lod	AL, 0x8d <.LASF1529+0x1>
    88bc:	94f3      	and	AL, #-13
    88be:	8408      	or	AL, #8
    88c0:	42d8 008d 	mov	0x8d <.LASF1529+0x1>, AL

000088c4 <.LM22>:
    Itc_Enable(COLIN_LIN);
    88c4:	62d8 0071 	lod	AL, 0x71 <__mlx4_cst_tables_ram_size+0x13>
    88c8:	8402      	or	AL, #2
    88ca:	42d8 0071 	mov	0x71 <__mlx4_cst_tables_ram_size+0x13>, AL

000088ce <.LM23>:
}
    88ce:	5401      	ret

000088d0 <_fw_mls_TransportLayerInit>:

void fw_mls_TransportLayerInit(void)
{
    ldt_Init(&ldt_TL_data,
    88d0:	54ca 13ca 	pushw	#5066

000088d4 <.LCFI1>:
    88d4:	54ca 13c2 	pushw	#5058

000088d8 <.LCFI2>:
    88d8:	54ca 13c6 	pushw	#5062

000088dc <.LCFI3>:
    88dc:	0ea7      	lod	C, ML.7
    88de:	54ca 0000 	pushw	#0

000088e2 <.LCFI4>:
    88e2:	72da 132c 	lod	A, #4908
    88e6:	82db 1fb0 	callf	0x3f60 <_ldt_Init>

000088ea <.LM26>:

#if FW_LIN_TL_FUNCTIONAL_NAD_FIX == 1
    (void)ldt_SubscribeMultipleHandler(plinEventTable->ldt_ResponseTransmitted, fw_mls_ldt_CustomResponseTransmitted);
#endif

    plinEventTable->ldt_ErrorDetected = fw_mls_ErrorDetected;
    88ea:	7ed8 1002 	lod	X, 0x1002 <_plinEventTable>
    88ee:	2016      	add	X, #22
    88f0:	72da 440a 	lod	A, #17418
    88f4:	52f8      	mov	[X], A

000088f6 <.LCFI5>:
}
    88f6:	5409      	ret	#10

000088f8 <__COLIN_LIN_INT>:
#endif /* FW_LIN_TL_FUNCTIONAL_NAD_FIX */

/** LIN interrupt handler
 */
__attribute__((interrupt)) void _COLIN_LIN_INT(void)
{
    88f8:	5edf      	push	X

000088fa <.LCFI6>:
    88fa:	5adf      	push	Y

000088fc <.LCFI7>:
    88fc:	52df      	push	A

000088fe <.LCFI8>:
    88fe:	4c83      	push	D

00008900 <.LCFI9>:
    ml_LinInterruptHandler();
    8900:	82db 20d0 	callf	0x41a0 <_ml_LinInterruptHandler>

00008904 <.LM30>:
}
    8904:	4cc3      	pop	D

00008906 <.LCFI10>:
    8906:	72cf      	pop	A

00008908 <.LCFI11>:
    8908:	7acf      	pop	Y

0000890a <.LCFI12>:
    890a:	7ecf      	pop	X

0000890c <.LCFI13>:
    890c:	72cb      	pop	M
    890e:	5401      	ret

00008910 <_fw_lepm_ResponseTransmitted>:
STATIC bool fw_lepm_ResponseTransmitted(LINDiagTransfer_t* transfer)
{
    (void)transfer;

#if HAS_PPM_EPM == 1
    if (lepmFlag == true) {
    8910:	62d8 1188 	lod	AL, 0x1188 <_lepmFlag>

00008914 <.LVL1>:
    8914:	1904      	je	0x891e <.L2>

00008916 <.LM3>:
        MLX16_RESET_SIGNED((uint16_t)C_CHIP_STATE_PPM_CMD_EPM);
    8916:	72da b065 	lod	A, #45157
    891a:	82db 1503 	callf	0x2a06 <_MLX16_RESET_SIGNED>

0000891e <.L2>:
    891e:	62d8 1189 	lod	AL, 0x1189 <_isAwaitingResponseTransmitted>
    8922:	5cf2      	usex	A

00008924 <.LM4>:
        return true;
    } else {
        /* The event is intended for the next LIN TL subscribers */
        return false;
    }
}
    8924:	5401      	ret

00008926 <_fw_lepm_Init>:
}

void fw_lepm_Init(void)
{
    /* LIN TL */
    (void)ldt_SubscribeMultipleHandler(&ld_RequestMultipleHandler, fw_lepm_Request);
    8926:	54ca 44a3 	pushw	#17571

0000892a <.LCFI0>:
    892a:	72da 13c6 	lod	A, #5062
    892e:	82db 2005 	callf	0x400a <_ldt_SubscribeMultipleHandler>

00008932 <.LM7>:
    (void)ldt_SubscribeMultipleHandler(&ld_ResponseTransmittedMultipleHandler, fw_lepm_ResponseTransmitted);
    8932:	54ca 4488 	pushw	#17544

00008936 <.LCFI1>:
    8936:	72da 13c2 	lod	A, #5058
    893a:	82db 2005 	callf	0x400a <_ldt_SubscribeMultipleHandler>

0000893e <.LM8>:

    /* LIN EPM specific */
#if HAS_PPM_EPM == 1
    lepmFlag = false;
    893e:	6000      	lod	AL, #0
    8940:	42d8 1188 	mov	0x1188 <_lepmFlag>, AL

00008944 <.LCFI2>:
#endif
}
    8944:	5405      	ret	#6

00008946 <_fw_lepm_Request>:
    /* Always allow enter programming mode by default */
    return true;
}

STATIC bool fw_lepm_Request(LINDiagTransfer_t* transfer)
{
    8946:	5807      	inc	S, #8

00008948 <.LCFI3>:
    8948:	5205      	mov	[S-6], A

0000894a <.LM13>:
     *   returns PLTF_VERSION + TYPE
     *
     * - Read by ID=LE_MLX_PATCH_ID, LE_MLX_SUPPLIER_ID, LE_MLX_FUNCTION_ID_GET_CHIP_VERSION (no broadcasts supported);
     *   returns patch identification
     */
    if (transfer->request.reqSId == LE_READ_BY_ID_SID) {
    894a:	7ae2      	lod	Y, A
    894c:	62f0      	lod	AL, [Y]

0000894e <.LVL7>:
    894e:	8cb2      	cmp	AL, #-78
    8950:	1902      	je	0x8956 <.L6>

00008952 <.L25>:
    return true;
}

STATIC bool fw_lepm_Request(LINDiagTransfer_t* transfer)
{
    bool isAnswerExpected = false;
    8952:	7000      	lod	A, #0
    8954:	0055      	jmp	0x8a00 <.L7>

00008956 <.L6>:
     *
     * - Read by ID=LE_MLX_PATCH_ID, LE_MLX_SUPPLIER_ID, LE_MLX_FUNCTION_ID_GET_CHIP_VERSION (no broadcasts supported);
     *   returns patch identification
     */
    if (transfer->request.reqSId == LE_READ_BY_ID_SID) {
        if (transfer->request.dataLen <= LE_MIN_RBI_DATA_LEN) {
    8956:	7e05      	lod	X, [S-6]
    8958:	72fa      	lod	A, [X+2]
    895a:	ac05      	cmp	A, #5
    895c:	1e7a      	jug	0x8952 <.L25>

0000895e <.LBB20>:

            fw_lepm_ReadByIdProdIdReq_t* pProdIdReq = (fw_lepm_ReadByIdProdIdReq_t*)transfer->request.data;

            if ((pProdIdReq->supp_id == LE_MLX_SUPPLIER_ID)) {
    895e:	7aee      	lod	Y, X

00008960 <.LVL11>:
    8960:	e005      	add	Y, #5
    8962:	7ee6      	lod	X, Y
    8964:	66f8      	lod	YL, [X]
    8966:	6ef9      	lod	YH, [X+1]
    8968:	ec13      	cmp	Y, #19
    896a:	1d73      	jne	0x8952 <.L25>

0000896c <.LM17>:
                switch (pProdIdReq->id) {
    896c:	7a05      	lod	Y, [S-6]
    896e:	62f4      	lod	AL, [Y+4]
    8970:	8c34      	cmp	AL, #52
    8972:	1d01      	jne	0x8976 <.LASF1042+0x7>
    8974:	0048      	jmp	0x8a06 <.L9>
    8976:	66e0      	lod	YL, AL
    8978:	5cf6      	usex	Y
    897a:	ec35      	cmp	Y, #53
    897c:	1d01      	jne	0x8980 <.LASF1619+0x5>
    897e:	005a      	jmp	0x8a34 <.L10>
    8980:	ec33      	cmp	Y, #51
    8982:	1d67      	jne	0x8952 <.L25>

00008984 <.LM18>:
                    case LE_MLX_SPECIAL_ID:
                        if ((pProdIdReq->func_id == LE_MLX_FUNCTION_ID_GET_CHIP_VERSION)
    8984:	7a05      	lod	Y, [S-6]
    8986:	e007      	add	Y, #7
    8988:	62f0      	lod	AL, [Y]
    898a:	6af1      	lod	AH, [Y+1]
    898c:	94bf      	and	AL, #-65
    898e:	aeda cabc 	cmp	A, #51900
    8992:	1d17      	jne	0x89c2 <.L12>

00008994 <.LBB21>:
}

STATIC void fw_lepm_PrepareProdResponse(LINDiagTransfer_t* transfer)
{
    /* Use Response SID */
    transfer->response.respSId = LE_READ_BY_ID_RSID;
    8994:	72da 00f2 	lod	A, #242
    8998:	7e05      	lod	X, [S-6]
    899a:	42f8      	mov	[X], AL

0000899c <.LM20>:
    transfer->response.dataLen = 5u;
    899c:	7005      	lod	A, #5
    899e:	52fa      	mov	[X+2], A

000089a0 <.LM21>:

    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_ProdIdRes_t* pDeviceVerRev = (fw_lepm_ProdIdRes_t*)transfer->response.data;
    pDeviceVerRev->prod_id_low = (uint16_t)PRODUCT_VERSION_32;
    89a0:	72d8 0a36 	lod	A, 0xa36 <.LASF1604+0x8>
    89a4:	6400      	lod	YL, #0
    89a6:	42fc      	mov	[X+4], AL
    89a8:	4afd      	mov	[X+5], AH

000089aa <.LM22>:
    pDeviceVerRev->prod_id_high = (uint16_t)(PRODUCT_VERSION_32 >> 16);
    89aa:	72ee      	lod	A, X
    89ac:	a006      	add	A, #6
    89ae:	7ee2      	lod	X, A
    89b0:	46f8      	mov	[X], YL

000089b2 <.LVL15>:
    89b2:	46f9      	mov	[X+1], YL

000089b4 <.LM23>:
    pDeviceVerRev->reserved = 0xFFu; /* it's reserved */
    89b4:	7e05      	lod	X, [S-6]
    89b6:	2008      	add	X, #8
    89b8:	72da 00ff 	lod	A, #255

000089bc <.L27>:
    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_PltfRevRes_t* pPltfRevResp = (fw_lepm_PltfRevRes_t*)transfer->response.data;
    pPltfRevResp->major = RELEASE_MAJOR;
    pPltfRevResp->minor = RELEASE_MINOR;
    pPltfRevResp->patch = RELEASE_REVISION;
    pPltfRevResp->build = 0x00u;
    89bc:	42f8      	mov	[X], AL

000089be <.L26>:
                    case LE_MLX_PATCH_ID:
                        if ((pProdIdReq->func_id == LE_MLX_FUNCTION_ID_GET_CHIP_VERSION)
                            || (pProdIdReq->func_id ==
                                fw_lepm_GetFuncIdAllModes(LE_MLX_FUNCTION_ID_GET_CHIP_VERSION))) {
                            fw_lepm_PreparePatchRevResponse(transfer);
                            isAnswerExpected = true;
    89be:	7001      	lod	A, #1
    89c0:	001f      	jmp	0x8a00 <.L7>

000089c2 <.L12>:
                                fw_lepm_GetFuncIdAllModes(LE_MLX_FUNCTION_ID_GET_CHIP_VERSION))) {
                            /* Prepare response with product identifiers */
                            fw_lepm_PrepareProdResponse(transfer);
                            isAnswerExpected = true;
#if HAS_PPM_EPM == 1
                        } else if ((pProdIdReq->func_id == LE_MLX_FUNCTION_ID_ENTER_PPM_MODE)
    89c2:	aeda cabd 	cmp	A, #51901
    89c6:	1d45      	jne	0x8952 <.L25>

000089c8 <.LM27>:
                                   || (pProdIdReq->func_id ==
                                       fw_lepm_GetFuncIdAllModes(LE_MLX_FUNCTION_ID_ENTER_PPM_MODE))) {
                            if (fw_lepm_ApplicationStop()) {
    89c8:	11e0      	call	0x8d8a <_fw_lepm_ApplicationStop>
    89ca:	ac00      	cmp	A, #0
    89cc:	1942      	je	0x8952 <.L25>

000089ce <.LM28>:
                                /* Set PPM mode flag */
                                lepmFlag = true;
    89ce:	6401      	lod	YL, #1
    89d0:	46d8 1188 	mov	0x1188 <_lepmFlag>, YL

000089d4 <.LBB26>:
}

STATIC void fw_lepm_PrepareProdResponse(LINDiagTransfer_t* transfer)
{
    /* Use Response SID */
    transfer->response.respSId = LE_READ_BY_ID_RSID;
    89d4:	7ada 00f2 	lod	Y, #242
    89d8:	7e05      	lod	X, [S-6]
    89da:	46f8      	mov	[X], YL

000089dc <.LM30>:
    transfer->response.dataLen = 5u;
    89dc:	7805      	lod	Y, #5
    89de:	5afa      	mov	[X+2], Y

000089e0 <.LM31>:

    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_ProdIdRes_t* pDeviceVerRev = (fw_lepm_ProdIdRes_t*)transfer->response.data;
    pDeviceVerRev->prod_id_low = (uint16_t)PRODUCT_VERSION_32;
    89e0:	7ad8 0a36 	lod	Y, 0xa36 <.LASF1604+0x8>
    89e4:	46fc      	mov	[X+4], YL
    89e6:	4efd      	mov	[X+5], YH

000089e8 <.LM32>:
    pDeviceVerRev->prod_id_high = (uint16_t)(PRODUCT_VERSION_32 >> 16);
    89e8:	7aee      	lod	Y, X
    89ea:	e006      	add	Y, #6
    89ec:	5a03      	mov	[S-4], Y
    89ee:	6400      	lod	YL, #0
    89f0:	7e03      	lod	X, [S-4]
    89f2:	46f8      	mov	[X], YL

000089f4 <.LVL21>:
    89f4:	7e03      	lod	X, [S-4]
    89f6:	46f9      	mov	[X+1], YL

000089f8 <.LM33>:
    pDeviceVerRev->reserved = 0xFFu; /* it's reserved */
    89f8:	7e05      	lod	X, [S-6]
    89fa:	2008      	add	X, #8
    89fc:	64ff      	lod	YL, #-1
    89fe:	46f8      	mov	[X], YL

00008a00 <.L7>:
        /* ignore other diagnostic messages */
    }

    /* If MLS device ID response is prepared then it's true;
     * in the case of new application specific request after - it's false */
    isAwaitingResponseTransmitted = isAnswerExpected;
    8a00:	42d8 1189 	mov	0x1189 <_isAwaitingResponseTransmitted>, AL

00008a04 <.LM35>:
    return isAnswerExpected;
}
    8a04:	5409      	ret	#10

00008a06 <.L9>:
                            /* ignore unknown Function ID value */
                        }
                        break;

                    case LE_MLX_PLTF_ID:
                        if ((pProdIdReq->func_id == LE_MLX_FUNCTION_ID_GET_CHIP_VERSION)
    8a06:	7a05      	lod	Y, [S-6]
    8a08:	e007      	add	Y, #7
    8a0a:	62f0      	lod	AL, [Y]
    8a0c:	6af1      	lod	AH, [Y+1]
    8a0e:	94bf      	and	AL, #-65
    8a10:	aeda cabc 	cmp	A, #51900
    8a14:	1901      	je	0x8a18 <.LM37>
    8a16:	079d      	jmp	0x8952 <.L25>

00008a18 <.LM37>:
}

STATIC void fw_lepm_PreparePltfRevResponse(LINDiagTransfer_t* transfer)
{
    /* Use Response SID */
    transfer->response.respSId = LE_READ_BY_ID_RSID;
    8a18:	72da 00f2 	lod	A, #242
    8a1c:	7a05      	lod	Y, [S-6]
    8a1e:	42f0      	mov	[Y], AL

00008a20 <.LM38>:
    transfer->response.dataLen = LE_PLTF_REV_RES_DATA_LENGTH;
    8a20:	7005      	lod	A, #5
    8a22:	52f2      	mov	[Y+2], A
    8a24:	7ada 0101 	lod	Y, #257
    8a28:	7e05      	lod	X, [S-6]
    8a2a:	5afc      	mov	[X+4], Y

00008a2c <.LM39>:

    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_PltfRevRes_t* pPltfRevResp = (fw_lepm_PltfRevRes_t*)transfer->response.data;
    pPltfRevResp->major = RELEASE_MAJOR;
    pPltfRevResp->minor = RELEASE_MINOR;
    8a2c:	7804      	lod	Y, #4
    8a2e:	5afe      	mov	[X+6], Y

00008a30 <.LM40>:
    pPltfRevResp->patch = RELEASE_REVISION;
    pPltfRevResp->build = 0x00u;
    8a30:	2008      	add	X, #8
    8a32:	07c4      	jmp	0x89bc <.L27>

00008a34 <.L10>:
                            /* ignore unknown Function ID value */
                        }
                        break;

                    case LE_MLX_PATCH_ID:
                        if ((pProdIdReq->func_id == LE_MLX_FUNCTION_ID_GET_CHIP_VERSION)
    8a34:	7a05      	lod	Y, [S-6]
    8a36:	e007      	add	Y, #7
    8a38:	62f0      	lod	AL, [Y]
    8a3a:	6af1      	lod	AH, [Y+1]
    8a3c:	94bf      	and	AL, #-65
    8a3e:	aeda cabc 	cmp	A, #51900
    8a42:	1901      	je	0x8a46 <.LBB29>
    8a44:	0786      	jmp	0x8952 <.L25>

00008a46 <.LBB29>:
}

STATIC void fw_lepm_PreparePatchRevResponse(LINDiagTransfer_t* transfer)
{
    /* Use Response SID */
    transfer->response.respSId = LE_READ_BY_ID_RSID;
    8a46:	72da 00f2 	lod	A, #242
    8a4a:	7a05      	lod	Y, [S-6]
    8a4c:	42f0      	mov	[Y], AL

00008a4e <.LM43>:
    transfer->response.dataLen = LE_PATCH_REV_RES_DATA_LENGTH;
    8a4e:	7002      	lod	A, #2
    8a50:	52f2      	mov	[Y+2], A

00008a52 <.LM44>:

    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_PatchRevRes_t* pPatchRevResp = (fw_lepm_PatchRevRes_t*)transfer->response.data;

    /* Return patch identifier only when patch is enabled by ROM */
    if (((IO_GET(MLX16, DBG_CONTROL0) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
    8a52:	72d8 0042 	lod	A, 0x42 <.LLST12+0x6>
    8a56:	d43f      	and	AH, #63
    8a58:	aeda 0410 	cmp	A, #1040
    8a5c:	190c      	je	0x8a76 <.L13>

00008a5e <.LM45>:
        ((IO_GET(MLX16, DBG_CONTROL1) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
    8a5e:	72d8 0046 	lod	A, 0x46 <.LLST12+0xa>
    8a62:	d43f      	and	AH, #63

00008a64 <.LM46>:

    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_PatchRevRes_t* pPatchRevResp = (fw_lepm_PatchRevRes_t*)transfer->response.data;

    /* Return patch identifier only when patch is enabled by ROM */
    if (((IO_GET(MLX16, DBG_CONTROL0) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
    8a64:	aeda 0410 	cmp	A, #1040
    8a68:	1906      	je	0x8a76 <.L13>

00008a6a <.LM47>:
        ((IO_GET(MLX16, DBG_CONTROL1) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
        ((IO_GET(MLX16, DBG_CONTROL2) & 0x3FFFu) == PATCH_CTRL_ENABLE)) {
    8a6a:	72d8 004a 	lod	A, 0x4a <.LLST12+0xe>
    8a6e:	d43f      	and	AH, #63

00008a70 <.LM48>:
    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_PatchRevRes_t* pPatchRevResp = (fw_lepm_PatchRevRes_t*)transfer->response.data;

    /* Return patch identifier only when patch is enabled by ROM */
    if (((IO_GET(MLX16, DBG_CONTROL0) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
        ((IO_GET(MLX16, DBG_CONTROL1) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
    8a70:	aeda 0410 	cmp	A, #1040
    8a74:	1d07      	jne	0x8a84 <.L14>

00008a76 <.L13>:
        ((IO_GET(MLX16, DBG_CONTROL2) & 0x3FFFu) == PATCH_CTRL_ENABLE)) {
        pPatchRevResp->identifier = EE_HOST(PATCH_CRC);
    8a76:	7300      	lod	A, ep:0x0 <__bss_dp_size>
    8a78:	7e05      	lod	X, [S-6]
    8a7a:	42fc      	mov	[X+4], AL
    8a7c:	6000      	lod	AL, #0
    8a7e:	72e4      	swap	A
    8a80:	42fd      	mov	[X+5], AL
    8a82:	079d      	jmp	0x89be <.L26>

00008a84 <.L14>:
    } else {
        pPatchRevResp->identifier = 0xFFFFu;
    8a84:	7e05      	lod	X, [S-6]
    8a86:	2004      	add	X, #4
    8a88:	60ff      	lod	AL, #-1
    8a8a:	42f8      	mov	[X], AL

00008a8c <.LVL32>:
    8a8c:	42f9      	mov	[X+1], AL
    8a8e:	0797      	jmp	0x89be <.L26>

00008a90 <_fw_low_level_init>:
    builtin_mlx16_set_priority(7);  /* system mode, the lowest priority: 7 */
}

void fw_low_level_init(void)
{
    if (nvram_CalcCRC((uint16_t*)EE_APP_TRIM_AREA_START, EE_APP_TRIM_AREA_SIZE >> 1) == NVRAM_CORRECT_CRC) {
    8a90:	54ca 0028 	pushw	#40

00008a94 <.LCFI0>:
    8a94:	72da 09b0 	lod	A, #2480
    8a98:	82db 1511 	callf	0x2a22 <_nvram_CalcCRC>
    8a9c:	5c01      	dec	S, #2

00008a9e <.LCFI1>:
    8a9e:	aeda 00ff 	cmp	A, #255
    8aa2:	1901      	je	0x8aa6 <.LM3>
    8aa4:	004f      	jmp	0x8b44 <.L2>

00008aa6 <.LM3>:
        /* load trimming data to io registers */
        IO_SET(TRIM1_DRV,
    8aa6:	72d8 0208 	lod	A, 0x208 <_TRIM1_DRV>
    8aaa:	b6da f000 	and	A, #61440
    8aae:	7ed8 09ec 	lod	X, 0x9ec <.LASF1746+0x3>
    8ab2:	3403      	and	X, #3
    8ab4:	a6ee      	or	A, X
    8ab6:	7ed8 09ec 	lod	X, 0x9ec <.LASF1746+0x3>
    8aba:	36da 0ffc 	and	X, #4092
    8abe:	a6ee      	or	A, X
    8ac0:	52d8 0208 	mov	0x208 <_TRIM1_DRV>, A

00008ac4 <.LM4>:
               TRIM_DRVSUP, EE_GET(TRIM_DRVSUP),             /* trim output level of driver supply */
               PRE_TRIM_DRVMOD_CPCLK, EE_GET(TRIM_CPCLK));   /* trim frequency of driver clock */
        IO_SET(TRIM2_DRV,
    8ac4:	72d8 020a 	lod	A, 0x20a <_TRIM2_DRV>
    8ac8:	b6da fe00 	and	A, #65024
    8acc:	0ea7      	lod	C, ML.7
    8ace:	7ed8 09ee 	lod	X, 0x9ee <.LASF1746+0x5>
    8ad2:	340f      	and	X, #15
    8ad4:	a6ee      	or	A, X
    8ad6:	7ed8 09ee 	lod	X, 0x9ee <.LASF1746+0x5>
    8ada:	36da 01f0 	and	X, #496
    8ade:	a6ee      	or	A, X
    8ae0:	52d8 020a 	mov	0x20a <_TRIM2_DRV>, A

00008ae4 <.LM5>:
               TRIM_SLWRT, EE_GET(TRIM_SLWRT),               /* trim slewrate / slope of drivers */
               TRIM_CSA_GAIN, EE_GET(TRIM_CSA_GAIN));        /* trim gain of current sense amplifier */
        IO_SET(TRIM3_DRV,
    8ae4:	62d8 09f1 	lod	AL, 0x9f1 <.LASF1746+0x8>
    8ae8:	42d8 020c 	mov	0x20c <_TRIM3_DRV>, AL

00008aec <.LM6>:
               TRIM_CSA_CL, EE_GET(TRIM_CSA_CL_LOW));        /* trim over-current limit of current sense amplifier */
        IO_SET(TRIM_MISC,
    8aec:	0ea7      	lod	C, ML.7
    8aee:	72d8 0206 	lod	A, 0x206 <_TRIM_MISC>
    8af2:	b6da c000 	and	A, #49152
    8af6:	7ed8 09f2 	lod	X, 0x9f2 <.LASF1746+0x9>
    8afa:	0ea7      	lod	C, ML.7
    8afc:	36da 0fc0 	and	X, #4032
    8b00:	a6ee      	or	A, X
    8b02:	7ed8 09f2 	lod	X, 0x9f2 <.LASF1746+0x9>
    8b06:	36da 3000 	and	X, #12288
    8b0a:	a6ee      	or	A, X
    8b0c:	7ad8 09d0 	lod	Y, 0x9d0 <.LASF2002+0x8>
    8b10:	7ae8      	swap	Y
    8b12:	f43f      	and	Y, #63
    8b14:	a6e6      	or	A, Y
    8b16:	52d8 0206 	mov	0x206 <_TRIM_MISC>, A

00008b1a <.LM7>:
               TRIM_OTD, EE_GET(TRIM_OTD),                   /* trim over temperature detection */
               TRIM_SDAFILT_IO, EE_GET(TRIM_SDAFILT_IO),     /* trim i2c sda filter/delay time */
               TRIM_LCD_LINAA, EE_GET(LINAA_TRIM_LCD_205));  /* trim linaa current */
        IO_SET(PORT_LINAA2,
    8b1a:	62d8 0204 	lod	AL, 0x204 <_PORT_LINAA2>
    8b1e:	94f8      	and	AL, #-8
    8b20:	7ad8 09d0 	lod	Y, 0x9d0 <.LASF2002+0x8>
    8b24:	44c6      	rl	Y, #2
    8b26:	f403      	and	Y, #3
    8b28:	86e8      	or	AL, YL
    8b2a:	42d8 0204 	mov	0x204 <_PORT_LINAA2>, AL

00008b2e <.LM8>:
               LCD_SEL_LINAA, EE_GET(LINAA_LCD_SEL_205));    /* select adjustment of linaa current */
        IO_SET(PORT_LINAA1,
    8b2e:	7ed8 0202 	lod	X, 0x202 <_PORT_LINAA1>
    8b32:	72d8 09d2 	lod	A, 0x9d2 <.LASF2002+0xa>
    8b36:	6000      	lod	AL, #0
    8b38:	72e4      	swap	A
    8b3a:	36da fe00 	and	X, #65024
    8b3e:	a6ee      	or	A, X
    8b40:	52d8 0202 	mov	0x202 <_PORT_LINAA1>, A

00008b44 <.L2>:
               LINAA_DIV, EE_GET(LINAA_DIV));                /* linaa amplifier common-mode rejection adjustment */
    } else {
        /* load default values */
    }

    IO_SET(PORT_SUPP_CFG,
    8b44:	605f      	lod	AL, #95
    8b46:	42d8 01e4 	mov	0x1e4 <_PORT_SUPP_CFG>, AL

00008b4a <.LM10>:
           UV_VS_FILT_SEL, 1u,                      /* 100-110us filtering for VS under voltage */
           OV_VS_FILT_SEL, 1u,                      /* 100-110us filtering for VS over voltage */
           OVC_FILT_SEL, 0u,                        /* 1-2us filtering for over current */
           OVT_FILT_SEL, 1u);                       /* 100-110us filtering for over temperature */

    IO_SET(PORT_MISC_OUT, SEL_TEMP, 8u);            /* temperature channel selection */
    8b4a:	62d8 01f3 	lod	AL, 0x1f3 <_PORT_MISC_OUT+0x1>
    8b4e:	940f      	and	AL, #15
    8b50:	8480      	or	AL, #-128
    8b52:	42d8 01f3 	mov	0x1f3 <_PORT_MISC_OUT+0x1>, AL

00008b56 <.LM11>:

    IO_SET(PORT_MISC2_OUT, ENABLE_OTD, 1u);         /* enable over-temperature detector */
    8b56:	62d8 01f5 	lod	AL, 0x1f5 <_PORT_MISC2_OUT+0x1>
    8b5a:	8402      	or	AL, #2
    8b5c:	42d8 01f5 	mov	0x1f5 <_PORT_MISC2_OUT+0x1>, AL

00008b60 <.LM12>:

    IO_SET(PORT_DRV1_PROT, OC_PM, 1u);              /* switch drivers to tri-state in case of over-current */
    8b60:	62d8 0219 	lod	AL, 0x219 <.LLST20>
    8b64:	8404      	or	AL, #4
    8b66:	42d8 0219 	mov	0x219 <.LLST20>, AL

00008b6a <.LM13>:
}
    8b6a:	5401      	ret

00008b6c <_fw_premain>:

void fw_premain(void)
{
	/* Initialize watch-dogs, both analogue and digital */
//	WDG_disableIwdIt();
    fw_low_level_init();            /* optionally call more low level initialization */
    8b6c:	1791      	call	0x8a90 <_fw_low_level_init>

00008b6e <.LM16>:

    fw_ram_section_init();          /* RAM initialization */
    8b6e:	100b      	call	0x8b86 <_fw_ram_section_init>

00008b70 <.LM17>:
#if defined (HAS_PATCH_COLIN)
    patch_colin_Init();
#endif /* HAS_PATCH_COLIN */

#if defined (HAS_MLS_API)
    fw_mls_Init();                  /* MLX LIN Slave initialization */
    8b70:	1679      	call	0x8864 <_fw_mls_Init>

00008b72 <.LM18>:
#endif /* HAS_MLS_API */

#if defined (HAS_STD_LIN_API) || defined (HAS_MLS_DEVICE_ID) || defined (HAS_MLS_LOADER)
    fw_mls_TransportLayerInit();
    8b72:	16ae      	call	0x88d0 <_fw_mls_TransportLayerInit>

00008b74 <.LM19>:
#endif /* HAS_STD_LIN_API || HAS_MLS_DEVICE_ID || defined (HAS_MLS_LOADER) */

#if defined (HAS_MLS_DEVICE_ID)
    fw_lepm_Init();                 /* MLX LIN device ID initialization */
    8b74:	16d8      	call	0x8926 <_fw_lepm_Init>

00008b76 <.LBB6>:
    ac_sel = 0u;
#elif FPLL == 28000
    tmp.u = EE_MS_TRIM7_VALUE;
    ac_sel = 0u;
#elif FPLL == 32000
    tmp.u = EE_MS_TRIM8_VALUE;
    8b76:	72d8 0a12 	lod	A, 0xa12 <.LASF1602>

00008b7a <.LM21>:
    ac_sel = 0u;
#else
    #warning "Clock Speed not valid, use 32MHz"
#endif

    SetSystemSpeed(tmp, ac_sel);
    8b7a:	54ca 0000 	pushw	#0

00008b7e <.LCFI2>:
    8b7e:	82db 5050 	callf	0xa0a0 <_SetSystemSpeed>

00008b82 <.LBB8>:
        );
}

STATIC INLINE void builtin_mlx16_set_priority(uint8_t level)
{
    __asm__ __volatile__ (
    8b82:	54f7      	mov	UPr, #7

00008b84 <.LBE8>:
    mls_loader_Init();
#endif /* HAS_MLS_LOADER */

    set_Clock_Speed();              /* set clock speed */
    builtin_mlx16_set_priority(7);  /* system mode, the lowest priority: 7 */
}
    8b84:	5403      	ret	#4

00008b86 <_fw_ram_section_init>:
#if !defined(RAM_APPLICATION)
    uint16_t* r;
#endif /* !RAM_APPLICATION */

    /* clear .bss and .dp.bss sections */
    for (w = &_bss_dp_start; w < &_bss_dp_end; ) {
    8b86:	7ada 101a 	lod	Y, #4122
    8b8a:	eeda 101a 	cmp	Y, #4122
    8b8e:	1c08      	jnc	0x8ba0 <.L2>
    8b90:	7eda 101a 	lod	X, #4122
    8b94:	2ae6      	sub	X, Y
    8b96:	1904      	je	0x8ba0 <.L2>
    8b98:	443e      	lsr	X
    8b9a:	7000      	lod	A, #0
    8b9c:	52d6      	mov	[Y++], A

00008b9e <L0>:
    8b9e:	1bfe      	djnz	X, 0x8b9c <.LASF1024+0x3>

00008ba0 <.L2>:
        *w++ = 0;
    }

    for (w = &_bss_start; w < &_bss_end; ) {
    8ba0:	7ada 10aa 	lod	Y, #4266
    8ba4:	eeda 142e 	cmp	Y, #5166
    8ba8:	1c08      	jnc	0x8bba <.L4>
    8baa:	7eda 142e 	lod	X, #5166
    8bae:	2ae6      	sub	X, Y
    8bb0:	1904      	je	0x8bba <.L4>
    8bb2:	443e      	lsr	X
    8bb4:	7000      	lod	A, #0
    8bb6:	52d6      	mov	[Y++], A

00008bb8 <L0>:
    8bb8:	1bfe      	djnz	X, 0x8bb6 <.LASF254+0xd>

00008bba <.L4>:

#if !defined(RAM_APPLICATION)   /* skip ROM-to-RAM loading for RAM application */
    /* initialize .data and .dp.data sections */
    r = &_data_load_start;      /* copy data from rom */

    for (w = &_data_dp_start; w < &_data_dp_end; ) {
    8bba:	7ada 1012 	lod	Y, #4114
    8bbe:	7eda 5b26 	lod	X, #23334

00008bc2 <.L26>:
    8bc2:	eeda 101a 	cmp	Y, #4122
    8bc6:	1c03      	jnc	0x8bce <.L6>
    8bc8:	0ea7      	lod	C, ML.7
    8bca:	54ce      	movsw	[Y++], [X++]
    8bcc:	07fa      	jmp	0x8bc2 <.L26>

00008bce <.L6>:
        *w++ = *r++;
    }

    for (w = &_data_start; w < &_data_end; ) {
    8bce:	7ada 101a 	lod	Y, #4122

00008bd2 <.L25>:
    8bd2:	eeda 10aa 	cmp	Y, #4266
    8bd6:	1c03      	jnc	0x8bde <.L8>
    8bd8:	0ea7      	lod	C, ML.7
    8bda:	54ce      	movsw	[Y++], [X++]
    8bdc:	07fa      	jmp	0x8bd2 <.L25>

00008bde <.L8>:
    }
#endif /* !RAM_APPLICATION */

#if defined (HAS_MLS_API)
    r = &_mlx4_cst_tables_ram_load_start;
    for (w = &_mlx4_cst_tables_ram_start; w < &_mlx4_cst_tables_ram_end; ) {
    8bde:	7eda 0e80 	lod	X, #3712
    8be2:	2eda 0ede 	cmp	X, #3806
    8be6:	1c07      	jnc	0x8bf6 <.L10>
    8be8:	7ada 5a40 	lod	Y, #23104

00008bec <.L11>:
    8bec:	0ea7      	lod	C, ML.7
    8bee:	54c6      	movsw	[X++], [Y++]
    8bf0:	2eda 0ede 	cmp	X, #3806
    8bf4:	187b      	jc	0x8bec <.L11>

00008bf6 <.L10>:
        *w++ = *r++;
    }

    r = &_mlx4_flash_table_load_start;
    for (w = &_mlx4_flash_table_start; w < &_mlx4_flash_table_end; ) {
    8bf6:	7eda 0f00 	lod	X, #3840
    8bfa:	2eda 0f88 	cmp	X, #3976
    8bfe:	1c07      	jnc	0x8c0e <.L1>
    8c00:	7ada 5a9e 	lod	Y, #23198

00008c04 <.L13>:
    8c04:	0ea7      	lod	C, ML.7
    8c06:	54c6      	movsw	[X++], [Y++]
    8c08:	2eda 0f88 	cmp	X, #3976
    8c0c:	187b      	jc	0x8c04 <.L13>

00008c0e <.L1>:
        *w++ = *r++;
    }
#endif /* HAS_MLS_API */
}
    8c0e:	5401      	ret

00008c10 <_fw_start>:
#include "sys_tools.h"
#endif

STATIC INLINE void Sys_SetStack(const uint16_t* const stackptr)
{
    __asm__ __volatile__ (
    8c10:	72da 142e 	lod	A, #5166
    8c14:	52ef      	mov	S, A

00008c16 <.LBB136>:
    return (stack_pointer);
}

STATIC INLINE void SYS_clearCpuStatus (void)
{
    __asm__ __volatile__ (
    8c16:	7000      	lod	A, #0
    8c18:	52e3      	mov	M, A

00008c1a <.LBE136>:
	}

}
#endif								 
    /* set priorities to lowest level */
    IO_SET(MLX16, ITC_PRIO0, 0xFFFFu);
    8c1a:	70ff      	lod	A, #-1
    8c1c:	52d8 0088 	mov	0x88 <__mlx4_flash_table_size>, A

00008c20 <.LM5>:
    IO_SET(MLX16, ITC_PRIO1, 0xFFFFu);
    8c20:	0ea7      	lod	C, ML.7
    8c22:	52d8 008a 	mov	0x8a <__mlx4_flash_table_size+0x2>, A

00008c26 <.LM6>:
    IO_SET(MLX16, ITC_PRIO2, 0xFFFFu);
    8c26:	52d8 008c 	mov	0x8c <.LASF1529>, A

00008c2a <.LM7>:
    IO_SET(MLX16, ITC_PRIO3, 0xFFFFu);
    8c2a:	52d8 008e 	mov	0x8e <.LASF1529+0x2>, A

00008c2e <.LM8>:
    IO_SET(MLX16, ITC_PRIO4, 0xFFFFu);
    8c2e:	0ea7      	lod	C, ML.7
    8c30:	52d8 0090 	mov	0x90 <__data_size>, A

00008c34 <.LM9>:
    IO_SET(MLX16, ITC_PRIO5, 0xFFFFu);
    8c34:	52d8 0092 	mov	0x92 <__data_size+0x2>, A

00008c38 <.LBB138>:
STATIC INLINE void MotorDriverUVWTSelectSource(DrvCtrlSelect_t drvctrl_u,
                                               DrvCtrlSelect_t drvctrl_v,
                                               DrvCtrlSelect_t drvctrl_w,
                                               DrvCtrlSelect_t drvctrl_t)
{
    IO_SET(PORT_DRV_CTRL,
    8c38:	72da eeee 	lod	A, #61166
    8c3c:	0ea7      	lod	C, ML.7
    8c3e:	52d8 0216 	mov	0x216 <_PORT_DRV_CTRL>, A

00008c42 <.LBE138>:

    /* all phases in tri-state explicitly */
    MotorDriverUVWTSelectSource(DRV_CTRL_TRISTATE, DRV_CTRL_TRISTATE, DRV_CTRL_TRISTATE, DRV_CTRL_TRISTATE);

    fw_premain();           /* Don't make this functions static to be sure its local variable will not apear before the SP assignment */
    8c42:	1794      	call	0x8b6c <_fw_premain>

00008c44 <.LM12>:

    __asm__ ("JMP _main\n\t" ::); /* jump to the main function */
    8c44:	76da 4b77 	jmpf	0x96ee <_main>

00008c48 <.LM13>:
}
    8c48:	5401      	ret

00008c4a <_ld_AppDiagRequest>:
    {
        transfer->response.respSId = transfer->request.reqSId + 0x40;
    }

    return retVal;
}
    8c4a:	7000      	lod	A, #0

00008c4c <.LVL1>:
    8c4c:	5401      	ret

00008c4e <_lin22_Init>:
 *
 * This function initialize the lin module and it will assign
 * the default frame ids to the different messages.
 */
void lin22_Init(void)
{
    8c4e:	5801      	inc	S, #2

00008c50 <.LCFI0>:
    (void)l_sys_init();
    8c50:	12c2      	call	0x91d6 <_l_sys_init>

00008c52 <.LM7>:
    (void)l_ifc_init_sl1();
    8c52:	12ea      	call	0x9228 <_l_ifc_init_sl1>

00008c54 <.LM8>:

#if 0 //(SL_HAS_SAVE_CONFIGURATION_SERVICE == 1)
    (void)eeprom_ReadLINconfig(lin_config, lin_cfg_len);
    (void)ld_set_configuration(ifcSlave_1, lin_config, lin_cfg_len);
#else
    (void)ml_Disconnect();
    8c54:	82db 11f0 	callf	0x23e0 <_ml_Disconnect>

00008c58 <.LBB281>:
    for (uint8_t index = 0u; index < (lin_cfg_len - 1); index++)
    {
        (void)ml_AssignFrameToMessageID(index, lin_config[1 + index]);
    8c58:	54ca 0092 	pushw	#146

00008c5c <.LCFI1>:
    8c5c:	7000      	lod	A, #0
    8c5e:	82db 1172 	callf	0x22e4 <_ml_AssignFrameToMessageID>
    8c62:	54ca 0011 	pushw	#17

00008c66 <.LCFI2>:
    8c66:	7001      	lod	A, #1
    8c68:	82db 1172 	callf	0x22e4 <_ml_AssignFrameToMessageID>
    8c6c:	54ca 00f0 	pushw	#240

00008c70 <.LCFI3>:
    8c70:	7002      	lod	A, #2
    8c72:	82db 1172 	callf	0x22e4 <_ml_AssignFrameToMessageID>

00008c76 <.LBE281>:
    }
    (void)ml_Connect();
    8c76:	82db 11ee 	callf	0x23dc <_ml_Connect>

00008c7a <.LM11>:

    ml_ConfiguredNAD = lin_config[0];
    8c7a:	6401      	lod	YL, #1
    8c7c:	46d8 10a4 	mov	0x10a4 <_ml_ConfiguredNAD>, YL

00008c80 <.LM12>:
#endif /* (SL_HAS_SAVE_CONFIGURATION_SERVICE == 1) */

#if (SL_HAS_UNKNOWN_DIAG_CALLOUT == 1)
    (void)ldt_SubscribeMultipleHandler(plinEventTable->ldt_Request, ld_AppDiagRequest);
    8c80:	7ed8 1002 	lod	X, 0x1002 <_plinEventTable>
    8c84:	201a      	add	X, #26
    8c86:	54ca 4625 	pushw	#17957

00008c8a <.LCFI4>:
    8c8a:	72f8      	lod	A, [X]
    8c8c:	5a09      	mov	[S-10], Y
    8c8e:	82db 2005 	callf	0x400a <_ldt_SubscribeMultipleHandler>

00008c92 <.LM13>:
#endif /* (SL_HAS_UNKNOWN_DIAG_CALLOUT == 1) */

    /* register a timer for SL_LD_N_AS_TIMEOUT timeout */
    swtimer_register(SWTIMER_LINAS, (SL_LD_N_AS_TIMEOUT / TO_N_AS_TIMEOUT_TICKS), REPETITIVE);
    8c92:	54ca 0001 	pushw	#1

00008c96 <.LCFI5>:
    8c96:	54ca 0001 	pushw	#1

00008c9a <.LCFI6>:
    8c9a:	7001      	lod	A, #1
    8c9c:	82db 4dff 	callf	0x9bfe <_swtimer_register>

00008ca0 <.LM14>:
    swtimer_start(SWTIMER_LINAS);
    8ca0:	7001      	lod	A, #1
    8ca2:	82db 4e15 	callf	0x9c2a <_swtimer_start>

00008ca6 <.LM15>:

    /* register a timer for SL_LD_N_CR_TIMEOUT timeout */
    swtimer_register(SWTIMER_LINCR, (SL_LD_N_CR_TIMEOUT / TO_N_CR_TIMEOUT_TICKS), REPETITIVE);
    8ca6:	54ca 0001 	pushw	#1

00008caa <.LCFI7>:
    8caa:	54ca 0001 	pushw	#1

00008cae <.LCFI8>:
    8cae:	0ea7      	lod	C, ML.7
    8cb0:	7002      	lod	A, #2
    8cb2:	82db 4dff 	callf	0x9bfe <_swtimer_register>

00008cb6 <.LM16>:
    swtimer_start(SWTIMER_LINCR);
    8cb6:	7002      	lod	A, #2
    8cb8:	82db 4e15 	callf	0x9c2a <_swtimer_start>

00008cbc <.LM17>:

    /* register a timer for COLIN check timeout */
    swtimer_register(SWTIMER_CHECKCOLIN, COLIN_CHECK_TIMEOUT, REPETITIVE);
    8cbc:	54ca 0001 	pushw	#1

00008cc0 <.LCFI9>:
    8cc0:	54ca 0bb8 	pushw	#3000

00008cc4 <.LCFI10>:
    8cc4:	0ea7      	lod	C, ML.7
    8cc6:	7000      	lod	A, #0
    8cc8:	82db 4dff 	callf	0x9bfe <_swtimer_register>

00008ccc <.LM18>:
    swtimer_start(SWTIMER_CHECKCOLIN);
    8ccc:	7000      	lod	A, #0
    8cce:	82db 4e15 	callf	0x9c2a <_swtimer_start>

00008cd2 <.LM19>:
#if DEBUG_DB_B2 == 1
    adc_RegisterIRQ2(B2_exit);
#endif
#endif

    bLinActive = true;
    8cd2:	7a15      	lod	Y, [S-22]
    8cd4:	46d8 118c 	mov	0x118c <_bLinActive>, YL

00008cd8 <.LM20>:
    bLinTimeoutActive = 0;
    8cd8:	6000      	lod	AL, #0
    8cda:	42d8 118b 	mov	0x118b <_bLinTimeoutActive>, AL

00008cde <.LCFI11>:
}
    8cde:	5417      	ret	#24

00008ce0 <_lin22_CheckColin>:
    }
}

/** Check the status of the COLIN module and handle accordingly */
void lin22_CheckColin(void)
{
    8ce0:	5801      	inc	S, #2

00008ce2 <.LBB374>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    8ce2:	7ae3      	lod	Y, M

00008ce4 <.LBB377>:

#include "builtin_mlx16_common.h"

STATIC INLINE void builtin_mlx16_disable_interrupts(void)
{
    __asm__ __volatile__ (
    8ce4:	08b2      	clrb	MH.2
    8ce6:	08b1      	clrb	MH.1
    8ce8:	08b0      	clrb	MH.0

00008cea <.LBE377>:
    static uint8_t u8ColinErrorState = 0u;
    ml_LinState_t ColinState;

    ENTER_SECTION(ATOMIC_KEEP_MODE);
    ColinState = ml_GetState(ML_CLR_LIN_BUS_ACTIVITY);
    8cea:	7008      	lod	A, #8
    8cec:	5a01      	mov	[S-2], Y
    8cee:	82db 11d3 	callf	0x23a6 <_ml_GetState>

00008cf2 <.LBB380>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    8cf2:	7a01      	lod	Y, [S-2]
    8cf4:	5ae3      	mov	M, Y

00008cf6 <.LBE374>:
    EXIT_SECTION();

    if (ColinState != ml_stINVALID)
    8cf6:	acff      	cmp	A, #-1
    8cf8:	1912      	je	0x8d1e <.L6>

00008cfa <.LM39>:
    {
        /* COLIN is responding */
        if (COLIN_LINstatus.event_overflow != 0u)
    8cfa:	62d8 0e2f 	lod	AL, 0xe2f <.LASF1554+0xb>

00008cfe <.LVL24>:
    8cfe:	9408      	and	AL, #8
    8d00:	1919      	je	0x8d34 <.L5>

00008d02 <.LBB384>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    8d02:	7ae3      	lod	Y, M

00008d04 <.LBB387>:

#include "builtin_mlx16_common.h"

STATIC INLINE void builtin_mlx16_disable_interrupts(void)
{
    __asm__ __volatile__ (
    8d04:	08b2      	clrb	MH.2
    8d06:	08b1      	clrb	MH.1
    8d08:	08b0      	clrb	MH.0

00008d0a <.LBE387>:
        {
            /* command overflow was detected */
            ENTER_SECTION(ATOMIC_KEEP_MODE);
            (void)ml_GetState(ML_CLR_LIN_CMD_OVERFLOW);
    8d0a:	7001      	lod	A, #1
    8d0c:	5a01      	mov	[S-2], Y
    8d0e:	82db 11d3 	callf	0x23a6 <_ml_GetState>

00008d12 <.LBB390>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    8d12:	7a01      	lod	Y, [S-2]
    8d14:	5ae3      	mov	M, Y

00008d16 <.LBE384>:
            EXIT_SECTION();

            /* do handshake MLX16 <> COLIN */
            ml_SetSLVCMD(0x42u);
    8d16:	7042      	lod	A, #66
    8d18:	82db 1224 	callf	0x2448 <_ml_SetSLVCMD>
    8d1c:	5403      	ret	#4

00008d1e <.L6>:
        }
    }
    else
    {
        /* COLIN response time-out */
        u8ColinErrorState++;
    8d1e:	62d8 118a 	lod	AL, 0x118a <___u8ColinErrorState_7224>

00008d22 <.LVL30>:
    8d22:	8001      	add	AL, #1
    8d24:	42d8 118a 	mov	0x118a <___u8ColinErrorState_7224>, AL

00008d28 <.LM46>:

        if (u8ColinErrorState >= 4u)
    8d28:	8c03      	cmp	AL, #3
    8d2a:	1a04      	jule	0x8d34 <.L5>

00008d2c <.LBB394>:
    return 1;
}

STATIC INLINE uint16_t mlx16_enter_system_mode_keep_prio(void)
{
    __asm__ __volatile__ (".word OPCODE_CALL_FP_ENTER_SYSTEM_MODE_KEEP_PRIO");
    8d2c:	5048      	call	fp2:0x40

00008d2e <.LBE397>:
}

STATIC INLINE NO_RETURN void Sys_ResetCpu (void)
{
    (void) mlx16_enter_system_mode_keep_prio();
    IO_SET(RST_CTRL, SOFT_RESET, 1u);    /* Reset happens immediately after writing SOFT_RESET bit */
    8d2e:	6283      	lod	AL, io:0x3 <_RST_CTRL+0x1>
    8d30:	8420      	or	AL, #32
    8d32:	4283      	mov	io:0x3 <_RST_CTRL+0x1>, AL

00008d34 <.L5>:
        {
            /* COLIN has not been responding to often, lets reset the module */
            Sys_ResetCpu();
        }
    }
}
    8d34:	5403      	ret	#4

00008d36 <_lin22_BackgroundHandler>:
void lin22_BackgroundHandler(void)
{

#if (SL_HAS_SAVE_CONFIGURATION_SERVICE == 1)
    l_s_IfcStatus_t status;
    status.word = l_ifc_read_status_sl1();
    8d36:	1282      	call	0x923c <_l_ifc_read_status_sl1>

00008d38 <.LM52>:
        /* nothing to be done */
    }
#endif /* (SL_HAS_SAVE_CONFIGURATION_SERVICE == 1) */

    /* Check LIN AS-timeout */
    if (swtimer_isTriggered(SWTIMER_LINAS))
    8d38:	7001      	lod	A, #1
    8d3a:	82db 4e26 	callf	0x9c4c <_swtimer_isTriggered>
    8d3e:	ac00      	cmp	A, #0
    8d40:	1906      	je	0x8d4e <.L13>

00008d42 <.LM53>:
    {
        ldt_Tick(100u / TO_N_AS_TIMEOUT_TICKS, 0u);
    8d42:	54ca 0000 	pushw	#0

00008d46 <.LCFI14>:
    8d46:	7000      	lod	A, #0
    8d48:	82db 5106 	callf	0xa20c <_ldt_Tick>
    8d4c:	5c01      	dec	S, #2

00008d4e <.L13>:
    }

    /* Check LIN CR-timeout */
    if (swtimer_isTriggered(SWTIMER_LINCR))
    8d4e:	7002      	lod	A, #2
    8d50:	82db 4e26 	callf	0x9c4c <_swtimer_isTriggered>
    8d54:	ac00      	cmp	A, #0
    8d56:	1906      	je	0x8d64 <.L14>

00008d58 <.LM55>:
    {
        ldt_Tick(0u, 100u / TO_N_CR_TIMEOUT_TICKS);
    8d58:	54ca 0000 	pushw	#0

00008d5c <.LCFI16>:
    8d5c:	7000      	lod	A, #0
    8d5e:	82db 5106 	callf	0xa20c <_ldt_Tick>
    8d62:	5c01      	dec	S, #2

00008d64 <.L14>:
    }

    if (swtimer_isTriggered(SWTIMER_CHECKCOLIN))
    8d64:	7000      	lod	A, #0
    8d66:	82db 4e26 	callf	0x9c4c <_swtimer_isTriggered>
    8d6a:	ac00      	cmp	A, #0
    8d6c:	1901      	je	0x8d70 <.L12>

00008d6e <.LM57>:
    {
        /* check COLIN state */
        lin22_CheckColin();
    8d6e:	17b8      	call	0x8ce0 <_lin22_CheckColin>

00008d70 <.L12>:
    }
}
    8d70:	5401      	ret

00008d72 <_ld_serial_number_callout>:
 * This function is called by the lin driver on receipt of a
 * read by id 0x00 request.
 * @param[out]  data  pointer to the data to be filled
 */
void ld_serial_number_callout(l_u8 data[4])
{
    8d72:	7ee2      	lod	X, A

00008d74 <.LM60>:
    data[0] = (l_u8)(EE_CHIP_ID_0); /* LSB */
    8d74:	7ada 0a30 	lod	Y, #2608
    8d78:	0ea7      	lod	C, ML.7
    8d7a:	54c4      	movsb	[X++], [Y++]

00008d7c <.LM61>:
    data[1] = (l_u8)(EE_CHIP_ID_0 >> 8);
    8d7c:	54c4      	movsb	[X++], [Y++]

00008d7e <.LM62>:
    data[2] = (l_u8)(EE_CHIP_ID_1);
    8d7e:	7ada 0a32 	lod	Y, #2610
    8d82:	0ea7      	lod	C, ML.7
    8d84:	54c4      	movsb	[X++], [Y++]

00008d86 <.LM63>:
    data[3] = (l_u8)(EE_CHIP_ID_1 >> 8); /* MSB */
    8d86:	54c4      	movsb	[X++], [Y++]

00008d88 <.LM64>:
}
    8d88:	5401      	ret

00008d8a <_fw_lepm_ApplicationStop>:
 * @retval  true   command has been handled successful;
 * @retval  false  command has not been handled successful;
 */
bool fw_lepm_ApplicationStop(void)
{
    adc_Stop();
    8d8a:	82db 3b0b 	callf	0x7616 <_adc_Stop>

00008d8e <.LM67>:
    pwm_Disable();
    8d8e:	82db 4d76 	callf	0x9aec <_pwm_Disable>

00008d92 <.LM68>:
    swtimer_deinit();
    8d92:	82db 4de7 	callf	0x9bce <_swtimer_deinit>

00008d96 <.LM69>:
    return (true); /* return that the application has stopped */
}
    8d96:	7001      	lod	A, #1
    8d98:	5401      	ret

00008d9a <_lin22_GotoSleep>:
 * This function will never return, after the chip went into sleep mode
 * it will wake up again via a power on sequence.
 */
void lin22_GotoSleep(void)
{
    (void)fw_lepm_ApplicationStop(); /* stop the application */
    8d9a:	17f7      	call	0x8d8a <_fw_lepm_ApplicationStop>

00008d9c <.LBB399>:
    8d9c:	5048      	call	fp2:0x40

00008d9e <.LBB401>:

#include "builtin_mlx16_common.h"

STATIC INLINE void builtin_mlx16_disable_interrupts(void)
{
    __asm__ __volatile__ (
    8d9e:	08b2      	clrb	MH.2
    8da0:	08b1      	clrb	MH.1
    8da2:	08b0      	clrb	MH.0

00008da4 <.LBB403>:
    SetRstatFlag();
}

STATIC INLINE void disallowWarmReboot(void)
{
    ResetRstatFlag();
    8da4:	82db 1508 	callf	0x2a10 <_ResetRstatFlag>

00008da8 <.LM75>:
    bistHeader = C_CHIP_HEADER_INVALID;
    8da8:	7000      	lod	A, #0
    8daa:	52d8 17f8 	mov	0x17f8 <_bistHeader>, A

00008dae <.LBB405>:
#endif
	return result;
}
static __attribute__((always_inline)) inline uint16_t IO_AWD__WIN_OPEN_GET (void) {
	register uint16_t result;
	asm volatile (
    8dae:	0f7f      	lod	C, io:0x0f.7

00008db0 <.LBE407>:
}

/** WDG_conditionalAwdRefresh acknowledges the AWD timer if its window is opened */
STATIC INLINE void WDG_conditionalAwdRefresh(void)
{
    if (IO_GET(AWD, WIN_OPEN) != 0u) {
    8db0:	1c01      	jnc	0x8db4 <.L28>

00008db2 <.LM78>:
        IO_SET(AWD, ACK, 1u);
    8db2:	0b76      	setb	io:0x0e.6

00008db4 <.L28>:

    disallowWarmReboot(); /* warm reboot is not allowed any more */

    WDG_conditionalAwdRefresh(); /* refresh the timers if they're used */

    IO_SET(SPI, STOP, 1u); /* stop the SPI despite it's running or not */
    8db4:	62d8 0132 	lod	AL, 0x132 <_SPI+0xa>
    8db8:	94fc      	and	AL, #-4
    8dba:	8402      	or	AL, #2
    8dbc:	42d8 0132 	mov	0x132 <_SPI+0xa>, AL

00008dc0 <.LM80>:

    //    IO_SET(PORT_MISC2_OUT, WU_IO_EN, 0u);           /* disable wake up on IO0 */
    IO_SET(PORT_MISC2_OUT, WU_IO_EN, 1u); /* enable wake up on IO0 */ // 250702-3 Support Sleep by IO0.
    8dc0:	62d8 01f5 	lod	AL, 0x1f5 <_PORT_MISC2_OUT+0x1>
    8dc4:	8401      	or	AL, #1
    8dc6:	42d8 01f5 	mov	0x1f5 <_PORT_MISC2_OUT+0x1>, AL

00008dca <.LM81>:
    ml_ResetDrv();                                                    /* stop the MLX4 */
    8dca:	82db 122f 	callf	0x245e <_ml_ResetDrv>

00008dce <.L29>:

    /* wait for EEPROM operations */
    while (IO_GET(EEPROM_FLASH, EE_BUSY) != 0u)
    8dce:	72d8 0186 	lod	A, 0x186 <.LASF1351+0x5>
    8dd2:	ac00      	cmp	A, #0
    8dd4:	1afc      	jsl	0x8dce <.L29>

00008dd6 <.L30>:
    {
    }
    /* wait for Flash operations */
    while ((IO_GET(EEPROM_FLASH, FL_STATUS) == FLASH_STATUS_PAGE_PROGRAM) ||
    8dd6:	72d8 017c 	lod	A, 0x17c <.LASF1350+0x3>
    8dda:	940f      	and	AL, #15
    8ddc:	8c04      	cmp	AL, #4
    8dde:	197b      	je	0x8dd6 <.L30>

00008de0 <.LM84>:
           (IO_GET(EEPROM_FLASH, FL_STATUS) == FLASH_STATUS_SECTOR_ERASE))
    8de0:	72d8 017c 	lod	A, 0x17c <.LASF1350+0x3>

00008de4 <.LM85>:
    /* wait for EEPROM operations */
    while (IO_GET(EEPROM_FLASH, EE_BUSY) != 0u)
    {
    }
    /* wait for Flash operations */
    while ((IO_GET(EEPROM_FLASH, FL_STATUS) == FLASH_STATUS_PAGE_PROGRAM) ||
    8de4:	940f      	and	AL, #15
    8de6:	8c03      	cmp	AL, #3
    8de8:	1976      	je	0x8dd6 <.L30>

00008dea <.LM86>:
           (IO_GET(EEPROM_FLASH, FL_STATUS) == FLASH_STATUS_SECTOR_ERASE))
    {
    }

    /* stop MLX16 */
    __asm__("HALT\n\t");
    8dea:	42c9      	halt

00008dec <.LBB409>:
    8dec:	5048      	call	fp2:0x40

00008dee <.LBE411>:
    8dee:	6283      	lod	AL, io:0x3 <_RST_CTRL+0x1>
    8df0:	8420      	or	AL, #32
    8df2:	4283      	mov	io:0x3 <_RST_CTRL+0x1>, AL

00008df4 <_ld_read_by_id_callout>:
 * - LD_NEGATIVE_RESPONSE   - the slave node will respond with a negative response;
 * - LD_POSTIVE_RESPONSE    - the slave node will setup a positive response;
 * - LD_NO_RESPONSE         - the slave node will not answer.
 */
l_u8 ld_read_by_id_callout(l_ifc_handle iii, l_u8 id, l_u8 *pci, l_u8 *data)
{
    8df4:	580d      	inc	S, #14

00008df6 <.LCFI18>:
    l_u8 u8Return;
    (void)iii;
    switch (id)
    8df6:	6211      	lod	AL, [S-18]

00008df8 <.LVL46>:
    8df8:	8c2b      	cmp	AL, #43
    8dfa:	1923      	je	0x8e42 <.L39>
    8dfc:	5cf2      	usex	A
    8dfe:	ac2c      	cmp	A, #44
    8e00:	192c      	je	0x8e5a <.L40>
    8e02:	ac21      	cmp	A, #33
    8e04:	1901      	je	0x8e08 <.LBB413>
    8e06:	003e      	jmp	0x8e84 <.L43>

00008e08 <.LBB413>:
    {
    case 0x21u:
    {
        uint8_t lin_cfg_len = SL_NUMBER_OF_DYNAMIC_MESSAGES + 1u;
        uint8_t lin_config[1 + SL_NUMBER_OF_DYNAMIC_MESSAGES] = SL_NODE_CONFIGURATION_INITIALIZER;
    8e08:	7eef      	lod	X, S
    8e0a:	20f2      	add	X, #-14
    8e0c:	7ada 5bbe 	lod	Y, #23486
    8e10:	0ea7      	lod	C, ML.7
    8e12:	54c4      	movsb	[X++], [Y++]
    8e14:	54c4      	movsb	[X++], [Y++]
    8e16:	54c4      	movsb	[X++], [Y++]
    8e18:	54c4      	movsb	[X++], [Y++]

00008e1a <.LM92>:

        /* Verify NAD */
#if (SL_HAS_SAVE_CONFIGURATION_SERVICE == 1)
        (void)eeprom_ReadLINconfig(lin_config, lin_cfg_len);
    8e1a:	54ca 0004 	pushw	#4

00008e1e <.LCFI19>:
    8e1e:	7aef      	lod	Y, S
    8e20:	e0f0      	add	Y, #-16
    8e22:	72e6      	lod	A, Y
    8e24:	5a07      	mov	[S-8], Y
    8e26:	141e      	call	0x8664 <_eeprom_ReadLINconfig>

00008e28 <.LM93>:

        *pci = 8u; /* 7-bytes of data + 1 */
    8e28:	7e15      	lod	X, [S-22]
    8e2a:	6008      	lod	AL, #8
    8e2c:	42f8      	mov	[X], AL
    8e2e:	7e17      	lod	X, [S-24]
    8e30:	7a07      	lod	Y, [S-8]
    8e32:	0ea7      	lod	C, ML.7
    8e34:	54c4      	movsb	[X++], [Y++]
    8e36:	54c4      	movsb	[X++], [Y++]
    8e38:	54c4      	movsb	[X++], [Y++]
    8e3a:	54c4      	movsb	[X++], [Y++]
    8e3c:	5c01      	dec	S, #2

00008e3e <.L44>:
        *pci = 5u; /* 4-bytes of data + 1-byte of pci */
        data[0] = (uint8_t)LIBRARIES_VERSION_MAJOR;
        data[1] = (uint8_t)LIBRARIES_VERSION_MINOR;
        data[2] = (uint8_t)LIBRARIES_VERSION_REVISION;
        data[3] = (uint8_t)LIBRARIES_VERSION_CUSTOMER_BUILD;
        u8Return = LD_POSITIVE_RESPONSE;
    8e3e:	7007      	lod	A, #7

00008e40 <.LM95>:
        break;
    8e40:	540f      	ret	#16

00008e42 <.L39>:
 * - LD_NEGATIVE_RESPONSE   - the slave node will respond with a negative response;
 * - LD_POSTIVE_RESPONSE    - the slave node will setup a positive response;
 * - LD_NO_RESPONSE         - the slave node will not answer.
 */
l_u8 ld_read_by_id_callout(l_ifc_handle iii, l_u8 id, l_u8 *pci, l_u8 *data)
{
    8e42:	7e13      	lod	X, [S-20]

00008e44 <.LM97>:
        break;
    }

    case 0x2Bu:
    {
        *pci = 5u; /* 4-bytes of data + 1-byte of pci */
    8e44:	6005      	lod	AL, #5
    8e46:	42f8      	mov	[X], AL

00008e48 <.LM98>:
 * - LD_NEGATIVE_RESPONSE   - the slave node will respond with a negative response;
 * - LD_POSTIVE_RESPONSE    - the slave node will setup a positive response;
 * - LD_NO_RESPONSE         - the slave node will not answer.
 */
l_u8 ld_read_by_id_callout(l_ifc_handle iii, l_u8 id, l_u8 *pci, l_u8 *data)
{
    8e48:	7e15      	lod	X, [S-22]

00008e4a <.LM99>:
    }

    case 0x2Bu:
    {
        *pci = 5u; /* 4-bytes of data + 1-byte of pci */
        data[0] = (uint8_t)LIBRARIES_VERSION_MAJOR;
    8e4a:	6002      	lod	AL, #2
    8e4c:	42f8      	mov	[X], AL

00008e4e <.LM100>:
        data[1] = (uint8_t)LIBRARIES_VERSION_MINOR;
    8e4e:	600b      	lod	AL, #11
    8e50:	42f9      	mov	[X+1], AL

00008e52 <.LM101>:
        data[2] = (uint8_t)LIBRARIES_VERSION_REVISION;
    8e52:	6000      	lod	AL, #0
    8e54:	42fa      	mov	[X+2], AL

00008e56 <.LM102>:
        data[3] = (uint8_t)LIBRARIES_VERSION_CUSTOMER_BUILD;
    8e56:	42fb      	mov	[X+3], AL
    8e58:	07f2      	jmp	0x8e3e <.L44>

00008e5a <.L40>:
        break;
    }

    case 0x2Cu:
    {
        uint32_t version = VERSION_getFwAppVersion();
    8e5a:	82db 50ba 	callf	0xa174 <_VERSION_getFwAppVersion>
    8e5e:	58a0      	mov	[S-4], YA

00008e60 <.LM104>:
        *pci = 5u; /* 4-bytes of data + 1-byte of pci */
    8e60:	7e13      	lod	X, [S-20]
    8e62:	6405      	lod	YL, #5
    8e64:	46f8      	mov	[X], YL

00008e66 <.LM105>:
        data[0] = (uint8_t)(version >> 24);
    8e66:	58e0      	mov	YA, [S-4]
    8e68:	48af      	lsr	YA, #16
    8e6a:	48a7      	lsr	YA, #8

00008e6c <.LVL55>:
    8e6c:	58a3      	mov	[S-10], YA
    8e6e:	7e15      	lod	X, [S-22]
    8e70:	42f8      	mov	[X], AL

00008e72 <.LM106>:
        data[1] = (uint8_t)(version >> 16);
    8e72:	6601      	lod	YL, [S-2]
    8e74:	46f9      	mov	[X+1], YL

00008e76 <.LM107>:
        data[2] = (uint8_t)(version >> 8);
    8e76:	58e0      	mov	YA, [S-4]
    8e78:	48a7      	lsr	YA, #8
    8e7a:	58a3      	mov	[S-10], YA
    8e7c:	42fa      	mov	[X+2], AL

00008e7e <.LM108>:
        data[3] = (uint8_t)(version >> 0);
    8e7e:	6603      	lod	YL, [S-4]
    8e80:	46fb      	mov	[X+3], YL
    8e82:	07dd      	jmp	0x8e3e <.L44>

00008e84 <.L43>:
        u8Return = LD_POSITIVE_RESPONSE;
        break;
    }

    default:
        u8Return = LD_NEGATIVE_RESPONSE;
    8e84:	7002      	lod	A, #2

00008e86 <.LM110>:
        break;
    }

    return (u8Return);
}
    8e86:	540f      	ret	#16

00008e88 <_l_ifc_sleep_entered_callout>:
 *
 * @param[in]  Reason  Reason of entering sleep mode.
 */
void l_ifc_sleep_entered_callout(ml_SleepReason_t Reason)
{
    switch (Reason)
    8e88:	ac01      	cmp	A, #1
    8e8a:	1903      	je	0x8e92 <.L47>
    8e8c:	ac06      	cmp	A, #6
    8e8e:	1904      	je	0x8e98 <.L48>
    8e90:	5401      	ret

00008e92 <.L47>:
    {
    case ml_reasonMaster:
        /* "Go-to-Sleep" frame has been received from Master */
        EVENT_GotoSleep(); // 250415 - To do act after sr
    8e92:	82db 4c17 	callf	0x982e <_EVENT_GotoSleep>

00008e96 <.LM114>:
        lin22_GotoSleep(); /* switch to sleep mode */
    8e96:	1781      	call	0x8d9a <_lin22_GotoSleep>

00008e98 <.L48>:
        break;
    case ml_reasonTimeOut:
        /* Sleep State entered with a timeout with LIN bus recessive */
        bLinTimeoutActive = 1;
    8e98:	6001      	lod	AL, #1

00008e9a <.LVL62>:
    8e9a:	42d8 118b 	mov	0x118b <_bLinTimeoutActive>, AL

00008e9e <.LM116>:
        EVENT_GotoSleep();
        lin22_GotoSleep(); /* switch to sleep mode */
#endif
        break;
    }
}
    8e9e:	5401      	ret

00008ea0 <_l_mls_Init>:
    const l_u8 l_s_ver = ML_VER_DEFAULT;
#endif /* ML_MLX4_VERSION >= 412 */

    /* Start and initialize the LIN Module
     * Note: MLX LIN API shall be initialized first with proper settings and only TL then */
    if (ml_Init(SL_LIN_AUTOBAUDRATE_MODE, SL_LIN_BAUDRATE, l_s_ver, MLX4_FPLL) == ML_SUCCESS) {
    8ea0:	54ca 7d00 	pushw	#32000

00008ea4 <.LCFI0>:
    8ea4:	54ca 0009 	pushw	#9

00008ea8 <.LCFI1>:
    8ea8:	54ca 4b00 	pushw	#19200

00008eac <.LCFI2>:
    8eac:	0ea7      	lod	C, ML.7
    8eae:	7001      	lod	A, #1
    8eb0:	82db 516b 	callf	0xa2d6 <_ml_Init>
    8eb4:	5c05      	dec	S, #6

00008eb6 <.LCFI3>:
    8eb6:	ac00      	cmp	A, #0
    8eb8:	1d3a      	jne	0x8f2e <.L1>

00008eba <.LBB10>:
 * @return void
 */
static void l_mls_InitEventTable(void)
{
    /* General events processing */
    plinEventTable->mlu_LinSleepMode = l_LinSleepMode;
    8eba:	7ad8 1002 	lod	Y, 0x1002 <_plinEventTable>
    8ebe:	7ee6      	lod	X, Y
    8ec0:	200a      	add	X, #10
    8ec2:	72da 493c 	lod	A, #18748
    8ec6:	52f8      	mov	[X], A

00008ec8 <.LM4>:
    plinEventTable->mlu_AutoAddressingStep = l_AutoAddressingStep;
    8ec8:	2002      	add	X, #2
    8eca:	72da 49be 	lod	A, #18878
    8ece:	52f8      	mov	[X], A

00008ed0 <.LM5>:

    /* Non-diagnostic frames are processed always by std. LIN API when it's initialized
     * The std. LIN API uses event from LIN transport layer */
    plinEventTable->ldt_NonDiagMessageReceived = l_MessageReceived;
    8ed0:	2002      	add	X, #2
    8ed2:	72da 4949 	lod	A, #18761
    8ed6:	52f8      	mov	[X], A

00008ed8 <.LM6>:
    plinEventTable->ldt_NonDiagDataRequest = l_DataRequest;
    8ed8:	2004      	add	X, #4
    8eda:	72da 4968 	lod	A, #18792
    8ede:	52f8      	mov	[X], A

00008ee0 <.LM7>:
    plinEventTable->ldt_NonDiagDataTransmitted = l_DataTransmitted;
    8ee0:	20fe      	add	X, #-2
    8ee2:	72da 49a3 	lod	A, #18851
    8ee6:	52f8      	mov	[X], A

00008ee8 <.LM8>:

    /* Subscribe to errors reporting */
    uint8_t* idx = &ld_ErrorDetectedMultipleHandler.eventsCount;
    if (*idx < ld_ErrorDetectedMultipleHandler.eventsMaxLength) {
    8ee8:	62d8 13d1 	lod	AL, 0x13d1 <.LLST14+0x2>
    8eec:	5cf2      	usex	A
    8eee:	7ee2      	lod	X, A
    8ef0:	62d8 13d0 	lod	AL, 0x13d0 <.LLST14+0x1>
    8ef4:	8ed8 13d1 	cmp	AL, 0x13d1 <.LLST14+0x2>
    8ef8:	1a0c      	jule	0x8f12 <.L3>

00008efa <.LM9>:
        ld_ErrorDetectedMultipleHandler.eventHandlerBuffer[*idx] = l_ErrorDetected;
    8efa:	442e      	asl	X
    8efc:	72d8 13ce 	lod	A, 0x13ce <_ld_ErrorDetectedMultipleHandler>
    8f00:	22e2      	add	X, A
    8f02:	72da 4984 	lod	A, #18820
    8f06:	52f8      	mov	[X], A

00008f08 <.LM10>:
        *idx = *idx + 1;
    8f08:	62d8 13d1 	lod	AL, 0x13d1 <.LLST14+0x2>
    8f0c:	8001      	add	AL, #1
    8f0e:	42d8 13d1 	mov	0x13d1 <.LLST14+0x2>, AL

00008f12 <.L3>:
    }

#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
    /* Diagnostic frames: node configuration / identification */
    (void)ldt_SubscribeMultipleHandler(plinEventTable->ldt_Request, ld_DiagRequest);
    8f12:	7ee6      	lod	X, Y
    8f14:	201a      	add	X, #26
    8f16:	54ca 47d4 	pushw	#18388

00008f1a <.LCFI4>:
    8f1a:	72f8      	lod	A, [X]
    8f1c:	82db 2005 	callf	0x400a <_ldt_SubscribeMultipleHandler>

00008f20 <.LM12>:
    plinEventTable->ldt_GetLINNAD = ld_GetLINNAD;
    8f20:	7ed8 1002 	lod	X, 0x1002 <_plinEventTable>
    8f24:	2014      	add	X, #20
    8f26:	72da 47ab 	lod	A, #18347
    8f2a:	52f8      	mov	[X], A
    8f2c:	5c01      	dec	S, #2

00008f2e <.L1>:
     * Note: MLX LIN API shall be initialized first with proper settings and only TL then */
    if (ml_Init(SL_LIN_AUTOBAUDRATE_MODE, SL_LIN_BAUDRATE, l_s_ver, MLX4_FPLL) == ML_SUCCESS) {
        /* Initialize MLX LIN API event table */
        l_mls_InitEventTable();
    }
}
    8f2e:	5401      	ret

00008f30 <_l_sys_irq_disable>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    8f30:	72e3      	lod	A, M

00008f32 <.LBE12>:
l_irqmask l_sys_irq_disable(void)
{
    l_u16 mreg_saved = builtin_mlx16_get_status();

    /* Keep User-bit unchanged */
    builtin_mlx16_set_status((mreg_saved & ~((l_u16)7u << 8)) |
    8f32:	7ee2      	lod	X, A
    8f34:	36da f8ff 	and	X, #63743
    8f38:	26da 0400 	or	X, #1024

00008f3c <.LBB14>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    8f3c:	5ee3      	mov	M, X

00008f3e <.LBE14>:
                             (((l_u16)LINAPI_RESOURCES_BLOCKING_PRIORITY & 7u) << 8));
    return mreg_saved;
}
    8f3e:	5401      	ret

00008f40 <_l_sys_irq_restore>:
    8f40:	52e3      	mov	M, A

00008f42 <.LBE16>:
 * @return void
 */
void l_sys_irq_restore(l_irqmask previous)
{
    builtin_mlx16_set_status(previous);
}
    8f42:	5401      	ret

00008f44 <_ld_DiagInit>:
/** (Re)initialize the configuration/identification layer
 * @return  void
 */
void ld_DiagInit (void)
{
    pendingSlaveResponse = respNoResponse;
    8f44:	7000      	lod	A, #0
    8f46:	52d8 1190 	mov	0x1190 <_pendingSlaveResponse>, A

00008f4a <.LM40>:
    ml_ConfiguredNAD = ml_InitialNAD;
    8f4a:	62d8 5d90 	lod	AL, 0x5d90 <_ml_InitialNAD>
    8f4e:	0ea7      	lod	C, ML.7
    8f50:	42d8 10a4 	mov	0x10a4 <_ml_ConfiguredNAD>, AL

00008f54 <.LM41>:
}
    8f54:	5401      	ret

00008f56 <_ld_GetLINNAD>:
 * @return Current NAD.
 */
l_u8 ld_GetLINNAD (l_u8 NAD)
{
    (void)NAD; /* There is no interest to track other than current NADs on the bus */
    l_u8 retVal = ml_ConfiguredNAD;
    8f56:	66d8 10a4 	lod	YL, 0x10a4 <_ml_ConfiguredNAD>
    8f5a:	5cf6      	usex	Y

00008f5c <.LM47>:
#if SL_EN_ASSIGN_NAD_SERVICE
    /* Assign NAD request */
    if (ML_SLAVE_FRAME_DATA_BUFFER[2] == 0xB0u) {
    8f5c:	62d8 1006 	lod	AL, 0x1006 <_ml_Data+0x2>

00008f60 <.LVL41>:
    8f60:	8cb0      	cmp	AL, #-80
    8f62:	1d03      	jne	0x8f6a <.L26>

00008f64 <.LM48>:
        retVal = ml_InitialNAD;
    8f64:	66d8 5d90 	lod	YL, 0x5d90 <_ml_InitialNAD>
    8f68:	5cf6      	usex	Y

00008f6a <.L26>:
    }
#endif /* SL_EN_ASSIGN_NAD_SERVICE */
    return retVal;
}
    8f6a:	72e6      	lod	A, Y
    8f6c:	5401      	ret

00008f6e <_isSupplierIdValid>:
    l_u16 supplierID;
    l_u16 cur_supplierID;
    ml_Status_t status;

    /* supplierID word could be on odd address, so get LSB, MSB separately */
    supplierID = ((l_u16)data[1] << 8 ) | data[0];
    8f6e:	7ee2      	lod	X, A
    8f70:	62f8      	lod	AL, [X]
    8f72:	6af9      	lod	AH, [X+1]

00008f74 <.LM52>:
    cur_supplierID = (l_u16)ml_ProductID[0]
    8f74:	66d8 5d8a 	lod	YL, 0x5d8a <_ml_ProductID>
    8f78:	6ed8 5d8b 	lod	YH, 0x5d8b <_ml_ProductID+0x1>

00008f7c <.LM53>:
                     | (((l_u16)ml_ProductID[1]) << 8);

    if (   (supplierID == cur_supplierID)
    8f7c:	aee6      	cmp	A, Y
    8f7e:	1904      	je	0x8f88 <.L29>

00008f80 <.LM54>:
           || (supplierID == 0x7FFFU /* wildcard */)) {
        status = ML_SUCCESS;
    8f80:	aeda 7fff 	cmp	A, #32767
    8f84:	5ca2      	sne	A
    8f86:	5401      	ret

00008f88 <.L29>:
    8f88:	7000      	lod	A, #0

00008f8a <.LM55>:
    } else {
        status = ML_FAILURE;
    }

    return status;
}
    8f8a:	5401      	ret

00008f8c <_isFunctionIdValid>:
    l_u16 functionID;
    l_u16 cur_functionID;
    ml_Status_t status;

    /* functionID word could be on odd address, so get LSB, MSB separately */
    functionID = ((l_u16)data[1] << 8) | data[0];
    8f8c:	7ee2      	lod	X, A
    8f8e:	62f8      	lod	AL, [X]
    8f90:	6af9      	lod	AH, [X+1]

00008f92 <.LM58>:
    cur_functionID = ((l_u16)ml_ProductID[2])
    8f92:	66d8 5d8c 	lod	YL, 0x5d8c <_ml_ProductID+0x2>
    8f96:	6ed8 5d8d 	lod	YH, 0x5d8d <_ml_ProductID+0x3>

00008f9a <.LM59>:
                     | (((l_u16)ml_ProductID[3]) << 8);

    if (   (functionID == cur_functionID)
    8f9a:	aee6      	cmp	A, Y
    8f9c:	1903      	je	0x8fa4 <.L32>

00008f9e <.LM60>:
           || (functionID == 0xFFFFU /* wildcard */)) {
        status = ML_SUCCESS;
    8f9e:	acff      	cmp	A, #-1
    8fa0:	5ca2      	sne	A
    8fa2:	5401      	ret

00008fa4 <.L32>:
    8fa4:	7000      	lod	A, #0

00008fa6 <.LM61>:
    } else {
        status = ML_FAILURE;
    }

    return status;
}
    8fa6:	5401      	ret

00008fa8 <_ld_DiagRequest>:
 * @return Status:
 * - true  There is data to send;
 * - false There is nothing to send (no response).
 */
bool ld_DiagRequest(LINDiagTransfer_t *transfer)
{
    8fa8:	5809      	inc	S, #10

00008faa <.LCFI4>:
    8faa:	7ae2      	lod	Y, A

00008fac <.LM63>:
    pDiagTransfer = transfer;
    8fac:	52d8 118e 	mov	0x118e <_pDiagTransfer>, A

00008fb0 <.LM64>:

    /* A new MRF received,
     * so reset pending response
     */
    pendingSlaveResponse = respNoResponse;
    8fb0:	7000      	lod	A, #0

00008fb2 <.LVL50>:
    8fb2:	52d8 1190 	mov	0x1190 <_pendingSlaveResponse>, A

00008fb6 <.LM65>:

    switch (pDiagTransfer->request.reqSId) {
    8fb6:	62f0      	lod	AL, [Y]
    8fb8:	4205      	mov	[S-6], AL
    8fba:	6205      	lod	AL, [S-6]
    8fbc:	8cb2      	cmp	AL, #-78
    8fbe:	1d01      	jne	0x8fc2 <.LM65+0xc>
    8fc0:	0061      	jmp	0x9084 <.L35>
    8fc2:	5cf2      	usex	A
    8fc4:	aeda 00b2 	cmp	A, #178
    8fc8:	1e11      	jug	0x8fec <.L36>
    8fca:	aeda 00b0 	cmp	A, #176
    8fce:	1d01      	jne	0x8fd2 <.L34>
    8fd0:	0040      	jmp	0x9052 <.L37>

00008fd2 <.L34>:
 * - false There is nothing to send (no response).
 */
static bool ld_DiagResponse (void)
{
    bool retVal = true;
    SlaveResponse_t thisPendingSlaveResponse = pendingSlaveResponse;
    8fd2:	7ed8 1190 	lod	X, 0x1190 <_pendingSlaveResponse>

00008fd6 <.LM67>:

    /* reset pending response after processing */
    /* speculative next state/response, overwrite if otherwise */
    pendingSlaveResponse = respNoResponse;
    8fd6:	7000      	lod	A, #0
    8fd8:	52d8 1190 	mov	0x1190 <_pendingSlaveResponse>, A

00008fdc <.LM68>:

    switch (thisPendingSlaveResponse) {
    8fdc:	20ff      	add	X, #-1

00008fde <.LVL53>:
    8fde:	2c06      	cmp	X, #6
    8fe0:	1a01      	jule	0x8fe4 <.LVL53+0x6>
    8fe2:	00d2      	jmp	0x9188 <.L61>
    8fe4:	442e      	asl	X
    8fe6:	22da 5d44 	add	X, #23876
    8fea:	76f8      	jmp	[X]

00008fec <.L36>:
    /* A new MRF received,
     * so reset pending response
     */
    pendingSlaveResponse = respNoResponse;

    switch (pDiagTransfer->request.reqSId) {
    8fec:	aeda 00b6 	cmp	A, #182
    8ff0:	1d01      	jne	0x8ff4 <.L36+0x8>
    8ff2:	0086      	jmp	0x9100 <.L38>
    8ff4:	aeda 00b7 	cmp	A, #183
    8ff8:	1d6c      	jne	0x8fd2 <.L34>

00008ffa <.LBB43>:
 * @return: Requested response or respNoResponse.
 */
static SlaveResponse_t assignFrameIdRange (void)
{
    /* wrong PCI */
    if (pDiagTransfer->request.dataLen != 0x05U) { /* if (PCI-1) is not correct .. */
    8ffa:	72f2      	lod	A, [Y+2]
    8ffc:	ac05      	cmp	A, #5
    8ffe:	1d27      	jne	0x904e <.L45>

00009000 <.LM71>:
        return respNoResponse;
    }

    /* invalid start index */
    if (pDiagTransfer->request.data[0] >= SL_NUMBER_OF_DYNAMIC_MESSAGES) {
    9000:	62f4      	lod	AL, [Y+4]
    9002:	4207      	mov	[S-8], AL
    9004:	8c02      	cmp	AL, #2
    9006:	1e23      	jug	0x904e <.L45>

00009008 <.LBB45>:
    } else {
        l_u8 *pid;
        l_u8 index;
        l_u8 i;

        index = pDiagTransfer->request.data[0] + 3u; /* index of the last frame in the range */
    9008:	8003      	add	AL, #3
    900a:	5cf2      	usex	A
    900c:	5205      	mov	[S-6], A

0000900e <.LM73>:
        pid = &pDiagTransfer->request.data[4]; /* PID of the last frame in the range */
    900e:	e008      	add	Y, #8

00009010 <.LVL57>:
    9010:	6207      	lod	AL, [S-8]

00009012 <.LVL58>:
    9012:	80ff      	add	AL, #-1
    9014:	5cf2      	usex	A
    9016:	5207      	mov	[S-8], A

00009018 <.L52>:

        for (i = 0U; i < 4U; i++) {
            if (*pid != 0xFFU) {                                /* if id is NOT 0xFF .. */
    9018:	62f0      	lod	AL, [Y]
    901a:	8cff      	cmp	AL, #-1
    901c:	1d01      	jne	0x9020 <.LM75>
    901e:	0082      	jmp	0x9124 <.L46>

00009020 <.LM75>:
                if (index >= SL_NUMBER_OF_DYNAMIC_MESSAGES) {   /* if wrong index for valid pid .. */
    9020:	7205      	lod	A, [S-6]
    9022:	ac02      	cmp	A, #2
    9024:	1e14      	jug	0x904e <.L45>

00009026 <.LM76>:
                    return respNoResponse;
                } else {                                          /* proper index */
                    (void)ml_Disconnect();
    9026:	5a03      	mov	[S-4], Y
    9028:	82db 11f0 	callf	0x23e0 <_ml_Disconnect>

0000902c <.LM77>:
                    if (*pid == 0x00U) {                        /* unassign */
    902c:	7a03      	lod	Y, [S-4]
    902e:	62f0      	lod	AL, [Y]
    9030:	4201      	mov	[S-2], AL
    9032:	5cf2      	usex	A
    9034:	7ee2      	lod	X, A
    9036:	6201      	lod	AL, [S-2]
    9038:	1901      	je	0x903c <.LM78>
    903a:	007e      	jmp	0x9138 <.L47>

0000903c <.LM78>:
                        if (ml_DisableMessage(index) != ML_SUCCESS) {
    903c:	7205      	lod	A, [S-6]
    903e:	82db 1175 	callf	0x22ea <_ml_DisableMessage>
    9042:	7a03      	lod	Y, [S-4]
    9044:	ac00      	cmp	A, #0
    9046:	1d01      	jne	0x904a <.L51>
    9048:	0065      	jmp	0x9114 <.L48>

0000904a <.L51>:
                            (void)ml_Connect();
    904a:	82db 11ee 	callf	0x23dc <_ml_Connect>

0000904e <.L45>:
 */
static SlaveResponse_t assignFrameIdRange (void)
{
    /* wrong PCI */
    if (pDiagTransfer->request.dataLen != 0x05U) { /* if (PCI-1) is not correct .. */
        return respNoResponse;
    904e:	7000      	lod	A, #0
    9050:	0016      	jmp	0x907e <.L49>

00009052 <.L37>:
 *
 * @return: Requested response or respNoResponse
 */
static SlaveResponse_t assignNAD (void)
{
    if (pDiagTransfer->request.dataLen != 0x05u) {
    9052:	72f2      	lod	A, [Y+2]
    9054:	ac05      	cmp	A, #5
    9056:	1d7b      	jne	0x904e <.L45>

00009058 <.LM82>:
        return respNoResponse;
    }
    /* else: (PCI-1) is valid, continue processing .. */

    /* Validate SupplierID [3..4] and FunctionID [5..6] */
    if ( (isSupplierIdValid(&pDiagTransfer->request.data[0]) == ML_SUCCESS) &&
    9058:	72e6      	lod	A, Y
    905a:	a004      	add	A, #4
    905c:	5a03      	mov	[S-4], Y
    905e:	1787      	call	0x8f6e <_isSupplierIdValid>

00009060 <.LVL65>:
    9060:	5205      	mov	[S-6], A
    9062:	7a03      	lod	Y, [S-4]
    9064:	ac00      	cmp	A, #0
    9066:	1d73      	jne	0x904e <.L45>

00009068 <.LM83>:
         (isFunctionIdValid(&pDiagTransfer->request.data[2]) == ML_SUCCESS) ) {
    9068:	72e6      	lod	A, Y
    906a:	a006      	add	A, #6
    906c:	178f      	call	0x8f8c <_isFunctionIdValid>

0000906e <.LM84>:
        return respNoResponse;
    }
    /* else: (PCI-1) is valid, continue processing .. */

    /* Validate SupplierID [3..4] and FunctionID [5..6] */
    if ( (isSupplierIdValid(&pDiagTransfer->request.data[0]) == ML_SUCCESS) &&
    906e:	7a03      	lod	Y, [S-4]
    9070:	ac00      	cmp	A, #0
    9072:	1d6d      	jne	0x904e <.L45>

00009074 <.LM85>:
         (isFunctionIdValid(&pDiagTransfer->request.data[2]) == ML_SUCCESS) ) {
        ml_ConfiguredNAD = pDiagTransfer->request.data[4];   /* new NAD */
    9074:	e008      	add	Y, #8
    9076:	62f0      	lod	AL, [Y]
    9078:	42d8 10a4 	mov	0x10a4 <_ml_ConfiguredNAD>, AL

0000907c <.LM86>:
        return respPositiveAssignNAD;
    907c:	7004      	lod	A, #4

0000907e <.L49>:
            break; /* !case 0xB6 */
#endif /* SL_vLIN_2_1_plus || SL_vISO17987_2016 */

#if SL_vLIN_2_1_plus || SL_vISO17987_2016
        case 0xB7: /* Assign Frame ID range */
            pendingSlaveResponse = assignFrameIdRange();
    907e:	52d8 1190 	mov	0x1190 <_pendingSlaveResponse>, A

00009082 <.LM88>:
            break; /* !case 0xB7 */
    9082:	07a7      	jmp	0x8fd2 <.L34>

00009084 <.L35>:
 */
static SlaveResponse_t readByIdentifier (void)
{
    SlaveResponse_t retVal;

    if (pDiagTransfer->request.dataLen != 0x05u) {
    9084:	72f2      	lod	A, [Y+2]
    9086:	ac05      	cmp	A, #5
    9088:	1901      	je	0x908c <.LM90>
    908a:	0034      	jmp	0x90f4 <.L66>

0000908c <.LM90>:
        retVal = respNoResponse;
    } else {
        /* else: (PCI-1) is valid, continue processing .. */

        /* Validate SupplierID [4..5] and FunctionID [6..7] */
        if ( (isSupplierIdValid(&pDiagTransfer->request.data[1]) == ML_SUCCESS) &&
    908c:	72e6      	lod	A, Y
    908e:	a005      	add	A, #5
    9090:	5a03      	mov	[S-4], Y
    9092:	176d      	call	0x8f6e <_isSupplierIdValid>

00009094 <.LVL68>:
    9094:	5205      	mov	[S-6], A
    9096:	7a03      	lod	Y, [S-4]
    9098:	ac00      	cmp	A, #0
    909a:	1d2c      	jne	0x90f4 <.L66>

0000909c <.LM91>:
             (isFunctionIdValid(&pDiagTransfer->request.data[3]) == ML_SUCCESS) ) {
    909c:	72e6      	lod	A, Y
    909e:	a007      	add	A, #7
    90a0:	1775      	call	0x8f8c <_isFunctionIdValid>

000090a2 <.LM92>:
        retVal = respNoResponse;
    } else {
        /* else: (PCI-1) is valid, continue processing .. */

        /* Validate SupplierID [4..5] and FunctionID [6..7] */
        if ( (isSupplierIdValid(&pDiagTransfer->request.data[1]) == ML_SUCCESS) &&
    90a2:	7a03      	lod	Y, [S-4]
    90a4:	ac00      	cmp	A, #0
    90a6:	1d26      	jne	0x90f4 <.L66>

000090a8 <.LM93>:
             (isFunctionIdValid(&pDiagTransfer->request.data[3]) == ML_SUCCESS) ) {

            /* if supplier/function IDs are valid .. */

            switch (pDiagTransfer->request.data[0]) {    /* check IDs ..  */
    90a8:	62f4      	lod	AL, [Y+4]
    90aa:	4205      	mov	[S-6], AL
    90ac:	6205      	lod	AL, [S-6]
    90ae:	1924      	je	0x90f8 <.L68>
    90b0:	5cf2      	usex	A
    90b2:	7ee2      	lod	X, A
    90b4:	ac01      	cmp	A, #1
    90b6:	1d04      	jne	0x90c0 <.L76>

000090b8 <.LM94>:
                    retVal = respLinProductID;
                    break;

#if SL_EN_SERIAL_NUMBER_CALLOUT
                case 0x01:                      /* ID: Serial number (optional) */
                    retVal = respSerialNumber;
    90b8:	7803      	lod	Y, #3

000090ba <.L41>:
            break;
#endif /* SL_vLIN_2_0 || (SL_vSAE_J2602_2012 && SL_EN_ASSIGN_FRAME_ID_SERVICE) */

#if SL_vLIN_2_x || SL_vISO17987_2016 || (SL_vSAE_J2602_2012 && SL_EN_READ_BY_ID_SERVICE)
        case 0xB2: /* Read by Identifier request */
            pendingSlaveResponse = readByIdentifier();
    90ba:	5ad8 1190 	mov	0x1190 <_pendingSlaveResponse>, Y

000090be <.LM96>:
            break;
    90be:	0789      	jmp	0x8fd2 <.L34>

000090c0 <.L76>:
                    break;
#endif /* SL_vISO17987_2016 && SL_EN_NCF_LDF_VERSION */

                default:
#if SL_EN_READ_BY_ID_CALLOUT
                    if ( (pDiagTransfer->request.data[0] > 31u ) && (pDiagTransfer->request.data[0] < 64u) ) {
    90c0:	6205      	lod	AL, [S-6]
    90c2:	80e0      	add	AL, #-32
    90c4:	8c1f      	cmp	AL, #31
    90c6:	1e1a      	jug	0x90fc <.L69>

000090c8 <.LBB52>:
                        l_u8 pci = 6; /* Default value */
    90c8:	6006      	lod	AL, #6
    90ca:	4209      	mov	[S-10], AL

000090cc <.LM99>:
                        l_u8 response = ld_read_by_id_callout (dummy,
                                                               pDiagTransfer->request.data[0],
                                                               (l_u8*)&pci,
                                                               pDiagTransfer->response.data);
    90cc:	e004      	add	Y, #4

000090ce <.LM100>:

                default:
#if SL_EN_READ_BY_ID_CALLOUT
                    if ( (pDiagTransfer->request.data[0] > 31u ) && (pDiagTransfer->request.data[0] < 64u) ) {
                        l_u8 pci = 6; /* Default value */
                        l_u8 response = ld_read_by_id_callout (dummy,
    90ce:	5adf      	push	Y

000090d0 <.LCFI5>:
    90d0:	72ef      	lod	A, S
    90d2:	a0f4      	add	A, #-12
    90d4:	52df      	push	A

000090d6 <.LCFI6>:
    90d6:	5edf      	push	X

000090d8 <.LCFI7>:
    90d8:	72d8 13d2 	lod	A, 0x13d2 <_dummy>
    90dc:	168b      	call	0x8df4 <_ld_read_by_id_callout>
    90de:	7ae2      	lod	Y, A

000090e0 <.LM101>:
                                                               pDiagTransfer->request.data[0],
                                                               (l_u8*)&pci,
                                                               pDiagTransfer->response.data);
                        pDiagTransfer->response.dataLen = (l_u16)pci - 1u; /* Convert PCI to data length */
    90e0:	7ed8 118e 	lod	X, 0x118e <_pDiagTransfer>
    90e4:	620f      	lod	AL, [S-16]

000090e6 <.LVL72>:
    90e6:	5cf2      	usex	A
    90e8:	a0ff      	add	A, #-1
    90ea:	52fa      	mov	[X+2], A

000090ec <.LM102>:
                        pDiagTransfer->response.respSId = RSID(SID_ReadById);
    90ec:	60f2      	lod	AL, #-14
    90ee:	42f8      	mov	[X], AL

000090f0 <.LVL73>:
    90f0:	5c05      	dec	S, #6

000090f2 <.LCFI8>:
    90f2:	07e3      	jmp	0x90ba <.L41>

000090f4 <.L66>:
{
    SlaveResponse_t retVal;

    if (pDiagTransfer->request.dataLen != 0x05u) {
        /* if (PCI-1) is not valid .. */
        retVal = respNoResponse;
    90f4:	7800      	lod	Y, #0
    90f6:	07e1      	jmp	0x90ba <.L41>

000090f8 <.L68>:

            /* if supplier/function IDs are valid .. */

            switch (pDiagTransfer->request.data[0]) {    /* check IDs ..  */
                case 0x00:                      /* ID: LIN Product Identification */
                    retVal = respLinProductID;
    90f8:	7801      	lod	Y, #1
    90fa:	07df      	jmp	0x90ba <.L41>

000090fc <.L69>:
                        retVal = (SlaveResponse_t)response;
                        break;
                    }
                    /* else : wrong ID */
#endif /* SL_EN_READ_BY_ID_CALLOUT */
                    retVal = respNegativeResponse;
    90fc:	7802      	lod	Y, #2
    90fe:	07dd      	jmp	0x90ba <.L41>

00009100 <.L38>:
/** Process Save Configuration frame.
 * @return  void
 */
static SlaveResponse_t saveConfiguration (void)
{
    if (pDiagTransfer->request.dataLen != 0u) {
    9100:	72f2      	lod	A, [Y+2]
    9102:	1901      	je	0x9106 <.LM107>
    9104:	07a4      	jmp	0x904e <.L45>

00009106 <.LM107>:
        /* if (PCI-1) is not correct .. */
        return respNoResponse;
    }
    /* else: (PCI-1) is correct, continue processing .. */

    s_ifcStatus.mapped.SaveConfig = true;
    9106:	7eda 13d4 	lod	X, #5076
    910a:	62f8      	lod	AL, [X]
    910c:	8440      	or	AL, #64
    910e:	42f8      	mov	[X], AL

00009110 <.LM108>:

    return respPositiveSaveConfig;
    9110:	7006      	lod	A, #6
    9112:	07b5      	jmp	0x907e <.L49>

00009114 <.L48>:
                        }
                        /* else save unassignment to node_configuration */

#if ((SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE) || ((SL_vLIN_2_0 || SL_vSAE_J2602_2012) && \
                        SL_EN_SAVE_CONFIG_FUNC)
                        node_configuration[index] = 0x00U;
    9114:	7e05      	lod	X, [S-6]
    9116:	22da 13da 	add	X, #5082
    911a:	42f8      	mov	[X], AL

0000911c <.L50>:
                        }
                        /* else: don't store PID */
#endif /* !SL_vSAE_J2602_2012 && SL_EN_EVENT_TRIGGERED_FRAMES */
                    } /* assign */

                    (void)ml_Connect();
    911c:	5a03      	mov	[S-4], Y
    911e:	82db 11ee 	callf	0x23dc <_ml_Connect>
    9122:	7a03      	lod	Y, [S-4]

00009124 <.L46>:
                } /* proper index */
            } else {   /* id is 0xFF .. */
                       /* .. skip PID from processing */
            }

            --pid;          /*lint !e960 : deviation MISRA 2004:17.4 pointer decrement */
    9124:	e0ff      	add	Y, #-1

00009126 <.LM112>:
            --index;        /* get previous index */
    9126:	6205      	lod	AL, [S-6]
    9128:	80ff      	add	AL, #-1
    912a:	5cf2      	usex	A
    912c:	5205      	mov	[S-6], A

0000912e <.LM113>:
        l_u8 i;

        index = pDiagTransfer->request.data[0] + 3u; /* index of the last frame in the range */
        pid = &pDiagTransfer->request.data[4]; /* PID of the last frame in the range */

        for (i = 0U; i < 4U; i++) {
    912e:	ae07      	cmp	A, [S-8]
    9130:	1901      	je	0x9134 <.LM114>
    9132:	0772      	jmp	0x9018 <.L52>

00009134 <.LM114>:

            --pid;          /*lint !e960 : deviation MISRA 2004:17.4 pointer decrement */
            --index;        /* get previous index */
        } /* for 4 pids */

        return respPositiveAssignFidRange;
    9134:	7005      	lod	A, #5

00009136 <.LVL81>:
    9136:	07a3      	jmp	0x907e <.L49>

00009138 <.L47>:
#if ((SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE) || ((SL_vLIN_2_0 || SL_vSAE_J2602_2012) && \
                        SL_EN_SAVE_CONFIG_FUNC)
                        node_configuration[index] = 0x00U;
#endif /* ((SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE) || ((SL_vLIN_2_0 || SL_vSAE_J2602_2012) && SL_EN_SAVE_CONFIG_FUNC) */
                    } else {                                      /* assign */
                        if (ml_AssignFrameToMessageID(index,*pid) != ML_SUCCESS) {
    9138:	5edf      	push	X

0000913a <.LCFI9>:
    913a:	7207      	lod	A, [S-8]
    913c:	5a05      	mov	[S-6], Y
    913e:	82db 1172 	callf	0x22e4 <_ml_AssignFrameToMessageID>
    9142:	5c01      	dec	S, #2

00009144 <.LCFI10>:
    9144:	7a03      	lod	Y, [S-4]
    9146:	ac00      	cmp	A, #0
    9148:	1901      	je	0x914c <.LM116>
    914a:	077f      	jmp	0x904a <.L51>

0000914c <.LM116>:
                        /* else: assignment was OK, continue processing */

#if ((SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE) || ((SL_vLIN_2_0 || SL_vSAE_J2602_2012) && \
                        SL_EN_SAVE_CONFIG_FUNC)
                        /* save assignment to node_configuration */
                        node_configuration[index] = *pid;
    914c:	7e05      	lod	X, [S-6]
    914e:	22da 13da 	add	X, #5082
    9152:	0ea7      	lod	C, ML.7
    9154:	54c4      	movsb	[X++], [Y++]

00009156 <.LVL86>:
    9156:	e0ff      	add	Y, #-1
    9158:	07e1      	jmp	0x911c <.L50>

0000915a <.L54>:
            retVal = false;
            break;

#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_EN_READ_BY_ID_SERVICE
        case respLinProductID:
            pDiagTransfer->response.respSId = RSID(SID_ReadById);
    915a:	7ed8 118e 	lod	X, 0x118e <_pDiagTransfer>
    915e:	60f2      	lod	AL, #-14
    9160:	42f8      	mov	[X], AL

00009162 <.LM118>:
            pDiagTransfer->response.dataLen = 5u; /* Only data bytes length */
    9162:	7005      	lod	A, #5
    9164:	52fa      	mov	[X+2], A

00009166 <.LM119>:
            pDiagTransfer->response.data[0] = ml_ProductID[0];
    9166:	62d8 5d8a 	lod	AL, 0x5d8a <_ml_ProductID>
    916a:	42fc      	mov	[X+4], AL

0000916c <.LM120>:
            pDiagTransfer->response.data[1] = ml_ProductID[1];
    916c:	62d8 5d8b 	lod	AL, 0x5d8b <_ml_ProductID+0x1>
    9170:	42fd      	mov	[X+5], AL

00009172 <.LM121>:
            pDiagTransfer->response.data[2] = ml_ProductID[2];
    9172:	62d8 5d8c 	lod	AL, 0x5d8c <_ml_ProductID+0x2>
    9176:	42fe      	mov	[X+6], AL

00009178 <.LM122>:
            pDiagTransfer->response.data[3] = ml_ProductID[3];
    9178:	62d8 5d8d 	lod	AL, 0x5d8d <_ml_ProductID+0x3>
    917c:	42ff      	mov	[X+7], AL

0000917e <.LM123>:
            pDiagTransfer->response.data[4] = ml_ProductID[4];
    917e:	2008      	add	X, #8
    9180:	62d8 5d8e 	lod	AL, 0x5d8e <_ml_ProductID+0x4>
    9184:	42f8      	mov	[X], AL

00009186 <.L71>:
 * - true  There is data to send;
 * - false There is nothing to send (no response).
 */
static bool ld_DiagResponse (void)
{
    bool retVal = true;
    9186:	7001      	lod	A, #1

00009188 <.L61>:
            break;
    }

    /* Prepare the response */
    return ld_DiagResponse();
}
    9188:	540b      	ret	#12

0000918a <.L57>:
            pDiagTransfer->response.data[4] = ml_ProductID[4];
            break;

#if SL_EN_SERIAL_NUMBER_CALLOUT
        case respSerialNumber:
            pDiagTransfer->response.respSId = RSID(SID_ReadById);
    918a:	7ed8 118e 	lod	X, 0x118e <_pDiagTransfer>
    918e:	60f2      	lod	AL, #-14
    9190:	42f8      	mov	[X], AL

00009192 <.LM127>:
            pDiagTransfer->response.dataLen = 4u; /* Only data bytes length */
    9192:	7004      	lod	A, #4
    9194:	52fa      	mov	[X+2], A

00009196 <.LM128>:
            ld_serial_number_callout(&pDiagTransfer->response.data[0]); /* Insert Serial Number into data bytes 3..6 */
    9196:	72ee      	lod	A, X
    9198:	a004      	add	A, #4
    919a:	15eb      	call	0x8d72 <_ld_serial_number_callout>
    919c:	07f4      	jmp	0x9186 <.L71>

0000919e <.L56>:
            pDiagTransfer->response.data[4] = 0x00u; /* reserved */
            break;
#endif /* SL_vISO17987_2016 && SL_EN_NCF_LDF_VERSION */

        case respNegativeResponse:
            pDiagTransfer->response.respSId = RSID_NegativeResponse;
    919e:	7ed8 118e 	lod	X, 0x118e <_pDiagTransfer>
    91a2:	607f      	lod	AL, #127
    91a4:	42f8      	mov	[X], AL

000091a6 <.LM130>:
            pDiagTransfer->response.dataLen = 2u; /* Only data bytes length */
    91a6:	7002      	lod	A, #2
    91a8:	52fa      	mov	[X+2], A
    91aa:	72da 12b2 	lod	A, #4786
    91ae:	52fc      	mov	[X+4], A
    91b0:	07ea      	jmp	0x9186 <.L71>

000091b2 <.L58>:
            break;
#endif /* SL_vLIN_2_x || SL_vISO17987_2016 || SL_EN_READ_BY_ID_SERVICE */

#if SL_EN_ASSIGN_NAD_SERVICE
        case respPositiveAssignNAD:
            pDiagTransfer->response.respSId = RSID(SID_AssignNad);
    91b2:	7ed8 118e 	lod	X, 0x118e <_pDiagTransfer>
    91b6:	72da 00f0 	lod	A, #240

000091ba <.L77>:
            break;
#endif /* SL_vLIN_2_1_plus || SL_vISO17987_2016 */

#if (SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE
        case respPositiveSaveConfig:
            pDiagTransfer->response.respSId = RSID(SID_SaveConfiguration);
    91ba:	42f8      	mov	[X], AL

000091bc <.LM133>:
            pDiagTransfer->response.dataLen = 0u; /* Only data bytes length */
    91bc:	7000      	lod	A, #0
    91be:	52fa      	mov	[X+2], A
    91c0:	07e2      	jmp	0x9186 <.L71>

000091c2 <.L59>:
            break;
#endif /* SL_vSAE_J2602_2012 */

#if SL_vLIN_2_1_plus || SL_vISO17987_2016
        case respPositiveAssignFidRange:
            pDiagTransfer->response.respSId = RSID(SID_AssignFrameIdRange);
    91c2:	7ed8 118e 	lod	X, 0x118e <_pDiagTransfer>
    91c6:	72da 00f7 	lod	A, #247
    91ca:	07f7      	jmp	0x91ba <.L77>

000091cc <.L60>:
            break;
#endif /* SL_vLIN_2_1_plus || SL_vISO17987_2016 */

#if (SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE
        case respPositiveSaveConfig:
            pDiagTransfer->response.respSId = RSID(SID_SaveConfiguration);
    91cc:	7ed8 118e 	lod	X, 0x118e <_pDiagTransfer>
    91d0:	72da 00f6 	lod	A, #246
    91d4:	07f2      	jmp	0x91ba <.L77>

000091d6 <_l_sys_init>:
 * - 1 - fail.
 */
l_bool l_sys_init(void)
{
    return (l_bool)0u;
}
    91d6:	7000      	lod	A, #0
    91d8:	5401      	ret

000091da <_l_SetFlagsMask>:
 * @param[out]  dest    destination pointer
 * @param[in]   mask    used flags mask
 * @param[in]   size    area size
 */
void l_SetFlagsMask(volatile l_u8 *dest, const l_u8 *mask, const l_u8 size)
{
    91da:	5805      	inc	S, #6

000091dc <.LCFI0>:
    91dc:	5201      	mov	[S-2], A
    91de:	620b      	lod	AL, [S-12]

000091e0 <.LVL1>:
    91e0:	5cf2      	usex	A
    91e2:	5203      	mov	[S-4], A

000091e4 <.LBB6>:
    ENTER_STD_LIN_API_ATOMIC_SECTION();
    91e4:	16a5      	call	0x8f30 <_l_sys_irq_disable>
    91e6:	5205      	mov	[S-6], A

000091e8 <.LBB7>:
    for (l_u8 cnt = 0u; cnt < size; cnt++) {
    91e8:	7203      	lod	A, [S-4]

000091ea <.LVL4>:
    91ea:	190a      	je	0x9200 <.L3>
    91ec:	7e09      	lod	X, [S-10]
    91ee:	7a01      	lod	Y, [S-2]

000091f0 <.L4>:
        dest[cnt] |= mask[cnt];
    91f0:	62f0      	lod	AL, [Y]
    91f2:	86de      	or	AL, [X++]
    91f4:	42d6      	mov	[Y++], AL

000091f6 <.LM7>:
 * @param[in]   size    area size
 */
void l_SetFlagsMask(volatile l_u8 *dest, const l_u8 *mask, const l_u8 size)
{
    ENTER_STD_LIN_API_ATOMIC_SECTION();
    for (l_u8 cnt = 0u; cnt < size; cnt++) {
    91f6:	62e8      	lod	AL, YL
    91f8:	8a01      	sub	AL, [S-2]
    91fa:	5cf2      	usex	A
    91fc:	ae03      	cmp	A, [S-4]
    91fe:	1878      	jc	0x91f0 <.L4>

00009200 <.L3>:
 *
 */

STATIC INLINE void l_sys_irq_restore_pointer (const l_irqmask *p)
{
    l_sys_irq_restore(*p);
    9200:	7205      	lod	A, [S-6]
    9202:	169e      	call	0x8f40 <_l_sys_irq_restore>

00009204 <.LBE6>:
        dest[cnt] |= mask[cnt];
    }
    EXIT_STD_LIN_API_ATOMIC_SECTION();
}
    9204:	5407      	ret	#8

00009206 <_l_ifcUpdateOverrun>:
    9206:	7eda 13d4 	lod	X, #5076
    920a:	66f8      	lod	YL, [X]
    920c:	62e8      	lod	AL, YL
    920e:	9404      	and	AL, #4
    9210:	1d0a      	jne	0x9226 <.L1>

00009212 <.LM3>:
    9212:	62d8 1192 	lod	AL, 0x1192 <_s_ifcOverrunFramesCount>
    9216:	8001      	add	AL, #1
    9218:	42d8 1192 	mov	0x1192 <_s_ifcOverrunFramesCount>, AL

0000921c <.LM4>:
    921c:	8c01      	cmp	AL, #1
    921e:	1a03      	jule	0x9226 <.L1>

00009220 <.LM5>:
    9220:	62e8      	lod	AL, YL
    9222:	8404      	or	AL, #4
    9224:	42f8      	mov	[X], AL

00009226 <.L1>:
    9226:	5401      	ret

00009228 <_l_ifc_init_sl1>:
    9228:	163b      	call	0x8ea0 <_l_mls_Init>

0000922a <.LM9>:
    922a:	6000      	lod	AL, #0
    922c:	42d8 1192 	mov	0x1192 <_s_ifcOverrunFramesCount>, AL

00009230 <.LM10>:
    9230:	1689      	call	0x8f44 <_ld_DiagInit>

00009232 <.LM11>:
    9232:	82db 11ee 	callf	0x23dc <_ml_Connect>
    9236:	ac00      	cmp	A, #0
    9238:	5ca2      	sne	A

0000923a <.LM12>:
    923a:	5401      	ret

0000923c <_l_ifc_read_status_sl1>:
    923c:	5803      	inc	S, #4

0000923e <.LBB17>:
    923e:	1678      	call	0x8f30 <_l_sys_irq_disable>
    9240:	5203      	mov	[S-4], A

00009242 <.LM15>:
    9242:	7008      	lod	A, #8

00009244 <.LVL5>:
    9244:	82db 11d3 	callf	0x23a6 <_ml_GetState>

00009248 <.LM16>:
    9248:	62d8 1010 	lod	AL, 0x1010 <.LASF1500+0x8>
    924c:	9401      	and	AL, #1
    924e:	1905      	je	0x925a <.L7>

00009250 <.LM17>:
    9250:	7eda 13d4 	lod	X, #5076
    9254:	62f8      	lod	AL, [X]
    9256:	8410      	or	AL, #16
    9258:	42f8      	mov	[X], AL

0000925a <.L7>:
    925a:	7ad8 13d4 	lod	Y, 0x13d4 <_s_ifcStatus>

0000925e <.LM19>:
    925e:	6000      	lod	AL, #0
    9260:	42d8 1192 	mov	0x1192 <_s_ifcOverrunFramesCount>, AL

00009264 <.LM20>:
    9264:	0ea7      	lod	C, ML.7
    9266:	7000      	lod	A, #0
    9268:	52d8 13d4 	mov	0x13d4 <_s_ifcStatus>, A

0000926c <.LBB18>:
    926c:	7203      	lod	A, [S-4]
    926e:	5a01      	mov	[S-2], Y
    9270:	1667      	call	0x8f40 <_l_sys_irq_restore>

00009272 <.LBE17>:
    9272:	7a01      	lod	Y, [S-2]
    9274:	72e6      	lod	A, Y
    9276:	5405      	ret	#6

00009278 <_l_LinSleepMode>:
/** LIN Slave driver entered a sleep mode.
 * @param[in]   Reason    Reason of entering sleep mode.
 * @return void
 */
void l_LinSleepMode(ml_SleepReason_t Reason)
{
    9278:	7ee2      	lod	X, A

0000927a <.LM29>:

#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
    if (Reason == ml_reasonMaster) {
    927a:	ac01      	cmp	A, #1
    927c:	1d08      	jne	0x928e <.L14>

0000927e <.LM30>:
        s_ifcStatus.mapped.GoToSleep = true;
    927e:	7ada 13d4 	lod	Y, #5076

00009282 <.LM31>:
        /*
         * MLX4 FW handles Goto Sleep frame (0x3C, 0x00 ...) automatically
         * and does not report it via l_MessageReceived event.
         * Hence write Protected ID 0x3C explicitly.
         */
        s_ifcStatus.mapped.PID = 0x3C;
    9282:	603c      	lod	AL, #60

00009284 <.LVL14>:
    9284:	42d8 13d5 	mov	0x13d5 <_s_ifcStatus+0x1>, AL

00009288 <.LM32>:
        s_ifcStatus.mapped.SuccessfulTrans = true;
    9288:	62f0      	lod	AL, [Y]
    928a:	840a      	or	AL, #10
    928c:	42f0      	mov	[Y], AL

0000928e <.L14>:
    }
    /* else: other reasons of sleep don't required special care */
#endif /* SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012 */

    l_ifc_sleep_entered_callout(Reason);    /* notify application on the sleep reason */
    928e:	72ee      	lod	A, X
    9290:	05fb      	jmp	0x8e88 <_l_ifc_sleep_entered_callout>

00009292 <_l_MessageReceived>:
 * @note The Signals write and Flags update are done atomically.
 * Thus the Signals / Flags API functions are allowed to be used in other interrupts
 * with higher priority then LIN ISR.
 */
void l_MessageReceived(ml_MessageID_t MessageIndex)
{
    9292:	5801      	inc	S, #2

00009294 <.LCFI1>:
    9294:	7ae2      	lod	Y, A

00009296 <.LM36>:
#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
    /*
     * Successful transfer is set if a frame has been
     * transmitted/received without an error
     */
    s_ifcStatus.mapped.SuccessfulTrans = true;
    9296:	7eda 13d4 	lod	X, #5076
    929a:	62f8      	lod	AL, [X]

0000929c <.LVL17>:
    929c:	8402      	or	AL, #2
    929e:	42f8      	mov	[X], AL

000092a0 <.LM37>:
    s_ifcStatus.mapped.PID = ml_GetProtectedID();
    92a0:	5a01      	mov	[S-2], Y
    92a2:	82db 513c 	callf	0xa278 <_ml_GetProtectedID>
    92a6:	42d8 13d5 	mov	0x13d5 <_s_ifcStatus+0x1>, AL

000092aa <.LM38>:
#endif /* SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012 */


        if (MessageIndex < SL_NUMBER_OF_DYNAMIC_MESSAGES) {
    92aa:	7a01      	lod	Y, [S-2]
    92ac:	ec02      	cmp	Y, #2
    92ae:	1e0f      	jug	0x92ce <.L15>

000092b0 <.LBB20>:

        }
#else /*SUPPORT_MULTI_SLAVE*/

		/* Get Frame Handler */
		const l_s_UnconditionalFrame_t *uncondFrame = currentFrame->Frame;
    92b0:	44a6      	asl	Y, #2
    92b2:	e2da 5d7a 	add	Y, #23930

000092b6 <.LM40>:
		l_s_FrameHandler_t ProcessFrame = uncondFrame->FrameHandler;
    92b6:	7ef0      	lod	X, [Y]
    92b8:	7af8      	lod	Y, [X]

000092ba <.LM41>:

		/* Actions on the frame */
		(void)ProcessFrame(sfa_UpdateSignals); /* Use new signals values */
    92ba:	7000      	lod	A, #0
    92bc:	5a01      	mov	[S-2], Y
    92be:	0001      	jmp	0x92c2 <.L18>

000092c0 <.L17>:
    92c0:	76e6      	jmp	Y

000092c2 <.L18>:
    92c2:	17fe      	call	0x92c0 <.L17>

000092c4 <.LM42>:
		(void)ProcessFrame(sfa_SetFlags);   /* Mark corresponding signal's flags as received */
    92c4:	7003      	lod	A, #3
    92c6:	7a01      	lod	Y, [S-2]
    92c8:	0001      	jmp	0x92cc <.L20>

000092ca <.L19>:
    92ca:	76e6      	jmp	Y

000092cc <.L20>:
    92cc:	17fe      	call	0x92ca <.L19>

000092ce <.L15>:
#endif /* SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012 */
#endif /*SUPPORT_MULTI_SLAVE*/
    } else {
        /* Unexpected frame -> ignore */
    }
}
    92ce:	5403      	ret	#4

000092d0 <_l_DataRequest>:
/** Header of the relevant non-diagnostic slave-to-master frame has been received.
 * @param[in]    MessageIndex    Message index of the current Frame
 * @return  void
 */
void l_DataRequest (ml_MessageID_t MessageIndex)
{
    92d0:	5801      	inc	S, #2

000092d2 <.LCFI2>:
    if (MessageIndex < SL_NUMBER_OF_DYNAMIC_MESSAGES) {
    92d2:	ac02      	cmp	A, #2
    92d4:	1e16      	jug	0x9302 <.L22>

000092d6 <.LBB21>:
        /* Non-diagnostic message */
        /* Get the frame by message index */
        const l_s_Frame_t *currentFrame = (const l_s_Frame_t*)&frameList[MessageIndex];

        /* Unconditional frame */
        if (currentFrame->FrameType == sft_UnconditionalFrame) {
    92d6:	44a2      	asl	A, #2

000092d8 <.LVL27>:
    92d8:	7ee2      	lod	X, A
    92da:	22da 5d78 	add	X, #23928
    92de:	72f8      	lod	A, [X]
    92e0:	1d10      	jne	0x9302 <.L22>

000092e2 <.LBB22>:
            /* Get Frame Handler */
            const l_s_UnconditionalFrame_t *uncondFrame = currentFrame->Frame;
            const l_s_FrameHandler_t ProcessFrame = uncondFrame->FrameHandler;
    92e2:	7efa      	lod	X, [X+2]
    92e4:	7af8      	lod	Y, [X]

000092e6 <.LM48>:


#else	/*SUPPORT_MULTI_SLAVE*/

        /* Actions on the frame */
        (void)ProcessFrame(sfa_FillBuffer);          /* Fill the data buffer */
    92e6:	7001      	lod	A, #1
    92e8:	5a01      	mov	[S-2], Y
    92ea:	0001      	jmp	0x92ee <.L25>

000092ec <.L24>:
    92ec:	76e6      	jmp	Y

000092ee <.L25>:
    92ee:	17fe      	call	0x92ec <.L24>

000092f0 <.LM49>:
        (void)ProcessFrame(sfa_SetFlags);            /* Consider Signals as sent */
    92f0:	7003      	lod	A, #3
    92f2:	7a01      	lod	Y, [S-2]
    92f4:	0001      	jmp	0x92f8 <.L27>

000092f6 <.L26>:
    92f6:	76e6      	jmp	Y

000092f8 <.L27>:
    92f8:	17fe      	call	0x92f6 <.L26>

000092fa <.LM50>:

#if SL_vSAE_J2602_2012
        l_u8 api_info = mlu_SAE_SetStatusApiInfo(MessageIndex); /* call User Application */
        (void)ml_SAE_DataReady(api_info);            /* Notify driver */
#else
        (void)ml_DataReady(ML_END_OF_TX_ENABLED);    /* Notify driver */
    92fa:	7001      	lod	A, #1
    92fc:	82db 1167 	callf	0x22ce <_ml_DataReady>

00009300 <.LBE22>:
    9300:	5403      	ret	#4

00009302 <.L22>:
            }
        }
#endif /* !SL_vSAE_J2602_2012 && SL_EN_EVENT_TRIGGERED_FRAMES */
        /* Unexpected frame type -> ignore */
        else {
            (void)ml_DiscardFrame();
    9302:	82db 119a 	callf	0x2334 <_ml_DiscardFrame>

00009306 <.LBE21>:
    }
    /* Unexpected message index -> ignore */
    else {
        (void)ml_DiscardFrame();
    }
}
    9306:	5403      	ret	#4

00009308 <_l_ErrorDetected>:
            /* There is no J2602 only specific action for other errors */
            break;
    }
#endif /* SL_vSAE_J2602_2012 */

    switch (Error) {
    9308:	a0fc      	add	A, #-4

0000930a <.LVL35>:
    930a:	ac0c      	cmp	A, #12
    930c:	1e1b      	jug	0x9344 <.L28>
    930e:	4422      	asl	A
    9310:	7ee2      	lod	X, A
    9312:	22da 5d52 	add	X, #23890
    9316:	76f8      	jmp	[X]

00009318 <.L32>:
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Overvoltage, signal, Fwv_Overvoltage)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Overcurrent, signal, Fwv_Overcurrent)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Overtemperature, signal, Fwv_Overtemperature)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Diag_Forced_Status, signal, Fwv_Diag_Forced_Status)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Position_Sensor_Fault, signal, Fwv_Position_Sensor_Fault)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_CommErr, signal, Fwv_CommErr)
    9318:	160b      	call	0x8f30 <_l_sys_irq_disable>
    931a:	7ee2      	lod	X, A

0000931c <.LVL38>:
    931c:	62d8 13d8 	lod	AL, 0x13d8 <_l_sl1_flags+0x2>

00009320 <.LVL39>:
    9320:	94df      	and	AL, #-33
    9322:	42d8 13d8 	mov	0x13d8 <_l_sl1_flags+0x2>, AL
    9326:	72ee      	lod	A, X
    9328:	160b      	call	0x8f40 <_l_sys_irq_restore>

0000932a <.L33>:
L_SIGNAL(l_bool, Fwv_Overvoltage)
L_SIGNAL(l_bool, Fwv_Overcurrent)
L_SIGNAL(l_bool, Fwv_Overtemperature)
L_SIGNAL(l_bool, Fwv_Diag_Forced_Status)
L_SIGNAL(l_bool, Fwv_Position_Sensor_Fault)
L_SIGNAL(l_bool, Fwv_CommErr)
    932a:	6001      	lod	AL, #1
    932c:	42d8 11a9 	mov	0x11a9 <.LLST13+0x5>, AL

00009330 <.LBE31>:
             */
            l_flg_clr_response_error();

            l_bool_wr_response_error(true);
#endif /* !SL_vSAE_J2602_2012 */
            s_ifcStatus.mapped.ErrorInResponse = true;
    9330:	7eda 13d4 	lod	X, #5076
    9334:	62f8      	lod	AL, [X]
    9336:	8401      	or	AL, #1
    9338:	42f8      	mov	[X], AL

0000933a <.LM58>:
            s_ifcStatus.mapped.PID = ml_GetProtectedID();
    933a:	82db 513c 	callf	0xa278 <_ml_GetProtectedID>
    933e:	42d8 13d5 	mov	0x13d5 <_s_ifcStatus+0x1>, AL

00009342 <.LM59>:
#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
            l_ifcUpdateOverrun();
    9342:	1761      	call	0x9206 <_l_ifcUpdateOverrun>

00009344 <.L28>:
    }

#if !SL_vSAE_J2602_2012 && SL_EN_EVENT_TRIGGERED_FRAMES
    isNonUnconditional = snuft_False;
#endif /* !SL_vSAE_J2602_2012 && SL_EN_EVENT_TRIGGERED_FRAMES */
}
    9344:	5401      	ret

00009346 <_l_DataTransmitted>:
#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
    /*
     * Successful transfer is set if a frame has been
     * transmitted/received without an error
     */
    s_ifcStatus.mapped.SuccessfulTrans = true;
    9346:	7eda 13d4 	lod	X, #5076
    934a:	62f8      	lod	AL, [X]

0000934c <.LVL45>:
    934c:	8402      	or	AL, #2
    934e:	42f8      	mov	[X], AL

00009350 <.LM63>:
    s_ifcStatus.mapped.PID = ml_GetProtectedID();
    9350:	82db 513c 	callf	0xa278 <_ml_GetProtectedID>
    9354:	42d8 13d5 	mov	0x13d5 <_s_ifcStatus+0x1>, AL

00009358 <.LM64>:
    l_ifcUpdateOverrun();
    9358:	1756      	call	0x9206 <_l_ifcUpdateOverrun>

0000935a <.LBB39>:
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Overvoltage, signal, Fwv_Overvoltage)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Overcurrent, signal, Fwv_Overcurrent)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Overtemperature, signal, Fwv_Overtemperature)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Diag_Forced_Status, signal, Fwv_Diag_Forced_Status)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Position_Sensor_Fault, signal, Fwv_Position_Sensor_Fault)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_CommErr, signal, Fwv_CommErr)
    935a:	62d8 13d8 	lod	AL, 0x13d8 <_l_sl1_flags+0x2>

0000935e <.LBE39>:
    /*
     * The response_error flag is set when Response Error signal is copied to
     * frame buffer for transmission in the current frame. If an error occurred
     * during transmission, the flag is cleared in l_ErrorDetected handler.
     */
    if (l_flg_tst_response_error()) {
    935e:	9420      	and	AL, #32
    9360:	190c      	je	0x937a <.L34>

00009362 <.LBB41>:
    9362:	15e6      	call	0x8f30 <_l_sys_irq_disable>
    9364:	7ee2      	lod	X, A

00009366 <.LVL49>:
    9366:	62d8 13d8 	lod	AL, 0x13d8 <_l_sl1_flags+0x2>

0000936a <.LVL50>:
    936a:	94df      	and	AL, #-33
    936c:	42d8 13d8 	mov	0x13d8 <_l_sl1_flags+0x2>, AL
    9370:	72ee      	lod	A, X
    9372:	15e6      	call	0x8f40 <_l_sys_irq_restore>

00009374 <.LBB43>:
L_SIGNAL(l_bool, Fwv_Overvoltage)
L_SIGNAL(l_bool, Fwv_Overcurrent)
L_SIGNAL(l_bool, Fwv_Overtemperature)
L_SIGNAL(l_bool, Fwv_Diag_Forced_Status)
L_SIGNAL(l_bool, Fwv_Position_Sensor_Fault)
L_SIGNAL(l_bool, Fwv_CommErr)
    9374:	6000      	lod	AL, #0
    9376:	42d8 11a9 	mov	0x11a9 <.LLST13+0x5>, AL

0000937a <.L34>:
    }

    /* Notify user application about end of transmission */
    mlu_SAE_DataTransmitted();
#endif /* SL_vSAE_J2602_2012 */
}
    937a:	5401      	ret

0000937c <_l_AutoAddressingStep>:
 * @return  void
 */
__attribute__((weak)) void l_AutoAddressingStep(l_u8 StepNumber)
{
    (void)StepNumber;   /* unused parameter */
}
    937c:	5401      	ret

0000937e <_l_FillBufferSlave>:
/** Fill the data buffer from source
 * @param[in]   src     pointer to source
 * @param[in]   size    area size
 */
void l_FillBufferSlave(l_u8 *src, l_u8 size)
{
    937e:	5805      	inc	S, #6

00009380 <.LCFI3>:
    9380:	5205      	mov	[S-6], A

00009382 <.LBB45>:
    for (l_u8 cnt = 0; cnt < size; cnt++) {
    9382:	6209      	lod	AL, [S-10]

00009384 <.LVL56>:
    9384:	1911      	je	0x93a8 <.L40>
    9386:	5cf2      	usex	A
    9388:	5203      	mov	[S-4], A
    938a:	7000      	lod	A, #0

0000938c <.L42>:
        ((l_u8*)ML_SLAVE_FRAME_DATA_BUFFER)[cnt] = src[cnt];
    938c:	7e05      	lod	X, [S-6]
    938e:	22e2      	add	X, A
    9390:	7ae2      	lod	Y, A
    9392:	e2da 1004 	add	Y, #4100
    9396:	0ea7      	lod	C, ML.7
    9398:	54cc      	movsb	[Y++], [X++]

0000939a <.LVL58>:
    939a:	a001      	add	A, #1

0000939c <.LM75>:
 * @param[in]   src     pointer to source
 * @param[in]   size    area size
 */
void l_FillBufferSlave(l_u8 *src, l_u8 size)
{
    for (l_u8 cnt = 0; cnt < size; cnt++) {
    939c:	66e0      	lod	YL, AL
    939e:	5cf6      	usex	Y
    93a0:	5a01      	mov	[S-2], Y
    93a2:	7a03      	lod	Y, [S-4]
    93a4:	ee01      	cmp	Y, [S-2]
    93a6:	1e72      	jug	0x938c <.L42>

000093a8 <.L40>:
        ((l_u8*)ML_SLAVE_FRAME_DATA_BUFFER)[cnt] = src[cnt];
    }
}
    93a8:	5407      	ret	#8

000093aa <_l_sl1_Debug_Frame_handler>:
    l_u8 unused56  : 8;
} l_sl1_Debug_Frame_data_t;
ASSERT(sizeof(l_sl1_Debug_Frame_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_Debug_Frame_handler (l_s_FrameAction_t frameAction)
{
    93aa:	5809      	inc	S, #10

000093ac <.LCFI0>:
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    static const l_sl1_flags_t Debug_Frame_flags_mask = {{0x0, 0x0, 0x0, 0x2f}};

    switch (frameAction) {
    93ac:	ac01      	cmp	A, #1
    93ae:	190c      	je	0x93c8 <.L3>
    93b0:	1802      	jc	0x93b6 <.L4>
    93b2:	ac03      	cmp	A, #3
    93b4:	1d26      	jne	0x9402 <.L9>

000093b6 <.L4>:
            break;
        }
        case sfa_UpdateSignals:     /* For M2S frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&Debug_Frame_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
    93b6:	54ca 0004 	pushw	#4

000093ba <.LCFI1>:
    93ba:	54ca 5d74 	pushw	#23924

000093be <.LCFI2>:
    93be:	72da 13d6 	lod	A, #5078

000093c2 <.LVL2>:
    93c2:	170b      	call	0x91da <_l_SetFlagsMask>

000093c4 <.LM4>:
            break;
    93c4:	5c03      	dec	S, #4

000093c6 <.LCFI3>:
    93c6:	001b      	jmp	0x93fe <.L10>

000093c8 <.L3>:

    switch (frameAction) {
        case sfa_FillBuffer:    /* For S2M frames */
        {
            /* Freeze the volatile Signal values */
            l_u8 sig_d_valve_status = l_signals.d_valve_status;
    93c8:	66d8 11ad 	lod	YL, 0x11ad <.LLST13+0x9>

000093cc <.LM6>:
            l_u8 sig_d_motor_status = l_signals.d_motor_status;
    93cc:	62d8 11ae 	lod	AL, 0x11ae <.LLST13+0xa>

000093d0 <.LVL6>:
    93d0:	4200      	mov	[S-1], AL

000093d2 <.LM7>:
            l_u16 sig_d_debug_1 = l_signals.d_debug_1;
    93d2:	7ed8 11b0 	lod	X, 0x11b0 <.LASF1799+0x1>

000093d6 <.LM8>:
            l_u8 sig_d_debug_2 = l_signals.d_debug_2;
    93d6:	62d8 11b2 	lod	AL, 0x11b2 <.LASF1799+0x3>

000093da <.LVL9>:
    93da:	4201      	mov	[S-2], AL

000093dc <.LM9>:

            l_sl1_Debug_Frame_data_t Debug_Frame_data = {
    93dc:	4609      	mov	[S-10], YL
    93de:	6200      	lod	AL, [S-1]

000093e0 <.LVL11>:
    93e0:	4208      	mov	[S-9], AL
    93e2:	5e07      	mov	[S-8], X
    93e4:	6201      	lod	AL, [S-2]
    93e6:	4205      	mov	[S-6], AL
    93e8:	72da 00ff 	lod	A, #255
    93ec:	4204      	mov	[S-5], AL
    93ee:	4203      	mov	[S-4], AL
    93f0:	4202      	mov	[S-3], AL

000093f2 <.LM10>:
                sig_d_debug_2,
                0xff,
                0xff,
                0xff
            };
            l_FillBufferSlave((l_u8*)&Debug_Frame_data, (l_u8)sizeof(l_sl1_Debug_Frame_data_t));
    93f2:	54ca 0008 	pushw	#8

000093f6 <.LCFI4>:
    93f6:	72ef      	lod	A, S
    93f8:	a0f4      	add	A, #-12
    93fa:	17c1      	call	0x937e <_l_FillBufferSlave>

000093fc <.LVL13>:
    93fc:	5c01      	dec	S, #2

000093fe <.L10>:
} l_sl1_Debug_Frame_data_t;
ASSERT(sizeof(l_sl1_Debug_Frame_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_Debug_Frame_handler (l_s_FrameAction_t frameAction)
{
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    93fe:	7000      	lod	A, #0

00009400 <.LM12>:
        }
        case sfa_UpdateSignals:     /* For M2S frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&Debug_Frame_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
            break;
    9400:	540b      	ret	#12

00009402 <.L9>:
        }
        case sfa_CheckFlags:    /* Only for frames associated with an Event-triggered frame */
        default:
            retVal = sfhs_Fail;
    9402:	7001      	lod	A, #1

00009404 <.LM14>:
            break;
    }
    return retVal;
}
    9404:	540b      	ret	#12

00009406 <_l_sl1_VPC_Fwv_Ctrl_handler>:
static l_s_FrameHandlerStatus_t l_sl1_VPC_Fwv_Ctrl_handler (l_s_FrameAction_t frameAction)
{
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    static const l_sl1_flags_t VPC_Fwv_Ctrl_flags_mask = {{0x1f, 0x0, 0x0, 0x40}};

    switch (frameAction) {
    9406:	ac01      	cmp	A, #1
    9408:	1903      	je	0x9410 <.L13>
    940a:	180b      	jc	0x9422 <.L14>
    940c:	ac03      	cmp	A, #3
    940e:	1d28      	jne	0x9460 <.L22>

00009410 <.L13>:
            break;
        }
        case sfa_FillBuffer:    /* For S2M frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&VPC_Fwv_Ctrl_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
    9410:	54ca 0004 	pushw	#4

00009414 <.LCFI6>:
    9414:	54ca 5d70 	pushw	#23920

00009418 <.LCFI7>:
    9418:	72da 13d6 	lod	A, #5078

0000941c <.LVL17>:
    941c:	16de      	call	0x91da <_l_SetFlagsMask>

0000941e <.LM18>:
            break;
    941e:	5c03      	dec	S, #4

00009420 <.LCFI8>:
    9420:	001d      	jmp	0x945c <.L23>

00009422 <.L14>:

    switch (frameAction) {
        case sfa_UpdateSignals:    /* For M2S frames */
        {
            l_sl1_VPC_Fwv_Ctrl_data_t MLXCOMP_354_WA *VPC_Fwv_Ctrl_data = (l_sl1_VPC_Fwv_Ctrl_data_t*)ML_SLAVE_FRAME_DATA_BUFFER;
            l_signals.Fwv_Target_Mode = VPC_Fwv_Ctrl_data->sig_Fwv_Target_Mode;
    9422:	7eda 1004 	lod	X, #4100
    9426:	62f8      	lod	AL, [X]

00009428 <.LVL20>:
    9428:	9407      	and	AL, #7
    942a:	42d8 1194 	mov	0x1194 <_l_signals>, AL

0000942e <.LM20>:
            l_signals.Fwv_MoveEnable = VPC_Fwv_Ctrl_data->sig_Fwv_MoveEnable;
    942e:	62f8      	lod	AL, [X]
    9430:	44b0      	lsr	AL, #2
    9432:	4430      	lsr	AL
    9434:	9401      	and	AL, #1
    9436:	42d8 1195 	mov	0x1195 <_l_signals+0x1>, AL

0000943a <.LM21>:
            l_signals.Fwv_Initial = VPC_Fwv_Ctrl_data->sig_Fwv_Initial;
    943a:	62f8      	lod	AL, [X]
    943c:	44b0      	lsr	AL, #2
    943e:	44b0      	lsr	AL, #2
    9440:	9401      	and	AL, #1
    9442:	42d8 1196 	mov	0x1196 <_l_signals+0x2>, AL

00009446 <.LM22>:
            l_signals.Fwv_ForcedDiag = VPC_Fwv_Ctrl_data->sig_Fwv_ForcedDiag;
    9446:	62f8      	lod	AL, [X]
    9448:	44b0      	lsr	AL, #2
    944a:	44b0      	lsr	AL, #2
    944c:	4430      	lsr	AL
    944e:	9401      	and	AL, #1
    9450:	42d8 1197 	mov	0x1197 <_l_signals+0x3>, AL

00009454 <.LM23>:
            l_signals.Fwv_Reserved1 = VPC_Fwv_Ctrl_data->sig_Fwv_Reserved1;
    9454:	62d8 1005 	lod	AL, 0x1005 <_ml_Data+0x1>
    9458:	42d8 1198 	mov	0x1198 <_l_signals+0x4>, AL

0000945c <.L23>:
} l_sl1_VPC_Fwv_Ctrl_data_t;
ASSERT(sizeof(l_sl1_VPC_Fwv_Ctrl_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_VPC_Fwv_Ctrl_handler (l_s_FrameAction_t frameAction)
{
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    945c:	7000      	lod	A, #0

0000945e <.LM25>:
        }
        case sfa_FillBuffer:    /* For S2M frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&VPC_Fwv_Ctrl_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
            break;
    945e:	5401      	ret

00009460 <.L22>:
        }
        case sfa_CheckFlags:    /* Only for frames associated with an Event-triggered frame */
        default:
            retVal = sfhs_Fail;
    9460:	7001      	lod	A, #1

00009462 <.LM27>:
            break;
    }
    return retVal;
}
    9462:	5401      	ret

00009464 <_l_sl1_VPC_Fwv_Resp_handler>:
    l_u8 unused56  : 8;
} l_sl1_VPC_Fwv_Resp_data_t;
ASSERT(sizeof(l_sl1_VPC_Fwv_Resp_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_VPC_Fwv_Resp_handler (l_s_FrameAction_t frameAction)
{
    9464:	582f      	inc	S, #48

00009466 <.LCFI9>:
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    static const l_sl1_flags_t VPC_Fwv_Resp_flags_mask = {{0xe0, 0xff, 0xff, 0x10}};

    switch (frameAction) {
    9466:	ac01      	cmp	A, #1
    9468:	190d      	je	0x9484 <.L26>
    946a:	1803      	jc	0x9472 <.L27>
    946c:	ac03      	cmp	A, #3
    946e:	1901      	je	0x9472 <.L27>
    9470:	00e0      	jmp	0x9632 <.L32>

00009472 <.L27>:
            break;
        }
        case sfa_UpdateSignals:     /* For M2S frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&VPC_Fwv_Resp_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
    9472:	54ca 0004 	pushw	#4

00009476 <.LCFI10>:
    9476:	54ca 5d6c 	pushw	#23916

0000947a <.LCFI11>:
    947a:	72da 13d6 	lod	A, #5078

0000947e <.LVL26>:
    947e:	16ad      	call	0x91da <_l_SetFlagsMask>

00009480 <.LM31>:
            break;
    9480:	5c03      	dec	S, #4

00009482 <.LCFI12>:
    9482:	00d5      	jmp	0x962e <.L33>

00009484 <.L26>:

    switch (frameAction) {
        case sfa_FillBuffer:    /* For S2M frames */
        {
            /* Freeze the volatile Signal values */
            l_u8 sig_Fwv_Actual_Mode = l_signals.Fwv_Actual_Mode;
    9484:	66d8 1199 	lod	YL, 0x1199 <_l_signals+0x5>

00009488 <.LM33>:
            l_bool sig_Fwv_Position_Fault = l_signals.Fwv_Position_Fault;
    9488:	62d8 119a 	lod	AL, 0x119a <_l_signals+0x6>

0000948c <.LVL30>:
    948c:	4205      	mov	[S-6], AL

0000948e <.LM34>:
            l_bool sig_Fwv_FaultMode = l_signals.Fwv_FaultMode;
    948e:	62d8 119b 	lod	AL, 0x119b <_l_signals+0x7>

00009492 <.LVL32>:
    9492:	4209      	mov	[S-10], AL

00009494 <.LM35>:
            l_bool sig_Fwv_ProtectMode = l_signals.Fwv_ProtectMode;
    9494:	62d8 119c 	lod	AL, 0x119c <_l_signals+0x8>

00009498 <.LVL34>:
    9498:	420b      	mov	[S-12], AL

0000949a <.LM36>:
            l_bool sig_Fwv_InitialSta = l_signals.Fwv_InitialSta;
    949a:	62d8 119d 	lod	AL, 0x119d <_l_signals+0x9>

0000949e <.LVL36>:
    949e:	420d      	mov	[S-14], AL

000094a0 <.LM37>:
            l_bool sig_Fwv_Calibration_Fail = l_signals.Fwv_Calibration_Fail;
    94a0:	62d8 119e 	lod	AL, 0x119e <_l_signals+0xa>

000094a4 <.LVL38>:
    94a4:	420f      	mov	[S-16], AL

000094a6 <.LM38>:
            l_bool sig_Fwv_MoveEnable_Status = l_signals.Fwv_MoveEnable_Status;
    94a6:	62d8 119f 	lod	AL, 0x119f <_l_signals+0xb>

000094aa <.LVL40>:
    94aa:	4211      	mov	[S-18], AL

000094ac <.LM39>:
            l_bool sig_Fwv_Motor_Stall = l_signals.Fwv_Motor_Stall;
    94ac:	62d8 11a0 	lod	AL, 0x11a0 <_l_signals+0xc>

000094b0 <.LVL42>:
    94b0:	4213      	mov	[S-20], AL

000094b2 <.LM40>:
            l_bool sig_Fwv_Short_Circuit = l_signals.Fwv_Short_Circuit;
    94b2:	62d8 11a1 	lod	AL, 0x11a1 <.LASF1798>

000094b6 <.LVL44>:
    94b6:	4215      	mov	[S-22], AL

000094b8 <.LM41>:
            l_bool sig_Fwv_Open_Circuit = l_signals.Fwv_Open_Circuit;
    94b8:	62d8 11a2 	lod	AL, 0x11a2 <.LASF1798+0x1>

000094bc <.LVL46>:
    94bc:	4217      	mov	[S-24], AL

000094be <.LM42>:
            l_bool sig_Fwv_Undervoltage = l_signals.Fwv_Undervoltage;
    94be:	62d8 11a3 	lod	AL, 0x11a3 <.LASF1798+0x2>

000094c2 <.LVL48>:
    94c2:	4219      	mov	[S-26], AL

000094c4 <.LM43>:
            l_bool sig_Fwv_Overvoltage = l_signals.Fwv_Overvoltage;
    94c4:	62d8 11a4 	lod	AL, 0x11a4 <.LLST13>

000094c8 <.LVL50>:
    94c8:	421b      	mov	[S-28], AL

000094ca <.LM44>:
            l_bool sig_Fwv_Overcurrent = l_signals.Fwv_Overcurrent;
    94ca:	62d8 11a5 	lod	AL, 0x11a5 <.LLST13+0x1>

000094ce <.LVL52>:
    94ce:	421d      	mov	[S-30], AL

000094d0 <.LM45>:
            l_bool sig_Fwv_Overtemperature = l_signals.Fwv_Overtemperature;
    94d0:	62d8 11a6 	lod	AL, 0x11a6 <.LLST13+0x2>

000094d4 <.LVL54>:
    94d4:	421f      	mov	[S-32], AL

000094d6 <.LM46>:
            l_bool sig_Fwv_Diag_Forced_Status = l_signals.Fwv_Diag_Forced_Status;
    94d6:	62d8 11a7 	lod	AL, 0x11a7 <.LLST13+0x3>

000094da <.LVL56>:
    94da:	4221      	mov	[S-34], AL

000094dc <.LM47>:
            l_bool sig_Fwv_Position_Sensor_Fault = l_signals.Fwv_Position_Sensor_Fault;
    94dc:	62d8 11a8 	lod	AL, 0x11a8 <.LLST13+0x4>

000094e0 <.LVL58>:
    94e0:	4223      	mov	[S-36], AL

000094e2 <.LM48>:
            l_bool sig_Fwv_CommErr = l_signals.Fwv_CommErr;
    94e2:	62d8 11a9 	lod	AL, 0x11a9 <.LLST13+0x5>

000094e6 <.LVL60>:
    94e6:	4225      	mov	[S-38], AL

000094e8 <.LM49>:
            l_u16 sig_Fwv_SW_Version = l_signals.Fwv_SW_Version;
    94e8:	72d8 11aa 	lod	A, 0x11aa <.LLST13+0x6>

000094ec <.LVL62>:
    94ec:	5207      	mov	[S-8], A

000094ee <.LM50>:
            l_u8 sig_Fwv_Stall_State = l_signals.Fwv_Stall_State;
    94ee:	62d8 11ac 	lod	AL, 0x11ac <.LLST13+0x8>

000094f2 <.LVL64>:
    94f2:	4227      	mov	[S-40], AL

000094f4 <.LM51>:

            l_sl1_VPC_Fwv_Resp_data_t VPC_Fwv_Resp_data = {
    94f4:	7ee6      	lod	X, Y
    94f6:	3407      	and	X, #7
    94f8:	5e01      	mov	[S-2], X
    94fa:	7a2f      	lod	Y, [S-48]

000094fc <.LVL66>:
    94fc:	f4f0      	and	Y, #-16
    94fe:	7e05      	lod	X, [S-6]
    9500:	3401      	and	X, #1
    9502:	72ee      	lod	A, X

00009504 <.LVL67>:
    9504:	44a2      	asl	A, #2
    9506:	4422      	asl	A
    9508:	e601      	or	Y, [S-2]
    950a:	e6e2      	or	Y, A
    950c:	7e09      	lod	X, [S-10]
    950e:	3401      	and	X, #1
    9510:	72ee      	lod	A, X
    9512:	44a2      	asl	A, #2
    9514:	44a2      	asl	A, #2
    9516:	5201      	mov	[S-2], A
    9518:	f4cf      	and	Y, #-49
    951a:	7e0b      	lod	X, [S-12]
    951c:	3401      	and	X, #1
    951e:	72ee      	lod	A, X
    9520:	4862 0020 	mulu	A, A, #32
    9524:	e601      	or	Y, [S-2]
    9526:	e6e2      	or	Y, A
    9528:	7e0d      	lod	X, [S-14]
    952a:	3401      	and	X, #1
    952c:	72ee      	lod	A, X
    952e:	4862 0040 	mulu	A, A, #64
    9532:	5201      	mov	[S-2], A
    9534:	f6da ff3f 	and	Y, #65343
    9538:	7e0f      	lod	X, [S-16]
    953a:	3401      	and	X, #1
    953c:	72ee      	lod	A, X
    953e:	4862 0080 	mulu	A, A, #128
    9542:	e601      	or	Y, [S-2]
    9544:	e6e2      	or	Y, A
    9546:	7e11      	lod	X, [S-18]
    9548:	3401      	and	X, #1
    954a:	72ee      	lod	A, X
    954c:	6800      	lod	AH, #0
    954e:	72e4      	swap	A
    9550:	5201      	mov	[S-2], A
    9552:	f6da fcff 	and	Y, #64767
    9556:	7e13      	lod	X, [S-20]
    9558:	3401      	and	X, #1
    955a:	72ee      	lod	A, X
    955c:	4862 0200 	mulu	A, A, #512
    9560:	e601      	or	Y, [S-2]
    9562:	e6e2      	or	Y, A
    9564:	7e15      	lod	X, [S-22]
    9566:	3401      	and	X, #1
    9568:	72ee      	lod	A, X
    956a:	4862 0400 	mulu	A, A, #1024
    956e:	5201      	mov	[S-2], A
    9570:	f6da f3ff 	and	Y, #62463
    9574:	7e17      	lod	X, [S-24]
    9576:	3401      	and	X, #1
    9578:	72ee      	lod	A, X
    957a:	4862 0800 	mulu	A, A, #2048
    957e:	e601      	or	Y, [S-2]
    9580:	e6e2      	or	Y, A
    9582:	7e19      	lod	X, [S-26]
    9584:	3401      	and	X, #1
    9586:	72ee      	lod	A, X
    9588:	4862 1000 	mulu	A, A, #4096
    958c:	5201      	mov	[S-2], A
    958e:	f6da cfff 	and	Y, #53247
    9592:	7e1b      	lod	X, [S-28]
    9594:	3401      	and	X, #1
    9596:	72ee      	lod	A, X
    9598:	4862 2000 	mulu	A, A, #8192
    959c:	e601      	or	Y, [S-2]
    959e:	e6e2      	or	Y, A
    95a0:	7e1d      	lod	X, [S-30]
    95a2:	3401      	and	X, #1
    95a4:	72ee      	lod	A, X
    95a6:	b403      	and	A, #3
    95a8:	44d2      	rr	A, #2
    95aa:	5203      	mov	[S-4], A
    95ac:	f6da 3fff 	and	Y, #16383
    95b0:	621f      	lod	AL, [S-32]
    95b2:	b401      	and	A, #1
    95b4:	4452      	rr	A
    95b6:	7ee2      	lod	X, A
    95b8:	7203      	lod	A, [S-4]
    95ba:	a6e6      	or	A, Y
    95bc:	a6ee      	or	A, X
    95be:	522f      	mov	[S-48], A
    95c0:	6621      	lod	YL, [S-34]
    95c2:	f401      	and	Y, #1
    95c4:	7e2d      	lod	X, [S-46]
    95c6:	34fc      	and	X, #-4
    95c8:	5e01      	mov	[S-2], X
    95ca:	7e23      	lod	X, [S-36]
    95cc:	3401      	and	X, #1
    95ce:	72ee      	lod	A, X
    95d0:	4422      	asl	A
    95d2:	7e01      	lod	X, [S-2]
    95d4:	26e6      	or	X, Y
    95d6:	26e2      	or	X, A
    95d8:	6225      	lod	AL, [S-38]
    95da:	b401      	and	A, #1
    95dc:	44a2      	asl	A, #2
    95de:	7ae2      	lod	Y, A
    95e0:	72ee      	lod	A, X
    95e2:	94fb      	and	AL, #-5
    95e4:	a6e6      	or	A, Y
    95e6:	84f8      	or	AL, #-8
    95e8:	422d      	mov	[S-46], AL
    95ea:	6207      	lod	AL, [S-8]
    95ec:	422c      	mov	[S-45], AL
    95ee:	7a07      	lod	Y, [S-8]
    95f0:	6400      	lod	YL, #0
    95f2:	7ae8      	swap	Y
    95f4:	7e2b      	lod	X, [S-44]
    95f6:	36da fc00 	and	X, #64512
    95fa:	5e03      	mov	[S-4], X
    95fc:	7e27      	lod	X, [S-40]
    95fe:	3403      	and	X, #3
    9600:	5e07      	mov	[S-8], X

00009602 <.LVL68>:
    9602:	72ee      	lod	A, X
    9604:	6800      	lod	AH, #0
    9606:	72e4      	swap	A
    9608:	7e03      	lod	X, [S-4]
    960a:	26e6      	or	X, Y
    960c:	a6ee      	or	A, X
    960e:	522b      	mov	[S-44], A
    9610:	7eef      	lod	X, S
    9612:	20d5      	add	X, #-43
    9614:	62f8      	lod	AL, [X]
    9616:	84fc      	or	AL, #-4
    9618:	42f8      	mov	[X], AL
    961a:	72da 00ff 	lod	A, #255
    961e:	4229      	mov	[S-42], AL
    9620:	4228      	mov	[S-41], AL

00009622 <.LM52>:
                sig_Fwv_Stall_State,
                0x3f,
                0xff,
                0xff
            };
            l_FillBufferSlave((l_u8*)&VPC_Fwv_Resp_data, (l_u8)sizeof(l_sl1_VPC_Fwv_Resp_data_t));
    9622:	54ca 0008 	pushw	#8

00009626 <.LCFI13>:
    9626:	72ef      	lod	A, S
    9628:	a0ce      	add	A, #-50
    962a:	16a9      	call	0x937e <_l_FillBufferSlave>

0000962c <.LVL70>:
    962c:	5c01      	dec	S, #2

0000962e <.L33>:
} l_sl1_VPC_Fwv_Resp_data_t;
ASSERT(sizeof(l_sl1_VPC_Fwv_Resp_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_VPC_Fwv_Resp_handler (l_s_FrameAction_t frameAction)
{
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    962e:	7000      	lod	A, #0

00009630 <.LM54>:
        }
        case sfa_UpdateSignals:     /* For M2S frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&VPC_Fwv_Resp_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
            break;
    9630:	5431      	ret	#50

00009632 <.L32>:
        }
        case sfa_CheckFlags:    /* Only for frames associated with an Event-triggered frame */
        default:
            retVal = sfhs_Fail;
    9632:	7001      	lod	A, #1

00009634 <.LM56>:
            break;
    }
    return retVal;
}
    9634:	5431      	ret	#50

00009636 <_globalVariableInit>:
 * @return 0
 */

void globalVariableInit(void)
{
	g_u16MotorSupplyVoltage = C_VSUP_REF; /**< [10mV] */
    9636:	72da 04b0 	lod	A, #1200
    963a:	52d8 1402 	mov	0x1402 <_g_u16MotorSupplyVoltage>, A

0000963e <.LM3>:
	g_i16ChipTemperature = 35;			  /**< [C] */
    963e:	7c23      	lod	X, #35
    9640:	0ea7      	lod	C, ML.7
    9642:	5ed8 13e8 	mov	0x13e8 <_g_i16ChipTemperature>, X

00009646 <.LM4>:
	g_u16SupplyVoltage = C_VSUP_REF;	  /**< [10mV] */
    9646:	52d8 140a 	mov	0x140a <_g_u16SupplyVoltage>, A

0000964a <.LM5>:
	g_u16VBGD = 1185u;					  /**< analog supply voltage [1mV] */
    964a:	72da 04a1 	lod	A, #1185
    964e:	0ea7      	lod	C, ML.7
    9650:	52d8 1406 	mov	0x1406 <_g_u16VBGD>, A

00009654 <.LM6>:
	l_u32MotorSupplyVoltageFilter = 0u;
    9654:	4cfa 0000 	movs	YA, #0
    9658:	52d8 140e 	mov	0x140e <_l_u32MotorSupplyVoltageFilter>, A
    965c:	0ea7      	lod	C, ML.7
    965e:	5ad8 1410 	mov	0x1410 <_l_u32MotorSupplyVoltageFilter+0x2>, Y

00009662 <.LM7>:
	l_u32SupplyVoltageFilter = 0u;
    9662:	52d8 13e2 	mov	0x13e2 <_l_u32SupplyVoltageFilter>, A
    9666:	5ad8 13e4 	mov	0x13e4 <_l_u32SupplyVoltageFilter+0x2>, Y

0000966a <.LM8>:
	l_u32ChipTemperatureFilter = 0u;
    966a:	0ea7      	lod	C, ML.7
    966c:	52d8 13f8 	mov	0x13f8 <_l_u32ChipTemperatureFilter>, A
    9670:	5ad8 13fa 	mov	0x13fa <_l_u32ChipTemperatureFilter+0x2>, Y

00009674 <.LM9>:
	g_u16IO3 = 0;  /**< [1mV] */
    9674:	52d8 13f6 	mov	0x13f6 <_g_u16IO3>, A

00009678 <.LM10>:
	g_u16VDDA = 0; /**< [1mV] */
    9678:	0ea7      	lod	C, ML.7
    967a:	52d8 13f2 	mov	0x13f2 <_g_u16VDDA>, A

0000967e <.LM11>:
	g_i16ShuntCurrent = 0u;
    967e:	52d8 1404 	mov	0x1404 <_g_i16ShuntCurrent>, A

00009682 <.LM12>:
	g_u16PositionSensor = 0;
    9682:	52d8 13e0 	mov	0x13e0 <_g_u16PositionSensor>, A

00009686 <.LM13>:
	u16_Angle_Gap = 0;
    9686:	0ea7      	lod	C, ML.7
    9688:	52d8 13ec 	mov	0x13ec <_u16_Angle_Gap>, A

0000968c <.LM14>:
	SetDuty = 0;
    968c:	52d8 13f4 	mov	0x13f4 <_SetDuty>, A

00009690 <.LM15>:
	u16_LIN_Target_Angle = 3;
    9690:	7c03      	lod	X, #3
    9692:	0ea7      	lod	C, ML.7
    9694:	5ed8 13f0 	mov	0x13f0 <_u16_LIN_Target_Angle>, X

00009698 <.LM16>:
	u16_CONV_Target_Angle = 0;
    9698:	52d8 13e6 	mov	0x13e6 <_u16_CONV_Target_Angle>, A

0000969c <.LM17>:
	u16_Target_Angle_LCL = 0;
    969c:	52d8 13fe 	mov	0x13fe <_u16_Target_Angle_LCL>, A

000096a0 <.LM18>:
	u16_Target_Angle_UCL = 0;
    96a0:	0ea7      	lod	C, ML.7
    96a2:	52d8 13ea 	mov	0x13ea <_u16_Target_Angle_UCL>, A

000096a6 <.LM19>:
	Angle_Hysteresis = 7U;
    96a6:	7c07      	lod	X, #7
    96a8:	5ed8 13fc 	mov	0x13fc <_Angle_Hysteresis>, X

000096ac <.LM20>:
	u16_Duty_Dec_Range = 0;
    96ac:	0ea7      	lod	C, ML.7
    96ae:	52d8 13de 	mov	0x13de <_u16_Duty_Dec_Range>, A

000096b2 <.LM21>:
	u16_IGN_PORT_CNT = 0;
    96b2:	52d8 13ee 	mov	0x13ee <_u16_IGN_PORT_CNT>, A

000096b6 <.LM22>:
}
    96b6:	5401      	ret

000096b8 <_system_timer_ISR>:

void system_timer_ISR()
{
	if(motor.fault.openDetectCnt < OPEN_DETECT_TIMEOUT)    {
    96b8:	72d8 12c2 	lod	A, 0x12c2 <.LLST10>
    96bc:	aeda 01f3 	cmp	A, #499
    96c0:	1e03      	jug	0x96c8 <.L3>

000096c2 <.LM25>:
		motor.fault.openDetectCnt++; 
    96c2:	a001      	add	A, #1
    96c4:	52d8 12c2 	mov	0x12c2 <.LLST10>, A

000096c8 <.L3>:
	}

	if(motor.fault.ocDetectCnt < OVER_CURRNET_DETECT_TIMEOUT)    {	
    96c8:	72d8 12be 	lod	A, 0x12be <.LLST9+0xf>
    96cc:	aeda 012b 	cmp	A, #299
    96d0:	1e03      	jug	0x96d8 <.L4>

000096d2 <.LM27>:
		motor.fault.ocDetectCnt++; 
    96d2:	a001      	add	A, #1
    96d4:	52d8 12be 	mov	0x12be <.LLST9+0xf>, A

000096d8 <.L4>:
	}

	if(motor.out.enable)
    96d8:	72d8 12a0 	lod	A, 0x12a0 <.LASF2051+0x1>
    96dc:	1907      	je	0x96ec <.L2>

000096de <.LM29>:
	{
		if(motor.stall.maskTimer < STALL_DETECT_TIMEOUT) {
    96de:	72d8 12ae 	lod	A, 0x12ae <.LASF1639+0x3>
    96e2:	ac63      	cmp	A, #99
    96e4:	1e03      	jug	0x96ec <.L2>

000096e6 <.LM30>:
			motor.stall.maskTimer++;
    96e6:	a001      	add	A, #1
    96e8:	52d8 12ae 	mov	0x12ae <.LASF1639+0x3>, A

000096ec <.L2>:
		}
	}
	

}
    96ec:	5401      	ret

000096ee <_main>:

int main(void)
{
    96ee:	5801      	inc	S, #2

000096f0 <.LBB234>:

/** WDG_disableIwdIt disables the intelligent watchdog timer interrupt */
STATIC INLINE void WDG_disableIwdIt(void)
{
    /* disable IWD interrupt */
    IO_SET(MLX16, IWD_ATT_ITC, 0u);
    96f0:	62d8 006c 	lod	AL, 0x6c <__mlx4_cst_tables_ram_size+0xe>
    96f4:	94f7      	and	AL, #-9
    96f6:	42d8 006c 	mov	0x6c <__mlx4_cst_tables_ram_size+0xe>, AL

000096fa <.LBE234>:
	/* Initialize watch-dogs, both analogue and digital */
	WDG_disableIwdIt();

	/* Initialize globalVariable */
	globalVariableInit();
    96fa:	179d      	call	0x9636 <_globalVariableInit>

000096fc <.LBB236>:
 * Log reset source
 */
static void log_reset_source(void)
{
	uint16_t temp;
	if (IO_GET(PORT_MISC_IN, LOCAL_WU) != 0u)
    96fc:	72d8 01e2 	lod	A, 0x1e2 <_PORT_MISC_IN>
    9700:	d440      	and	AH, #64
    9702:	1d05      	jne	0x970e <.L22>

00009704 <.LM36>:
	{
		/* IO_0 wake up */
	}
	else if (IO_GET(PORT_MISC_IN, LIN_WU) != 0u)
    9704:	72d8 01e2 	lod	A, 0x1e2 <_PORT_MISC_IN>
    9708:	d408      	and	AH, #8
    970a:	1d01      	jne	0x970e <.L22>

0000970c <.LM37>:
	{
		/* LIN wake up */
	}
	else if (IO_GET(RST_CTRL, AWD_WBOOT) != 0u)
    970c:	7282      	lod	A, io:0x2 <_RST_CTRL>

0000970e <.L22>:
	uint16_t temp;
	if (IO_GET(PORT_MISC_IN, LOCAL_WU) != 0u)
	{
		/* IO_0 wake up */
	}
	else if (IO_GET(PORT_MISC_IN, LIN_WU) != 0u)
    970e:	7020      	lod	A, #32

00009710 <.L14>:

STATIC INLINE uint8_t softio_get(GpioIo_t IO)
{
    uint8_t pinlevel = 0xFFu;
    if(IO <= MAXIO_INDEX) {
        pinlevel = (uint8_t)(IO_GET(PORT_IO_IN, IO_IN_SYNC) >> (uint16_t)IO) & 0x01u;
    9710:	7ed8 01de 	lod	X, 0x1de <_PORT_IO_IN>

00009714 <.LBE238>:
	}
#if LIN_WAKEUP_DISABLE == 1
	for (temp = 32; temp > 0; temp--)
	{

		if (softio_get(0) == 0)
    9714:	3401      	and	X, #1
    9716:	1d0b      	jne	0x972e <.L12>

00009718 <.LM41>:
		{

			u16_IGN_PORT_CNT++;
    9718:	7ed8 13ee 	lod	X, 0x13ee <_u16_IGN_PORT_CNT>
    971c:	2001      	add	X, #1
    971e:	5ed8 13ee 	mov	0x13ee <_u16_IGN_PORT_CNT>, X

00009722 <.LM42>:
			if (u16_IGN_PORT_CNT >= 16)
    9722:	2c0f      	cmp	X, #15
    9724:	1a04      	jule	0x972e <.L12>

00009726 <.LM43>:
			{
				lin22_GotoSleep();
    9726:	5201      	mov	[S-2], A
    9728:	82db 46cd 	callf	0x8d9a <_lin22_GotoSleep>

0000972c <.LVL3>:
    972c:	7201      	lod	A, [S-2]

0000972e <.L12>:
	{

		/* power on reset */
	}
#if LIN_WAKEUP_DISABLE == 1
	for (temp = 32; temp > 0; temp--)
    972e:	a0ff      	add	A, #-1

00009730 <.LVL5>:
    9730:	1d6f      	jne	0x9710 <.L14>

00009732 <.LBE236>:
#if UART_DEBUG_ENABLE
	uartInit();
#endif

	/* Initialize the timeout timer module */
	swtimer_init();
    9732:	1230      	call	0x9b94 <_swtimer_init>

00009734 <.LM46>:

	ctimer0_init(CTIMER0_1MS);
    9734:	72da 07d0 	lod	A, #2000
    9738:	12f5      	call	0x9d24 <_ctimer0_init>

0000973a <.LM47>:

	/* Initialize the eeprom handler */
	eeprom_Init();
    973a:	82db 4323 	callf	0x8646 <_eeprom_Init>

0000973e <.LM48>:

	/* initialize the pwm module */
	pwm_Init();
    973e:	10f3      	call	0x9926 <_pwm_Init>

00009740 <.LM49>:

	/* Initialize the lin handler */
	lin22_Init();
    9740:	82db 4627 	callf	0x8c4e <_lin22_Init>

00009744 <.LM50>:

	/* Initialize the adc driver */
	adc_Init();
    9744:	82db 3ab5 	callf	0x756a <_adc_Init>

00009748 <.LM51>:

	adc_Shunt_OffsetCalib();
    9748:	82db 3b2c 	callf	0x7658 <_adc_Shunt_OffsetCalib>

0000974c <.LM52>:
	adc_Start(true); /* pwm must be initialized before you can use the do start and wait for loop */
    974c:	7001      	lod	A, #1
    974e:	82db 3adc 	callf	0x75b8 <_adc_Start>

00009752 <.LM53>:

	ctimer0_start();
    9752:	1302      	call	0x9d58 <_ctimer0_start>

00009754 <.LM54>:

	/* Start application */
	IO_SET(PORT_IO_ENABLE, IO_DISREC, 0x1E); // IO 1~4 -> ADC
    9754:	601e      	lod	AL, #30
    9756:	42d8 023b 	mov	0x23b <_PORT_IO_ENABLE+0x1>, AL

0000975a <.LBB240>:
#if defined(HAS_HW_IO0_HV)
/** Enable high voltage cell of IO 0
 */
STATIC INLINE void gpio_io0HvEnable(void)
{
    IO_SET(PORT_IO_OUT_EN, IO0_LV_ENABLE, 0u);
    975a:	0ea7      	lod	C, ML.7
    975c:	62d8 01e8 	lod	AL, 0x1e8 <_PORT_IO_OUT_EN>
    9760:	947f      	and	AL, #127
    9762:	42d8 01e8 	mov	0x1e8 <_PORT_IO_OUT_EN>, AL

00009766 <.LBE240>:
	gpio_io0HvEnable();						 // 250702-1 Support IO0 for High Voltage ,ignition interface.
	/* diag & prot */
	protection_Init();
    9766:	1067      	call	0x9836 <_protection_Init>

00009768 <.LBB242>:
 * @returns  raw Vsm adc sample.
 */
static INLINE uint16_t adc_GetRawVsm(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_VSM];
    9768:	72d8 12c4 	lod	A, 0x12c4 <_dBase>

0000976c <.LBE244>:
 * --------------------------------------------- */
static void background_Handler(void);
static void log_reset_source(void);
static void app_Initialize(void)
{
	l_u32MotorSupplyVoltageFilter = adc_GetRawVsm() * 4u;
    976c:	44a2      	asl	A, #2
    976e:	4cf2      	usex	YA
    9770:	52d8 140e 	mov	0x140e <_l_u32MotorSupplyVoltageFilter>, A
    9774:	5ad8 1410 	mov	0x1410 <_l_u32MotorSupplyVoltageFilter+0x2>, Y

00009778 <.LBB246>:
 * @returns  raw Vs adc sample.
 */
static INLINE uint16_t adc_GetRawVs(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_VS];
    9778:	72d8 12ce 	lod	A, 0x12ce <_dBase+0xa>

0000977c <.LBE246>:
	l_u32SupplyVoltageFilter = adc_GetRawVs() * 4u;
    977c:	44a2      	asl	A, #2
    977e:	4cf2      	usex	YA
    9780:	52d8 13e2 	mov	0x13e2 <_l_u32SupplyVoltageFilter>, A
    9784:	5ad8 13e4 	mov	0x13e4 <_l_u32SupplyVoltageFilter+0x2>, Y

00009788 <.LBB248>:
 * @returns  raw temperature adc sample.
 */
static INLINE uint16_t adc_GetRawTemperature(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_TEMP];
    9788:	72d8 12c6 	lod	A, 0x12c6 <_dBase+0x2>

0000978c <.LBE248>:
	l_u32ChipTemperatureFilter = adc_GetRawTemperature() * 4u;
    978c:	44a2      	asl	A, #2
    978e:	4cf2      	usex	YA
    9790:	52d8 13f8 	mov	0x13f8 <_l_u32ChipTemperatureFilter>, A
    9794:	5ad8 13fa 	mov	0x13fa <_l_u32ChipTemperatureFilter+0x2>, Y

00009798 <.LM63>:
	swtimer_register((uint16_t)SWTIMER_MOT_CTRL_PERIOD, 1, REPETITIVE); // 100usec
    9798:	54ca 0001 	pushw	#1

0000979c <.LCFI1>:
    979c:	0ea7      	lod	C, ML.7
    979e:	54ca 0001 	pushw	#1

000097a2 <.LCFI2>:
    97a2:	7005      	lod	A, #5
    97a4:	122c      	call	0x9bfe <_swtimer_register>

000097a6 <.LM64>:
	swtimer_start((uint16_t)SWTIMER_MOT_CTRL_PERIOD);
    97a6:	7005      	lod	A, #5
    97a8:	1240      	call	0x9c2a <_swtimer_start>

000097aa <.LM65>:
	swtimer_register((uint16_t)SWTIMER_APP_CTRL_PERIOD, 10, REPETITIVE); // 1msec
    97aa:	54ca 0001 	pushw	#1

000097ae <.LCFI3>:
    97ae:	54ca 000a 	pushw	#10

000097b2 <.LCFI4>:
    97b2:	0ea7      	lod	C, ML.7
    97b4:	7006      	lod	A, #6
    97b6:	1223      	call	0x9bfe <_swtimer_register>

000097b8 <.LM66>:
	swtimer_start((uint16_t)SWTIMER_APP_CTRL_PERIOD);
    97b8:	7006      	lod	A, #6
    97ba:	1237      	call	0x9c2a <_swtimer_start>

000097bc <.LM67>:

	AppLinInit();
    97bc:	82db 31a8 	callf	0x6350 <_AppLinInit>

000097c0 <.LM68>:
	sensor_init();
    97c0:	82db 3bc0 	callf	0x7780 <_sensor_init>

000097c4 <.LM69>:
	app_mot_init();
    97c4:	82db 3e7a 	callf	0x7cf4 <_app_mot_init>

000097c8 <.LM70>:
	AppValveInit();
    97c8:	82db 336a 	callf	0x66d4 <_AppValveInit>

000097cc <.LBB250>:
        );
}

STATIC INLINE void builtin_mlx16_enter_user_mode(void)
{
    __asm__ __volatile__ ("setb MH.3" ::: "M", "memory");
    97cc:	0ab3      	setb	MH.3
    97ce:	5c07      	dec	S, #8

000097d0 <.L19>:
    97d0:	0f7f      	lod	C, io:0x0f.7

000097d2 <.LBE254>:
}

/** WDG_conditionalAwdRefresh acknowledges the AWD timer if its window is opened */
STATIC INLINE void WDG_conditionalAwdRefresh(void)
{
    if (IO_GET(AWD, WIN_OPEN) != 0u) {
    97d2:	1c01      	jnc	0x97d6 <.L15>

000097d4 <.LM74>:
        IO_SET(AWD, ACK, 1u);
    97d4:	0b76      	setb	io:0x0e.6

000097d6 <.L15>:
#endif
	/* Application loop */
	while (1u)
	{
		WDG_conditionalAwdRefresh(); /* Restart watchdog */
		AppLinTask();
    97d6:	82db 31ae 	callf	0x635c <_AppLinTask>

000097da <.LM76>:

		protection_Task();
    97da:	10a2      	call	0x9920 <_protection_Task>

000097dc <.LM77>:
		//     fm_Atan2HelperInterpolationInlined(100,200);

		if (g_bUnderVoltageDetected) /* log UV_VS interrupt detection */
    97dc:	62d8 11b4 	lod	AL, 0x11b4 <_g_bUnderVoltageDetected>
    97e0:	1903      	je	0x97e8 <.L16>

000097e2 <.LM78>:
		{
			g_bUnderVoltageDetected = false; /* IC self detect*/
    97e2:	6000      	lod	AL, #0
    97e4:	42d8 11b4 	mov	0x11b4 <_g_bUnderVoltageDetected>, AL

000097e8 <.L16>:
		}
		if (swtimer_isTriggered((uint16_t)SWTIMER_MOT_CTRL_PERIOD) != 0u) // 100us period
    97e8:	7005      	lod	A, #5
    97ea:	1230      	call	0x9c4c <_swtimer_isTriggered>
    97ec:	ac00      	cmp	A, #0
    97ee:	1902      	je	0x97f4 <.L17>

000097f0 <.LM80>:
		{
			motor_ctrl_handler();
    97f0:	82db 40ee 	callf	0x81dc <_motor_ctrl_handler>

000097f4 <.L17>:
		}
		if (swtimer_isTriggered((uint16_t)SWTIMER_APP_CTRL_PERIOD) != 0u) // 1ms period
    97f4:	7006      	lod	A, #6
    97f6:	122a      	call	0x9c4c <_swtimer_isTriggered>
    97f8:	ac00      	cmp	A, #0
    97fa:	1904      	je	0x9804 <.L18>

000097fc <.LM82>:
		{
			app_motor_task();
    97fc:	82db 3ede 	callf	0x7dbc <_app_motor_task>

00009800 <.LM83>:
			AppValveTask();
    9800:	82db 33fd 	callf	0x67fa <_AppValveTask>

00009804 <.L18>:
static void background_Handler(void)
{
	static int16_t i16ChipTemperature = 35;

	/* Calibrate stimer over temperature */
	if (abs(g_i16ChipTemperature - i16ChipTemperature) > 10)
    9804:	72d8 13e8 	lod	A, 0x13e8 <_g_i16ChipTemperature>
    9808:	aad8 10a6 	sub	A, 0x10a6 <___i16ChipTemperature_8562>
    980c:	1d81      	jnn	0x9810 <.L34>
    980e:	5cc2      	neg	A

00009810 <.L34>:
    9810:	ac0a      	cmp	A, #10
    9812:	1b5e      	jsle	0x97d0 <.L19>

00009814 <.LBB258>:
    9814:	72d8 12c6 	lod	A, 0x12c6 <_dBase+0x2>

00009818 <.LBE258>:
	{
		swtimer_calibrate(adc_GetRawTemperature());
    9818:	11e6      	call	0x9be6 <_swtimer_calibrate>

0000981a <.LM87>:
		i16ChipTemperature = g_i16ChipTemperature;
    981a:	72d8 13e8 	lod	A, 0x13e8 <_g_i16ChipTemperature>
    981e:	52d8 10a6 	mov	0x10a6 <___i16ChipTemperature_8562>, A
    9822:	0ea7      	lod	C, ML.7
    9824:	07d5      	jmp	0x97d0 <.L19>

00009826 <_EVENT_UnderVoltage>:
 * \image html diode.png
 * \image latex diode.png
 */
void EVENT_UnderVoltage(void)
{
	g_bUnderVoltageDetected = true;
    9826:	6001      	lod	AL, #1
    9828:	42d8 11b4 	mov	0x11b4 <_g_bUnderVoltageDetected>, AL

0000982c <.LM90>:
}
    982c:	5401      	ret

0000982e <_EVENT_GotoSleep>:
    982e:	0f7f      	lod	C, io:0x0f.7

00009830 <.LBE262>:
}

/** WDG_conditionalAwdRefresh acknowledges the AWD timer if its window is opened */
STATIC INLINE void WDG_conditionalAwdRefresh(void)
{
    if (IO_GET(AWD, WIN_OPEN) != 0u) {
    9830:	1c01      	jnc	0x9834 <.L37>

00009832 <.LM96>:
        IO_SET(AWD, ACK, 1u);
    9832:	0b76      	setb	io:0x0e.6

00009834 <.L37>:
 */
void EVENT_GotoSleep(void)
{

	WDG_conditionalAwdRefresh(); /* Restart watchdog */
}
    9834:	5401      	ret

00009836 <_protection_Init>:
    9836:	5801      	inc	S, #2

00009838 <.LCFI0>:
    9838:	7800      	lod	Y, #0
    983a:	5ad8 11ba 	mov	0x11ba <_g_e8ErrorVoltage>, Y

0000983e <.LM3>:
    983e:	5ad8 11b8 	mov	0x11b8 <_g_e8ErrorOverTemperature>, Y

00009842 <.LM4>:
    9842:	0ea7      	lod	C, ML.7
    9844:	5ad8 11b6 	mov	0x11b6 <_g_e8ShortOcc>, Y

00009848 <.LM5>:
    9848:	46d8 11b5 	mov	0x11b5 <_g_e8OverCurrent>, YL

0000984c <.LM6>:
    984c:	5adf      	push	Y

0000984e <.LCFI1>:
    984e:	54ca 04e2 	pushw	#1250

00009852 <.LCFI2>:
    9852:	7003      	lod	A, #3
    9854:	5a05      	mov	[S-6], Y
    9856:	11d3      	call	0x9bfe <_swtimer_register>

00009858 <.LM7>:
    9858:	7a05      	lod	Y, [S-6]
    985a:	5adf      	push	Y

0000985c <.LCFI3>:
    985c:	54ca 0064 	pushw	#100

00009860 <.LCFI4>:
    9860:	7004      	lod	A, #4
    9862:	11cd      	call	0x9bfe <_swtimer_register>

00009864 <.LM8>:
    9864:	82db 4273 	callf	0x84e6 <_diagnostic_Init>

00009868 <.LM9>:
    9868:	82db 42a3 	callf	0x8546 <_diagnostic_Start>

0000986c <.LCFI5>:
    986c:	540b      	ret	#12

0000986e <_protection_CheckShort>:
        {
        }	g_e8OverCurrent = 0;
    }
    */
   
    if (diagnostic_IsVDSPending())
    986e:	82db 42ea 	callf	0x85d4 <_diagnostic_IsVDSPending>
    9872:	ac00      	cmp	A, #0
    9874:	1903      	je	0x987c <.L5>

00009876 <.LM22>:
    {
        g_e8ShortOcc = C_ERR_SHORT_VDS;
    9876:	7002      	lod	A, #2
    9878:	52d8 11b6 	mov	0x11b6 <_g_e8ShortOcc>, A

0000987c <.L5>:
        {
        }
        //        g_e8ShortOcc = C_ERR_SHORT_NO;
        /* MISRA C-2012 Rule 15.7 */
    }
}
    987c:	5401      	ret

0000987e <_protection_CheckSupplyMotorVoltage>:
 *
 * @param[in]  a_u16SupplyMotorVoltage  VSM voltage [10mV]
 */
void protection_CheckSupplyMotorVoltage(void)
{
    if (diagnostic_IsOVPending())
    987e:	82db 42e1 	callf	0x85c2 <_diagnostic_IsOVPending>
    9882:	ac00      	cmp	A, #0
    9884:	1904      	je	0x988e <.L11>

00009886 <.LM26>:
    {
        g_e8ErrorVoltage = C_ERR_VOLTAGE_OVER_HW;
    9886:	7004      	lod	A, #4

00009888 <.L19>:
    }
    else if (diagnostic_IsUVPending())
    {

        g_e8ErrorVoltage = C_ERR_VOLTAGE_UNDER_HW;
    9888:	52d8 11ba 	mov	0x11ba <_g_e8ErrorVoltage>, A
    988c:	5401      	ret

0000988e <.L11>:
{
    if (diagnostic_IsOVPending())
    {
        g_e8ErrorVoltage = C_ERR_VOLTAGE_OVER_HW;
    }
    else if (diagnostic_IsUVPending())
    988e:	82db 42dc 	callf	0x85b8 <_diagnostic_IsUVPending>
    9892:	ac00      	cmp	A, #0
    9894:	1902      	je	0x989a <.L13>

00009896 <.LM29>:
    {

        g_e8ErrorVoltage = C_ERR_VOLTAGE_UNDER_HW;
    9896:	7002      	lod	A, #2
    9898:	07f7      	jmp	0x9888 <.L19>

0000989a <.L13>:
    }
    else
    {
        if ((g_e8ErrorVoltage == C_ERR_VOLTAGE_OVER_HW) && (get_valve_voltage() < C_APPL_OVOLT))
    989a:	72d8 11ba 	lod	A, 0x11ba <_g_e8ErrorVoltage>
    989e:	ac04      	cmp	A, #4
    98a0:	1d0f      	jne	0x98c0 <.L15>

000098a2 <.LM31>:
    98a2:	82db 3361 	callf	0x66c2 <_get_valve_voltage>
    98a6:	aeda 0707 	cmp	A, #1799
    98aa:	1e0a      	jug	0x98c0 <.L15>

000098ac <.LM32>:
        {
            IO_SET(PORT_DRV1_PROT, DIS_OV_VS, 1u); /* clear MEM flag */
    98ac:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    98b0:	8408      	or	AL, #8
    98b2:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

000098b6 <.LM33>:
            IO_SET(PORT_DRV1_PROT, DIS_OV_VS, 0u); /* re-enable hardware protection */
    98b6:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    98ba:	94f7      	and	AL, #-9
    98bc:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

000098c0 <.L15>:
        }
        if ((g_e8ErrorVoltage == C_ERR_VOLTAGE_UNDER_HW) && (get_valve_voltage() > C_APPL_UVOLT))
    98c0:	72d8 11ba 	lod	A, 0x11ba <_g_e8ErrorVoltage>
    98c4:	ac02      	cmp	A, #2
    98c6:	1d0f      	jne	0x98e6 <.L10>

000098c8 <.LM35>:
    98c8:	82db 3361 	callf	0x66c2 <_get_valve_voltage>
    98cc:	aeda 02bc 	cmp	A, #700
    98d0:	1a0a      	jule	0x98e6 <.L10>

000098d2 <.LM36>:
        {
            IO_SET(PORT_DRV1_PROT, DIS_UV_VS, 1u); /* clear MEM flag */
    98d2:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    98d6:	8420      	or	AL, #32
    98d8:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

000098dc <.LM37>:
            IO_SET(PORT_DRV1_PROT, DIS_UV_VS, 0u); /* re-enable hardware protection */
    98dc:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    98e0:	94df      	and	AL, #-33
    98e2:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

000098e6 <.L10>:
        }
        //		g_e8ErrorVoltage = C_ERR_VOLTAGE_IN_RANGE;
    }
}
    98e6:	5401      	ret

000098e8 <_protection_CheckChipTemperature>:
 *
 * @param[in]  a_i16ChipTemperature  chip internal temperature sensor [C]
 */
void protection_CheckChipTemperature(void)
{
    if (diagnostic_IsOVTPending())
    98e8:	82db 42e6 	callf	0x85cc <_diagnostic_IsOVTPending>
    98ec:	ac00      	cmp	A, #0
    98ee:	1904      	je	0x98f8 <.L21>

000098f0 <.LM41>:
    {

        g_e8ErrorOverTemperature = C_ERR_TEMP_ALARM;
    98f0:	7002      	lod	A, #2
    98f2:	52d8 11b8 	mov	0x11b8 <_g_e8ErrorOverTemperature>, A
    98f6:	5401      	ret

000098f8 <.L21>:
        //            swtimer_stop(SWTIMER_PROTECTION_DELAY_OVT);
    }
    else
    {
        if ((g_e8ErrorOverTemperature == C_ERR_TEMP_ALARM) && (get_valve_temperature() < (int16_t)(C_APPL_OTEMP + C_TEMP_CONV_OFFSET)))
    98f8:	72d8 11b8 	lod	A, 0x11b8 <_g_e8ErrorOverTemperature>
    98fc:	ac02      	cmp	A, #2
    98fe:	1d0f      	jne	0x991e <.L20>

00009900 <.LM43>:
    9900:	82db 3364 	callf	0x66c8 <_get_valve_temperature>
    9904:	aeda 009f 	cmp	A, #159
    9908:	1f0a      	jsg	0x991e <.L20>

0000990a <.LM44>:
        {
            IO_SET(PORT_DRV1_PROT, DIS_OVT, 1u); /* clear MEM flag */
    990a:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    990e:	8402      	or	AL, #2
    9910:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

00009914 <.LM45>:
            IO_SET(PORT_DRV1_PROT, DIS_OVT, 0u); /* re-enable hardware protection */
    9914:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    9918:	94fd      	and	AL, #-3
    991a:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

0000991e <.L20>:
        }
        //	 g_e8ErrorOverTemperature = C_ERR_TEMP_NO;
        /* MISRA C-2012 Rule 15.7 */
    }
}
    991e:	5401      	ret

00009920 <_protection_Task>:

void protection_Task(void)
{
    protection_CheckShort();
    9920:	17a6      	call	0x986e <_protection_CheckShort>

00009922 <.LM49>:

    protection_CheckSupplyMotorVoltage();
    9922:	17ad      	call	0x987e <_protection_CheckSupplyMotorVoltage>

00009924 <.LM50>:
    protection_CheckChipTemperature();
    9924:	07e1      	jmp	0x98e8 <_protection_CheckChipTemperature>

00009926 <_pwm_Init>:
 *    |______|______|       |______|_
 *     <-LT->|<-LT->|        <-LT->|
 *
 */
void pwm_Init(void)
{
    9926:	5801      	inc	S, #2

00009928 <.LBB1030>:
#if defined (IO_PWM_MASTER1__START_GET)
#define PWM1_MASTER_DISABLE pwm1_master_disable

STATIC INLINE void pwm1_master_disable(void)
{
    IO_HOST(PWM_MASTER1, STOP) = 1u << IO_OFFSET(PWM_MASTER1, STOP);
    9928:	7802      	lod	Y, #2
    992a:	5ad8 013c 	mov	0x13c <_PWM_MASTER1+0x8>, Y

0000992e <.LBB1032>:
#if defined (IO_PWM_SLAVE1__START_GET)
#define PWM1_DISABLE pwm1_disable

STATIC INLINE void pwm1_disable(void)
{
    IO_HOST(PWM_SLAVE1, STOP) = 1u << IO_OFFSET(PWM_SLAVE1, STOP);
    992e:	5ad8 0146 	mov	0x146 <.LASF2017+0x3>, Y

00009932 <.LBB1034>:
#if defined (IO_PWM_SLAVE2__START_GET)
#define PWM2_DISABLE pwm2_disable

STATIC INLINE void pwm2_disable(void)
{
    IO_HOST(PWM_SLAVE2, STOP) = 1u << IO_OFFSET(PWM_SLAVE2, STOP);
    9932:	0ea7      	lod	C, ML.7
    9934:	5ad8 0150 	mov	0x150 <_PWM_SLAVE2+0x8>, Y

00009938 <.LBB1036>:
#if defined (IO_PWM_SLAVE3__START_GET)
#define PWM3_DISABLE pwm3_disable

STATIC INLINE void pwm3_disable(void)
{
    IO_HOST(PWM_SLAVE3, STOP) = 1u << IO_OFFSET(PWM_SLAVE3, STOP);
    9938:	5ad8 015a 	mov	0x15a <.LASF1651+0x3>, Y

0000993c <.LBB1038>:
#if defined (IO_PWM_MASTER2__START_GET)
#define PWM2_MASTER_DISABLE pwm2_master_disable

STATIC INLINE void pwm2_master_disable(void)
{
    IO_HOST(PWM_MASTER2, STOP) = 1u << IO_OFFSET(PWM_MASTER2, STOP);
    993c:	5ad8 0164 	mov	0x164 <_PWM_MASTER2+0x8>, Y

00009940 <.LBB1040>:
                                    uint16_t CMP_,
                                    PwmMode_t MODE_,
                                    PwmPolarity_t POL_,
                                    uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_MASTER1, PSCLM, ((DIV_)-1) & 0x0Fu,
    9940:	0ea7      	lod	C, ML.7
    9942:	7008      	lod	A, #8
    9944:	52d8 013c 	mov	0x13c <_PWM_MASTER1+0x8>, A

00009948 <.LM8>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 0u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_MASTER1, PER, PERIOD_);
    9948:	7eda 0640 	lod	X, #1600
    994c:	0ea7      	lod	C, ML.7
    994e:	5ed8 013a 	mov	0x13a <_PWM_MASTER1+0x6>, X

00009952 <.LM9>:
    IO_SET(PWM_MASTER1, CMP, CMP_);
    9952:	72da 010b 	lod	A, #267
    9956:	52d8 0134 	mov	0x134 <_PWM_MASTER1>, A

0000995a <.LM10>:
    IO_SET(PWM_MASTER1, LT, LT_);
    995a:	0ea7      	lod	C, ML.7
    995c:	7000      	lod	A, #0
    995e:	52d8 0138 	mov	0x138 <_PWM_MASTER1+0x4>, A

00009962 <.LM11>:
    IO_SET(PWM_MASTER1, HT, HT_);
    9962:	52d8 0136 	mov	0x136 <_PWM_MASTER1+0x2>, A

00009966 <.LBB1042>:
#define PWM1_INIT pwm1_init

STATIC INLINE void pwm1_init(uint8_t DIV_, uint8_t DIVN_, uint16_t LT_, uint16_t HT_,
                             uint16_t CMP_, PwmMode_t MODE_, PwmPolarity_t POL_, uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_SLAVE1, PSCLM, ((DIV_)-1) & 0x0Fu,
    9966:	0ea7      	lod	C, ML.7
    9968:	7c0c      	lod	X, #12
    996a:	5ed8 0146 	mov	0x146 <.LASF2017+0x3>, X

0000996e <.LM13>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 1u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_SLAVE1, CMP, CMP_);
    996e:	7eda 0215 	lod	X, #533
    9972:	0ea7      	lod	C, ML.7
    9974:	5ed8 013e 	mov	0x13e <_PWM_SLAVE1>, X

00009978 <.LM14>:
    IO_SET(PWM_SLAVE1, LT, LT_);
    9978:	52d8 0142 	mov	0x142 <.LASF2025+0x2>, A

0000997c <.LM15>:
    IO_SET(PWM_SLAVE1, HT, HT_);
    997c:	52d8 0140 	mov	0x140 <.LASF2025>, A

00009980 <.LBB1044>:
#define PWM2_INIT pwm2_init

STATIC INLINE void pwm2_init(uint8_t DIV_, uint8_t DIVN_, uint16_t LT_, uint16_t HT_,
                             uint16_t CMP_, PwmMode_t MODE_, PwmPolarity_t POL_, uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_SLAVE2, PSCLM, ((DIV_)-1) & 0x0Fu,
    9980:	0ea7      	lod	C, ML.7
    9982:	7c0c      	lod	X, #12
    9984:	5ed8 0150 	mov	0x150 <_PWM_SLAVE2+0x8>, X

00009988 <.LM17>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 1u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_SLAVE2, CMP, CMP_);
    9988:	7eda 0320 	lod	X, #800
    998c:	0ea7      	lod	C, ML.7
    998e:	5ed8 0148 	mov	0x148 <_PWM_SLAVE2>, X

00009992 <.LM18>:
    IO_SET(PWM_SLAVE2, LT, LT_);
    9992:	52d8 014c 	mov	0x14c <_PWM_SLAVE2+0x4>, A

00009996 <.LM19>:
    IO_SET(PWM_SLAVE2, HT, HT_);
    9996:	52d8 014a 	mov	0x14a <_PWM_SLAVE2+0x2>, A

0000999a <.LBB1046>:
#define PWM3_INIT pwm3_init

STATIC INLINE void pwm3_init(uint8_t DIV_, uint8_t DIVN_, uint16_t LT_, uint16_t HT_,
                             uint16_t CMP_, PwmMode_t MODE_, PwmPolarity_t POL_, uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_SLAVE3, PSCLM, ((DIV_)-1) & 0x0Fu,
    999a:	0ea7      	lod	C, ML.7
    999c:	7c0c      	lod	X, #12
    999e:	5ed8 015a 	mov	0x15a <.LASF1651+0x3>, X

000099a2 <.LM21>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 1u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_SLAVE3, CMP, CMP_);
    99a2:	7eda 042a 	lod	X, #1066
    99a6:	0ea7      	lod	C, ML.7
    99a8:	5ed8 0152 	mov	0x152 <_PWM_SLAVE3>, X

000099ac <.LM22>:
    IO_SET(PWM_SLAVE3, LT, LT_);
    99ac:	52d8 0156 	mov	0x156 <_PWM_SLAVE3+0x4>, A

000099b0 <.LM23>:
    IO_SET(PWM_SLAVE3, HT, HT_);
    99b0:	52d8 0154 	mov	0x154 <_PWM_SLAVE3+0x2>, A

000099b4 <.LBB1048>:
                                    uint16_t CMP_,
                                    PwmMode_t MODE_,
                                    PwmPolarity_t POL_,
                                    uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_MASTER2, PSCLM, ((DIV_)-1) & 0x0Fu,
    99b4:	0ea7      	lod	C, ML.7
    99b6:	7c08      	lod	X, #8
    99b8:	5ed8 0164 	mov	0x164 <_PWM_MASTER2+0x8>, X

000099bc <.LM25>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 0u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_MASTER2, PER, PERIOD_);
    99bc:	7eda 0640 	lod	X, #1600
    99c0:	0ea7      	lod	C, ML.7
    99c2:	5ed8 0162 	mov	0x162 <_PWM_MASTER2+0x6>, X

000099c6 <.LM26>:
    IO_SET(PWM_MASTER2, CMP, CMP_);
    99c6:	7eda 0535 	lod	X, #1333
    99ca:	5ed8 015c 	mov	0x15c <_PWM_MASTER2>, X

000099ce <.LM27>:
    IO_SET(PWM_MASTER2, LT, LT_);
    99ce:	0ea7      	lod	C, ML.7
    99d0:	52d8 0160 	mov	0x160 <_PWM_MASTER2+0x4>, A

000099d4 <.LM28>:
    IO_SET(PWM_MASTER2, HT, HT_);
    99d4:	52d8 015e 	mov	0x15e <_PWM_MASTER2+0x2>, A

000099d8 <.LBB1050>:
#if defined (IO_PWM_MASTER1__START_GET)
#define PWM1_MASTER_ENABLE pwm1_master_enable

STATIC INLINE void pwm1_master_enable(void)
{
    IO_HOST(PWM_MASTER1, START) = 1u << IO_OFFSET(PWM_MASTER1, START);
    99d8:	7c01      	lod	X, #1
    99da:	0ea7      	lod	C, ML.7
    99dc:	5ed8 013c 	mov	0x13c <_PWM_MASTER1+0x8>, X

000099e0 <.LBB1052>:
#if defined (IO_PWM_SLAVE1__START_GET)
#define PWM1_ENABLE pwm1_enable

STATIC INLINE void pwm1_enable(void)
{
    IO_HOST(PWM_SLAVE1, START) = 1u << IO_OFFSET(PWM_SLAVE1, START);
    99e0:	5ed8 0146 	mov	0x146 <.LASF2017+0x3>, X

000099e4 <.LBB1054>:
#if defined (IO_PWM_SLAVE2__START_GET)
#define PWM2_ENABLE pwm2_enable

STATIC INLINE void pwm2_enable(void)
{
    IO_HOST(PWM_SLAVE2, START) = 1u << IO_OFFSET(PWM_SLAVE2, START);
    99e4:	5ed8 0150 	mov	0x150 <_PWM_SLAVE2+0x8>, X

000099e8 <.LBB1056>:
#if defined (IO_PWM_SLAVE3__START_GET)
#define PWM3_ENABLE pwm3_enable

STATIC INLINE void pwm3_enable(void)
{
    IO_HOST(PWM_SLAVE3, START) = 1u << IO_OFFSET(PWM_SLAVE3, START);
    99e8:	0ea7      	lod	C, ML.7
    99ea:	5ed8 015a 	mov	0x15a <.LASF1651+0x3>, X

000099ee <.LBB1058>:
#if defined (IO_PWM_MASTER2__START_GET)
#define PWM2_MASTER_ENABLE pwm2_master_enable

STATIC INLINE void pwm2_master_enable(void)
{
    IO_HOST(PWM_MASTER2, START) = 1u << IO_OFFSET(PWM_MASTER2, START);
    99ee:	5ed8 0164 	mov	0x164 <_PWM_MASTER2+0x8>, X

000099f2 <.LBB1060>:
    99f2:	7eda eeee 	lod	X, #61166
    99f6:	0ea7      	lod	C, ML.7
    99f8:	5ed8 0216 	mov	0x216 <_PORT_DRV_CTRL>, X

000099fc <.LBE1060>:
                                DRV_CTRL_TRISTATE,  /* W */
                                DRV_CTRL_TRISTATE); /* T */

    /* enable digital part of the driver */
    // drvcfg_Enable(); in motor3ph_pwm_private.h
    IO_SET(PORT_DRV2_PROT, DIS_DRV, 0u);
    99fc:	42d8 021a 	mov	0x21a <_PORT_DRV2_PROT>, AL

00009a00 <.LM36>:

    IO_SET(PORT_DRV_OUT, ENABLE_DRVSUP, 0x1u); /* enable driver supply */
    9a00:	62d8 020e 	lod	AL, 0x20e <_PORT_DRV_OUT>
    9a04:	8401      	or	AL, #1
    9a06:	42d8 020e 	mov	0x20e <_PORT_DRV_OUT>, AL

00009a0a <.LBB1062>:
    }
}

STATIC INLINE void DELAY(const uint16_t loops)
{
    delay_cycles(loops);
    9a0a:	7050      	lod	A, #80
    9a0c:	5a01      	mov	[S-2], Y
    9a0e:	82db 1128 	callf	0x2250 <_delay_cycles>

00009a12 <.LBE1062>:

    /* wait some time to have Vddaf to stabilize */
    DELAY_US(10u);

    /* enable the driver */
    IO_SET(PORT_DRV_OUT,
    9a12:	72d8 020e 	lod	A, 0x20e <_PORT_DRV_OUT>
    9a16:	b6da f001 	and	A, #61441
    9a1a:	a6da 09c2 	or	A, #2498
    9a1e:	0ea7      	lod	C, ML.7
    9a20:	52d8 020e 	mov	0x20e <_PORT_DRV_OUT>, A

00009a24 <.LBB1065>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    9a24:	7ee3      	lod	X, M

00009a26 <.LBB1068>:
    return 1;
}

STATIC INLINE uint16_t mlx16_di_enter_system_mode(void)
{
    __asm__ __volatile__ (".word OPCODE_CALL_FP_ENTER_SYSTEM_MODE_PRIO_0");
    9a26:	5049      	call	fp2:0x48

00009a28 <.LBE1068>:
           DRVMOD_OPTION, 0x0u,
           PARALLEL_MODE_DRV, 0x1u); /* enable parallel mode U+V, W+T driver */

    /* configure pwm update sync interrupt - CNT ISR */
    ENTER_SECTION(ATOMIC_SYSTEM_MODE);
    Itc_SetPrio(PWM_MASTER1_END, 3u);
    9a28:	62d8 008a 	lod	AL, 0x8a <__mlx4_flash_table_size+0x2>
    9a2c:	943f      	and	AL, #63
    9a2e:	42d8 008a 	mov	0x8a <__mlx4_flash_table_size+0x2>, AL

00009a32 <.LBB1070>:

#define PWM1_MASTER_CNTI_ENABLE pwm1_master_cnti_enable

STATIC INLINE void pwm1_master_cnti_enable(void)
{
    Itc_Clear(PWM_MASTER1_END);
    9a32:	6080      	lod	AL, #-128
    9a34:	42d8 0053 	mov	0x53 <.LASF1528+0x6>, AL

00009a38 <.LM43>:
    Itc_Enable(PWM_MASTER1_END);
    9a38:	0ea7      	lod	C, ML.7
    9a3a:	62d8 006f 	lod	AL, 0x6f <__mlx4_cst_tables_ram_size+0x11>
    9a3e:	8480      	or	AL, #-128
    9a40:	42d8 006f 	mov	0x6f <__mlx4_cst_tables_ram_size+0x11>, AL

00009a44 <.LBB1072>:
#if defined (IO_PWM_SLAVE2__START_GET)
#define PWM2_CMPI_ENABLE pwm2_cmpi_enable

STATIC INLINE void pwm2_cmpi_enable(void)
{
    Itc_Clear(PWM_SLAVE2_CMP);
    9a44:	7a01      	lod	Y, [S-2]
    9a46:	46d8 0054 	mov	0x54 <.Lframe0>, YL

00009a4a <.LM45>:
    Itc_Enable(PWM_SLAVE2_CMP);
    9a4a:	62d8 0070 	lod	AL, 0x70 <__mlx4_cst_tables_ram_size+0x12>
    9a4e:	8402      	or	AL, #2
    9a50:	42d8 0070 	mov	0x70 <__mlx4_cst_tables_ram_size+0x12>, AL

00009a54 <.LBB1074>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    9a54:	5ee3      	mov	M, X

00009a56 <.LBE1065>:
    pwm1_master_cnti_enable();
    pwm2_cmpi_enable(); // pwm2
    EXIT_SECTION();

    u16DutyCycleMax = 0x4000;
}
    9a56:	5403      	ret	#4

00009a58 <_pwm_SetDutyCycle>:
 * @param[in]  u8Channels    The channel(s) to update the duty cycle for.
 * @param[in]  u16DutyCycle  The new pwm duty cycle (u16DutyCycle < u16DutyCycleMax).
 */
extern uint16_t g_u16debug_2, g_u16debug_5;
void pwm_SetDutyCycle(uint8_t dir, uint16_t u16DutyCycle)
{
    9a58:	5801      	inc	S, #2

00009a5a <.LCFI1>:
    9a5a:	7e05      	lod	X, [S-6]
    9a5c:	7ada 0800 	lod	Y, #2048
    9a60:	2ee6      	cmp	X, Y
    9a62:	1a01      	jule	0x9a66 <.L3>
    9a64:	7ee6      	lod	X, Y

00009a66 <.L3>:

    if (u16DutyCycle > C_PWMOUT_MAX_DUTY)
    {
        u16DutyCycle = C_PWMOUT_MAX_DUTY;
    }
    u16DutyCycle = (C_PWMOUT_MAX_DUTY - u16DutyCycle);
    9a66:	eaee      	sub	Y, X

00009a68 <.LM50>:
     * |     _____________     |
     * |____|             |____|
     */

    /* Change direction */
    switch (dir)
    9a68:	ac01      	cmp	A, #1
    9a6a:	190f      	je	0x9a8a <.L5>
    9a6c:	ac02      	cmp	A, #2
    9a6e:	1912      	je	0x9a94 <.L6>

00009a70 <.L4>:
MATHLIB_INLINE_STATIC __inline__ uint16_t mulU16hi_U16byU16(uint16_t multiplicand, uint16_t multiplier)
{
    uint16_t result;
    uint16_t result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9a70:	72e6      	lod	A, Y
    9a72:	4822 63f0 	mulu	YA, A, #25584

00009a76 <.LBE1078>:
        break;
    } /* Change direction */

    u16LT = mulU16hi_U16byU16(u16DutyCycle, PWM_PERIOD << 4);

    u16LTcopy[0] = u16LT; /* U */
    9a76:	5ad8 11bc 	mov	0x11bc <_u16LTcopy>, Y

00009a7a <.LM53>:
    u16LTcopy[1] = u16LT; /* V */
    9a7a:	5ad8 11be 	mov	0x11be <.LASF1511+0x1>, Y

00009a7e <.LM54>:
    u16LTcopy[2] = u16LT; /* W */
    9a7e:	5ad8 11c0 	mov	0x11c0 <.LASF1511+0x3>, Y

00009a82 <.LM55>:
    u16LTcopy[3] = u16LT; /* T */
    9a82:	0ea7      	lod	C, ML.7
    9a84:	5ad8 11c2 	mov	0x11c2 <.LASF1511+0x5>, Y

00009a88 <.LM56>:
}
    9a88:	5403      	ret	#4

00009a8a <.L5>:
    9a8a:	72da dd00 	lod	A, #56576

00009a8e <.L7>:
    9a8e:	52d8 0216 	mov	0x216 <_PORT_DRV_CTRL>, A
    9a92:	07ee      	jmp	0x9a70 <.L4>

00009a94 <.L6>:
    9a94:	72da 33dd 	lod	A, #13277

00009a98 <.LVL21>:
    9a98:	07fa      	jmp	0x9a8e <.L7>

00009a9a <_pwm_Start>:
 * This function will start the pwm driver and will enable the
 * output of the pwm signals on the driver pins.
 * @param[in]  u16DutyCycle  The new pwm duty cycle (u16DutyCycle < u16DutyCycleMax).
 */
void pwm_Start(uint8_t dir, uint16_t u16DutyCycle)
{
    9a9a:	7e03      	lod	X, [S-4]

00009a9c <.LM60>:
			Itc_Enable(OVC);
			Itc_Clear(OVT);
			Itc_Enable(OVT);
			EXIT_SECTION();
#endif
        pwm_SetDutyCycle(dir, u16DutyCycle);
    9a9c:	5edf      	push	X

00009a9e <.LCFI2>:
    9a9e:	17dc      	call	0x9a58 <_pwm_SetDutyCycle>

00009aa0 <.LM61>:
            MotorDriverUVWTSelectSource(DRV_CTRL_PWM_MASTER1,  /* U - Phase A */
            							DRV_CTRL_PWM_MASTER1,  /* V - Phase A */
										DRV_CTRL_PWM_SLAVE1,   /* W - Phase B */
										DRV_CTRL_PWM_SLAVE1);  /* T - Phase B */
#endif
        IO_SET(PORT_DRV_OUT, ENABLE_DRV, 0xFu); /* enable drivers of phases U,V,W,T */
    9aa0:	62d8 020e 	lod	AL, 0x20e <_PORT_DRV_OUT>
    9aa4:	843c      	or	AL, #60
    9aa6:	42d8 020e 	mov	0x20e <_PORT_DRV_OUT>, AL

00009aaa <.LCFI3>:
    }
}
    9aaa:	5403      	ret	#4

00009aac <_pwm_Stop>:
    9aac:	72da dddd 	lod	A, #56797
    9ab0:	52d8 0216 	mov	0x216 <_PORT_DRV_CTRL>, A

00009ab4 <.LBE1084>:
                                DRV_CTRL_LOW,  /* V */
                                DRV_CTRL_LOW,  /* W */
                                DRV_CTRL_LOW); /* T */

    /* stop pwm modules output */
    IO_SET(PWM_MASTER1, LT, 0u); /* U */
    9ab4:	7000      	lod	A, #0
    9ab6:	0ea7      	lod	C, ML.7
    9ab8:	52d8 0138 	mov	0x138 <_PWM_MASTER1+0x4>, A

00009abc <.LM68>:
    IO_SET(PWM_SLAVE1, LT, 0u);  /* V */
    9abc:	52d8 0142 	mov	0x142 <.LASF2025+0x2>, A

00009ac0 <.LM69>:
    IO_SET(PWM_SLAVE2, LT, 0u);  /* W */
    9ac0:	52d8 014c 	mov	0x14c <_PWM_SLAVE2+0x4>, A

00009ac4 <.LM70>:
    IO_SET(PWM_SLAVE3, LT, 0u);  /* T */
    9ac4:	0ea7      	lod	C, ML.7
    9ac6:	52d8 0156 	mov	0x156 <_PWM_SLAVE3+0x4>, A

00009aca <.LM71>:
}
    9aca:	5401      	ret

00009acc <_pwm_Off>:
    9acc:	72da eeee 	lod	A, #61166
    9ad0:	52d8 0216 	mov	0x216 <_PORT_DRV_CTRL>, A

00009ad4 <.LBE1086>:
                                DRV_CTRL_TRISTATE,  /* V */
                                DRV_CTRL_TRISTATE,  /* W */
                                DRV_CTRL_TRISTATE); /* T */

    /* stop pwm modules output */
    IO_SET(PWM_MASTER1, LT, 0u); /* U */
    9ad4:	7000      	lod	A, #0
    9ad6:	0ea7      	lod	C, ML.7
    9ad8:	52d8 0138 	mov	0x138 <_PWM_MASTER1+0x4>, A

00009adc <.LM75>:
    IO_SET(PWM_SLAVE1, LT, 0u);  /* V */
    9adc:	52d8 0142 	mov	0x142 <.LASF2025+0x2>, A

00009ae0 <.LM76>:
    IO_SET(PWM_SLAVE2, LT, 0u);  /* W */
    9ae0:	52d8 014c 	mov	0x14c <_PWM_SLAVE2+0x4>, A

00009ae4 <.LM77>:
    IO_SET(PWM_SLAVE3, LT, 0u);  /* T */
    9ae4:	0ea7      	lod	C, ML.7
    9ae6:	52d8 0156 	mov	0x156 <_PWM_SLAVE3+0x4>, A

00009aea <.LM78>:
}
    9aea:	5401      	ret

00009aec <_pwm_Disable>:
    9aec:	72da eeee 	lod	A, #61166
    9af0:	52d8 0216 	mov	0x216 <_PORT_DRV_CTRL>, A

00009af4 <.LBE1088>:
                                DRV_CTRL_TRISTATE,  /* V */
                                DRV_CTRL_TRISTATE,  /* W */
                                DRV_CTRL_TRISTATE); /* T */

    /* stop pwm modules output */
    IO_SET(PWM_MASTER1, LT, 0u); /* U */
    9af4:	7000      	lod	A, #0
    9af6:	0ea7      	lod	C, ML.7
    9af8:	52d8 0138 	mov	0x138 <_PWM_MASTER1+0x4>, A

00009afc <.LM82>:
    IO_SET(PWM_SLAVE1, LT, 0u);  /* V */
    9afc:	52d8 0142 	mov	0x142 <.LASF2025+0x2>, A

00009b00 <.LM83>:
    IO_SET(PWM_SLAVE2, LT, 0u);  /* W */
    9b00:	52d8 014c 	mov	0x14c <_PWM_SLAVE2+0x4>, A

00009b04 <.LM84>:
    IO_SET(PWM_SLAVE3, LT, 0u);  /* T */
    9b04:	0ea7      	lod	C, ML.7
    9b06:	52d8 0156 	mov	0x156 <_PWM_SLAVE3+0x4>, A

00009b0a <.LM85>:

    IO_SET(PORT_DRV_OUT,
    9b0a:	62d8 020e 	lod	AL, 0x20e <_PORT_DRV_OUT>
    9b0e:	94c0      	and	AL, #-64
    9b10:	42d8 020e 	mov	0x20e <_PORT_DRV_OUT>, AL

00009b14 <.LM86>:
           ENABLE_DRV, 0x0u,           /* disable drivers of all phases */
           ENABLE_DRVSUP, 0x0u,        /* disable driver supply */
           ENABLE_DRVMOD_CPCLK, 0x0u); /* disable driver clock */

    IO_SET(PORT_DRV2_PROT, DIS_DRV, 1u); /* disable digital part of the driver */
    9b14:	6001      	lod	AL, #1
    9b16:	42d8 021a 	mov	0x21a <_PORT_DRV2_PROT>, AL

00009b1a <.LBB1090>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    9b1a:	7ee3      	lod	X, M

00009b1c <.LBB1093>:
    9b1c:	5049      	call	fp2:0x48

00009b1e <.LBE1093>:

    ENTER_SECTION(ATOMIC_SYSTEM_MODE);
    Itc_Disable(DIAG);
    9b1e:	62d8 0071 	lod	AL, 0x71 <__mlx4_cst_tables_ram_size+0x13>
    9b22:	94f7      	and	AL, #-9
    9b24:	42d8 0071 	mov	0x71 <__mlx4_cst_tables_ram_size+0x13>, AL

00009b28 <.LM90>:
    Itc_Disable(UV_VS);
    9b28:	62d8 006c 	lod	AL, 0x6c <__mlx4_cst_tables_ram_size+0xe>
    9b2c:	947f      	and	AL, #127
    9b2e:	42d8 006c 	mov	0x6c <__mlx4_cst_tables_ram_size+0xe>, AL

00009b32 <.LM91>:
    Itc_Disable(OV_VS);
    9b32:	62d8 0071 	lod	AL, 0x71 <__mlx4_cst_tables_ram_size+0x13>
    9b36:	94fb      	and	AL, #-5
    9b38:	42d8 0071 	mov	0x71 <__mlx4_cst_tables_ram_size+0x13>, AL

00009b3c <.LBB1095>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    9b3c:	5ee3      	mov	M, X

00009b3e <.LBE1090>:
    EXIT_SECTION();
}
    9b3e:	5401      	ret

00009b40 <__PWM_MASTER1_END_INT>:
 *
 * This function will handle the end of period interrupt to produce a
 * synchronized PWM LT update.
 */
INTERRUPT void _PWM_MASTER1_END_INT(void)
{
    9b40:	52df      	push	A

00009b42 <.LCFI4>:
    IO_SET(PWM_MASTER1, LT, u16LTcopy[0]); /* U */
    9b42:	72d8 11bc 	lod	A, 0x11bc <_u16LTcopy>
    9b46:	52d8 0138 	mov	0x138 <_PWM_MASTER1+0x4>, A

00009b4a <.LM96>:
    IO_SET(PWM_SLAVE1, LT, u16LTcopy[1]);  /* V */
    9b4a:	72d8 11be 	lod	A, 0x11be <.LASF1511+0x1>
    9b4e:	0ea7      	lod	C, ML.7
    9b50:	52d8 0142 	mov	0x142 <.LASF2025+0x2>, A

00009b54 <.LM97>:
    IO_SET(PWM_SLAVE2, LT, u16LTcopy[2]);  /* W */
    9b54:	72d8 11c0 	lod	A, 0x11c0 <.LASF1511+0x3>
    9b58:	52d8 014c 	mov	0x14c <_PWM_SLAVE2+0x4>, A

00009b5c <.LM98>:
    IO_SET(PWM_SLAVE3, LT, u16LTcopy[3]);  /* T */
    9b5c:	0ea7      	lod	C, ML.7
    9b5e:	72d8 11c2 	lod	A, 0x11c2 <.LASF1511+0x5>
    9b62:	52d8 0156 	mov	0x156 <_PWM_SLAVE3+0x4>, A

00009b66 <.LM99>:

    //    ENTER_SECTION(ATOMIC_SYSTEM_MODE);
    //    Itc_Disable(PWM_MASTER1_END);
    //    EXIT_SECTION();
}
    9b66:	72cf      	pop	A

00009b68 <.LCFI5>:
    9b68:	72cb      	pop	M
    9b6a:	5401      	ret

00009b6c <__PWM_SLAVE2_CMP_INT>:

INTERRUPT void _PWM_SLAVE2_CMP_INT(void)
{
}
    9b6c:	72cb      	pop	M
    9b6e:	5401      	ret

00009b70 <__DIAG_INT>:
 *
 * This function will handle the generic motor driver
 * interrupt.
 */
INTERRUPT void _DIAG_INT(void)
{
    9b70:	5edf      	push	X

00009b72 <.LCFI6>:
    9b72:	5adf      	push	Y

00009b74 <.LCFI7>:
    9b74:	52df      	push	A

00009b76 <.LCFI8>:
    9b76:	4c83      	push	D

00009b78 <.LCFI9>:
    /* remember the diagnostic error, all diagnostic errors need to be
     * cleared before the driver can be started again
     */
    u16LastDiagErr = IO_HOST(PORT_DIAG_IN, OVT_MEM);
    9b78:	72d8 021e 	lod	A, 0x21e <_PORT_DIAG_IN>

00009b7c <.LM104>:

    pwm_Stop();
    9b7c:	1797      	call	0x9aac <_pwm_Stop>

00009b7e <.LM105>:

    /* disable the interrupt, otherwise the interrupt will be called continuously */
    Itc_Disable(DIAG);
    9b7e:	62d8 0071 	lod	AL, 0x71 <__mlx4_cst_tables_ram_size+0x13>
    9b82:	94f7      	and	AL, #-9
    9b84:	42d8 0071 	mov	0x71 <__mlx4_cst_tables_ram_size+0x13>, AL

00009b88 <.LM106>:
}
    9b88:	4cc3      	pop	D

00009b8a <.LCFI10>:
    9b8a:	72cf      	pop	A

00009b8c <.LCFI11>:
    9b8c:	7acf      	pop	Y

00009b8e <.LCFI12>:
    9b8e:	7ecf      	pop	X

00009b90 <.LCFI13>:
    9b90:	72cb      	pop	M
    9b92:	5401      	ret

00009b94 <_swtimer_init>:
 * Initialize Core Timer and start.
 */
void swtimer_init(void)
{
    /* Init clock error conversion */
    conv_clock_error_init();
    9b94:	82db 3d16 	callf	0x7a2c <_conv_clock_error_init>

00009b98 <.LBB198>:
/** STIMER_SET_MODE sets the simple timer's mode
 * @param[in] mode new Simple Timer's mode
 */
STATIC INLINE void STIMER_SET_MODE( STimerClk_t mode )
{
    IO_SET(STIMER, MODE, (uint16_t)mode);
    9b98:	72b2      	lod	A, io:0x32 <_STIMER+0x2>
    9b9a:	d43f      	and	AH, #63
    9b9c:	c480      	or	AH, #-128
    9b9e:	52b2      	mov	io:0x32 <_STIMER+0x2>, A

00009ba0 <.LBB201>:
/** STIMER_SET_VALUE sets the simple timer's mode
 * @param[in] value is new 14-bit timer value
 */
STATIC INLINE void STIMER_SET_VALUE( uint16_t value )
{
    IO_SET(STIMER, VALUE, value);
    9ba0:	72b2      	lod	A, io:0x32 <_STIMER+0x2>
    9ba2:	b6da c000 	and	A, #49152
    9ba6:	8464      	or	AL, #100
    9ba8:	52b2      	mov	io:0x32 <_STIMER+0x2>, A

00009baa <.LBB203>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    9baa:	7ee3      	lod	X, M

00009bac <.LBB206>:
    return 1;
}

STATIC INLINE uint16_t mlx16_enter_system_mode_keep_prio(void)
{
    __asm__ __volatile__ (".word OPCODE_CALL_FP_ENTER_SYSTEM_MODE_KEEP_PRIO");
    9bac:	5048      	call	fp2:0x40

00009bae <.LBE206>:
    STIMER_INIT(STIMER_1US_CLOCK, CT_PERIODIC_RATE);

    /* Enable Timer interrupt */
    #ifndef UNITTEST
    ENTER_SECTION(SYSTEM_MODE);
    Itc_Clear(STIMER);
    9bae:	6010      	lod	AL, #16
    9bb0:	42d8 0052 	mov	0x52 <.LASF1528+0x5>, AL

00009bb4 <.LM8>:
    Itc_Enable(STIMER);
    9bb4:	62d8 006e 	lod	AL, 0x6e <__mlx4_cst_tables_ram_size+0x10>
    9bb8:	8410      	or	AL, #16
    9bba:	42d8 006e 	mov	0x6e <__mlx4_cst_tables_ram_size+0x10>, AL

00009bbe <.LBB208>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    9bbe:	5ee3      	mov	M, X

00009bc0 <.LBE203>:

    EXIT_SECTION();
    #endif

    /* Clear all */
    (void)memset((void *)g_pTimer, 0, sizeof(g_pTimer) / sizeof(uint8_t));
    9bc0:	7eda 1412 	lod	X, #5138
    9bc4:	7000      	lod	A, #0
    9bc6:	54ee      	mov	Cx, #14
    9bc8:	52de      	mov	[X++], A
    9bca:	1ffe      	djnz	Cx, 0x9bc8 <.LASF1016>

00009bcc <.LM11>:
}
    9bcc:	5401      	ret

00009bce <_swtimer_deinit>:
/** STIMER_SET_MODE sets the simple timer's mode
 * @param[in] mode new Simple Timer's mode
 */
STATIC INLINE void STIMER_SET_MODE( STimerClk_t mode )
{
    IO_SET(STIMER, MODE, (uint16_t)mode);
    9bce:	72b2      	lod	A, io:0x32 <_STIMER+0x2>
    9bd0:	d43f      	and	AH, #63
    9bd2:	52b2      	mov	io:0x32 <_STIMER+0x2>, A

00009bd4 <.LBB214>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    9bd4:	7ee3      	lod	X, M

00009bd6 <.LBB217>:
    9bd6:	5048      	call	fp2:0x40

00009bd8 <.LBE217>:
    STIMER_SET_MODE(STIMER_DISABLE_CLOCK);  /* switch off */

    /* Disable Timer interrupt */
    #ifndef UNITTEST
    ENTER_SECTION(SYSTEM_MODE);
    Itc_Disable(STIMER);
    9bd8:	62d8 006e 	lod	AL, 0x6e <__mlx4_cst_tables_ram_size+0x10>
    9bdc:	94ef      	and	AL, #-17
    9bde:	42d8 006e 	mov	0x6e <__mlx4_cst_tables_ram_size+0x10>, AL

00009be2 <.LBB219>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    9be2:	5ee3      	mov	M, X

00009be4 <.LBE214>:
    EXIT_SECTION();
    #endif
}
    9be4:	5401      	ret

00009be6 <_swtimer_calibrate>:
void swtimer_calibrate(uint16_t u16ADC_Value)
{
    int16_t i16ClockCountCorrection = 0;

    /* Get clock count correction */
    i16ClockCountCorrection = conv_clock_error_speed(u16ADC_Value);
    9be6:	82db 3d2a 	callf	0x7a54 <_conv_clock_error_speed>

00009bea <.LM21>:

    i16ClockCountCorrection = conv_clock_error_correct_period(CT_PERIODIC_RATE, i16ClockCountCorrection);
    9bea:	52df      	push	A

00009bec <.LCFI0>:
    9bec:	7064      	lod	A, #100

00009bee <.LVL13>:
    9bee:	82db 3d40 	callf	0x7a80 <_conv_clock_error_correct_period>

00009bf2 <.LBB223>:
/** STIMER_SET_VALUE sets the simple timer's mode
 * @param[in] value is new 14-bit timer value
 */
STATIC INLINE void STIMER_SET_VALUE( uint16_t value )
{
    IO_SET(STIMER, VALUE, value);
    9bf2:	7eb2      	lod	X, io:0x32 <_STIMER+0x2>
    9bf4:	36da c000 	and	X, #49152
    9bf8:	a6ee      	or	A, X

00009bfa <.LVL15>:
    9bfa:	52b2      	mov	io:0x32 <_STIMER+0x2>, A

00009bfc <.LBE223>:
    STIMER_SET_VALUE(i16ClockCountCorrection);
}
    9bfc:	5403      	ret	#4

00009bfe <_swtimer_register>:
 */
bool swtimer_register(swtimer_id_t a_e8Id, uint16_t a_u15Load, swtimer_mode_t a_eMode)
{
    bool bRetVal = false;

    if ((a_e8Id < SWTIMER_NR_OF) && (a_u15Load < 0x8000))
    9bfe:	ac06      	cmp	A, #6
    9c00:	1e12      	jug	0x9c26 <.L7>

00009c02 <.LM26>:
 * @param  a_u15Load  a 15-bit load value [0:0x8000] x CT_PERIODIC_RATE us
 * @param  a_eMode  timer mode, single shot or repetitive
 * @return  true  in case of success
 */
bool swtimer_register(swtimer_id_t a_e8Id, uint16_t a_u15Load, swtimer_mode_t a_eMode)
{
    9c02:	7a03      	lod	Y, [S-4]

00009c04 <.LM27>:
    bool bRetVal = false;

    if ((a_e8Id < SWTIMER_NR_OF) && (a_u15Load < 0x8000))
    9c04:	ec00      	cmp	Y, #0
    9c06:	1a8f      	jsl	0x9c26 <.L7>

00009c08 <.LM28>:
    {
        g_pTimer[a_e8Id].bRepetitive = (a_eMode == REPETITIVE) ? 1u : 0u;
    9c08:	44a2      	asl	A, #2

00009c0a <.LVL17>:
    9c0a:	7ee2      	lod	X, A
    9c0c:	22da 1412 	add	X, #5138

00009c10 <.LM29>:
 * @param  a_u15Load  a 15-bit load value [0:0x8000] x CT_PERIODIC_RATE us
 * @param  a_eMode  timer mode, single shot or repetitive
 * @return  true  in case of success
 */
bool swtimer_register(swtimer_id_t a_e8Id, uint16_t a_u15Load, swtimer_mode_t a_eMode)
{
    9c10:	7205      	lod	A, [S-6]

00009c12 <.LM30>:
    bool bRetVal = false;

    if ((a_e8Id < SWTIMER_NR_OF) && (a_u15Load < 0x8000))
    {
        g_pTimer[a_e8Id].bRepetitive = (a_eMode == REPETITIVE) ? 1u : 0u;
    9c12:	ac01      	cmp	A, #1
    9c14:	5c82      	se	A

00009c16 <.LM31>:
        g_pTimer[a_e8Id].u15Load = a_u15Load;
    9c16:	f6da 7fff 	and	Y, #32767
    9c1a:	b401      	and	A, #1
    9c1c:	4452      	rr	A
    9c1e:	a6e6      	or	A, Y
    9c20:	52f8      	mov	[X], A

00009c22 <.LM32>:
        bRetVal = true;
    9c22:	7001      	lod	A, #1
    9c24:	5401      	ret

00009c26 <.L7>:
 * @param  a_eMode  timer mode, single shot or repetitive
 * @return  true  in case of success
 */
bool swtimer_register(swtimer_id_t a_e8Id, uint16_t a_u15Load, swtimer_mode_t a_eMode)
{
    bool bRetVal = false;
    9c26:	7000      	lod	A, #0

00009c28 <.LM34>:
        g_pTimer[a_e8Id].bRepetitive = (a_eMode == REPETITIVE) ? 1u : 0u;
        g_pTimer[a_e8Id].u15Load = a_u15Load;
        bRetVal = true;
    }
    return bRetVal;
}
    9c28:	5401      	ret

00009c2a <_swtimer_start>:
 * Start a software timer
 * @param[in]  a_e8Id  Timer id
 */
void swtimer_start(swtimer_id_t a_e8Id)
{
    g_pTimer[a_e8Id].u15Current = g_pTimer[a_e8Id].u15Load;
    9c2a:	44a2      	asl	A, #2

00009c2c <.LVL22>:
    9c2c:	7ee2      	lod	X, A
    9c2e:	22da 1412 	add	X, #5138
    9c32:	7af8      	lod	Y, [X]
    9c34:	f6da 7fff 	and	Y, #32767
    9c38:	72fa      	lod	A, [X+2]
    9c3a:	b6da 8000 	and	A, #32768
    9c3e:	a6e6      	or	A, Y
    9c40:	52fa      	mov	[X+2], A

00009c42 <.LM37>:
    g_pTimer[a_e8Id].bTriggered = 0u;
    9c42:	2003      	add	X, #3
    9c44:	62f8      	lod	AL, [X]
    9c46:	947f      	and	AL, #127
    9c48:	42f8      	mov	[X], AL

00009c4a <.LM38>:
}
    9c4a:	5401      	ret

00009c4c <_swtimer_isTriggered>:
 * Check if a software timer has expired and clear it by timer id.
 * @param[in]  a_e8Id  Timer id
 * @return  true  if expired
 */
bool swtimer_isTriggered(swtimer_id_t a_e8Id)
{
    9c4c:	5801      	inc	S, #2

00009c4e <.LCFI2>:
    bool lb_trigged = false;

    if (g_pTimer[a_e8Id].bTriggered != 0u)
    9c4e:	44a2      	asl	A, #2

00009c50 <.LVL31>:
    9c50:	5201      	mov	[S-2], A
    9c52:	7ee2      	lod	X, A
    9c54:	22da 1415 	add	X, #5141
    9c58:	66f8      	lod	YL, [X]
    9c5a:	62e8      	lod	AL, YL
    9c5c:	4440      	rl	AL
    9c5e:	9401      	and	AL, #1
    9c60:	5cf2      	usex	A
    9c62:	7ee2      	lod	X, A
    9c64:	62e8      	lod	AL, YL
    9c66:	1d88      	jnn	0x9c78 <.L16>

00009c68 <.LM52>:
    {
        g_pTimer[a_e8Id].bTriggered = 0u;
    9c68:	7e01      	lod	X, [S-2]
    9c6a:	22da 1415 	add	X, #5141
    9c6e:	62e8      	lod	AL, YL
    9c70:	947f      	and	AL, #127
    9c72:	42f8      	mov	[X], AL

00009c74 <.LM53>:
        lb_trigged = true;
    9c74:	7001      	lod	A, #1
    9c76:	5403      	ret	#4

00009c78 <.L16>:
 * @param[in]  a_e8Id  Timer id
 * @return  true  if expired
 */
bool swtimer_isTriggered(swtimer_id_t a_e8Id)
{
    bool lb_trigged = false;
    9c78:	72ee      	lod	A, X

00009c7a <.LM55>:
        g_pTimer[a_e8Id].bTriggered = 0u;
        lb_trigged = true;
    }

    return (lb_trigged);
}
    9c7a:	5403      	ret	#4

00009c7c <_swtimer_enterIrq>:
/* ---------------------------------------------
 * Weak, default function implementation
 * --------------------------------------------- */

WEAK void swtimer_enterIrq(void)
{}
    9c7c:	5401      	ret

00009c7e <_swtimer_exitIrq>:
    9c7e:	5401      	ret

00009c80 <_swtimer_triggerIrq>:
{}

WEAK void swtimer_triggerIrq(uint16_t id)
{
    (void)id;
}
    9c80:	5401      	ret

00009c82 <__STIMER_INT>:

/**
 * The core timer interrupt service routine.
 */
INTERRUPT void _STIMER_INT(void)
{
    9c82:	5edf      	push	X

00009c84 <.LCFI3>:
    9c84:	5adf      	push	Y

00009c86 <.LCFI4>:
    9c86:	52df      	push	A

00009c88 <.LCFI5>:
    9c88:	4c83      	push	D

00009c8a <.LCFI6>:
    9c8a:	5807      	inc	S, #8

00009c8c <.LCFI7>:
    swtimer_enterIrq();
    9c8c:	17f7      	call	0x9c7c <_swtimer_enterIrq>

00009c8e <.LBB225>:

    /* Count-down all the registered SW timers, trigger when 0 is reached */
    for (uint16_t index = 0u; index < (uint16_t)SWTIMER_NR_OF; index++)
    9c8e:	7000      	lod	A, #0
    9c90:	5205      	mov	[S-6], A

00009c92 <.L23>:
    {
        uint16_t value = g_pTimer[index].u15Current;
    9c92:	7205      	lod	A, [S-6]
    9c94:	44a2      	asl	A, #2
    9c96:	5201      	mov	[S-2], A
    9c98:	7ee2      	lod	X, A
    9c9a:	22da 1414 	add	X, #5140
    9c9e:	7ef8      	lod	X, [X]

00009ca0 <.LM64>:

        if (value != 0u)
    9ca0:	72ee      	lod	A, X
    9ca2:	d47f      	and	AH, #127
    9ca4:	ac00      	cmp	A, #0
    9ca6:	1926      	je	0x9cf4 <.L21>
    9ca8:	72ee      	lod	A, X
    9caa:	b6da 7fff 	and	A, #32767

00009cae <.LM65>:
        {
            value--;

            if (value == 0u)
    9cae:	7ae2      	lod	Y, A
    9cb0:	e0ff      	add	Y, #-1

00009cb2 <.LVL40>:
    9cb2:	5a07      	mov	[S-8], Y
    9cb4:	ac01      	cmp	A, #1
    9cb6:	1d12      	jne	0x9cdc <.L22>

00009cb8 <.LM66>:
            {
                /* Trigger state */
                g_pTimer[index].bTriggered = 1u;
    9cb8:	7a01      	lod	Y, [S-2]

00009cba <.LVL41>:
    9cba:	e2da 1412 	add	Y, #5138
    9cbe:	7ee6      	lod	X, Y
    9cc0:	2003      	add	X, #3
    9cc2:	62f8      	lod	AL, [X]
    9cc4:	8480      	or	AL, #-128
    9cc6:	42f8      	mov	[X], AL

00009cc8 <.LM67>:

                /* Callback event */
                swtimer_triggerIrq(index);
    9cc8:	7205      	lod	A, [S-6]
    9cca:	5a03      	mov	[S-4], Y
    9ccc:	17d9      	call	0x9c80 <_swtimer_triggerIrq>

00009cce <.LM68>:

                if (g_pTimer[index].bRepetitive != 0u)
    9cce:	7a03      	lod	Y, [S-4]
    9cd0:	62f1      	lod	AL, [Y+1]
    9cd2:	1d84      	jnn	0x9cdc <.L22>

00009cd4 <.LM69>:
                {
                    /* Reload periodic timers */
                    value = g_pTimer[index].u15Load;
    9cd4:	72f0      	lod	A, [Y]
    9cd6:	b6da 7fff 	and	A, #32767
    9cda:	5207      	mov	[S-8], A

00009cdc <.L22>:
                }
            }

            g_pTimer[index].u15Current = value;
    9cdc:	7205      	lod	A, [S-6]
    9cde:	44a2      	asl	A, #2
    9ce0:	7ae2      	lod	Y, A
    9ce2:	e2da 1412 	add	Y, #5138
    9ce6:	7207      	lod	A, [S-8]
    9ce8:	d47f      	and	AH, #127
    9cea:	7ef2      	lod	X, [Y+2]
    9cec:	36da 8000 	and	X, #32768
    9cf0:	26e2      	or	X, A
    9cf2:	5ef2      	mov	[Y+2], X

00009cf4 <.L21>:
INTERRUPT void _STIMER_INT(void)
{
    swtimer_enterIrq();

    /* Count-down all the registered SW timers, trigger when 0 is reached */
    for (uint16_t index = 0u; index < (uint16_t)SWTIMER_NR_OF; index++)
    9cf4:	7205      	lod	A, [S-6]
    9cf6:	a001      	add	A, #1

00009cf8 <.LVL46>:
    9cf8:	5205      	mov	[S-6], A
    9cfa:	ac07      	cmp	A, #7
    9cfc:	1d4a      	jne	0x9c92 <.L23>

00009cfe <.LBE225>:

            g_pTimer[index].u15Current = value;
        }
    }

    swtimer_exitIrq();
    9cfe:	17bf      	call	0x9c7e <_swtimer_exitIrq>

00009d00 <.LM73>:
}
    9d00:	5c07      	dec	S, #8

00009d02 <.LVL48>:
    9d02:	4cc3      	pop	D

00009d04 <.LCFI8>:
    9d04:	72cf      	pop	A

00009d06 <.LCFI9>:
    9d06:	7acf      	pop	Y

00009d08 <.LCFI10>:
    9d08:	7ecf      	pop	X

00009d0a <.LCFI11>:
    9d0a:	72cb      	pop	M
    9d0c:	5401      	ret

00009d0e <__CTIMER0_3_INT>:
#include <ctimerlib.h>
#include "defines.h"

/** Timer1 INT3 handler for LIN AA frame timeout */
INTERRUPT void _CTIMER0_3_INT(void)
{
    9d0e:	5edf      	push	X

00009d10 <.LCFI0>:
    9d10:	5adf      	push	Y

00009d12 <.LCFI1>:
    9d12:	52df      	push	A

00009d14 <.LCFI2>:
    9d14:	4c83      	push	D

00009d16 <.LCFI3>:
	system_timer_ISR();
    9d16:	14d0      	call	0x96b8 <_system_timer_ISR>

00009d18 <.LM3>:
}
    9d18:	4cc3      	pop	D

00009d1a <.LCFI4>:
    9d1a:	72cf      	pop	A

00009d1c <.LCFI5>:
    9d1c:	7acf      	pop	Y

00009d1e <.LCFI6>:
    9d1e:	7ecf      	pop	X

00009d20 <.LCFI7>:
    9d20:	72cb      	pop	M
    9d22:	5401      	ret

00009d24 <_ctimer0_init>:
#include <stdint.h>
#include "io.h"

STATIC INLINE void CTimer0_AutoloadInit(CTimer_Clockdivider_t divider, uint16_t cmpb)
{
    IO_SET(CTIMER0, TREGB, cmpb);
    9d24:	52d8 0118 	mov	0x118 <_CTIMER0>, A

00009d28 <.LM6>:
    IO_SET(CTIMER0, DIV, (uint16_t)divider, MODE, (uint16_t)eTimerModeTimer);
    9d28:	62d8 011f 	lod	AL, 0x11f <.LASF2011+0x1>

00009d2c <.LVL2>:
    9d2c:	9407      	and	AL, #7
    9d2e:	8440      	or	AL, #64
    9d30:	42d8 011f 	mov	0x11f <.LASF2011+0x1>, AL

00009d34 <.LM7>:
    IO_SET(CTIMER0, START, 1u);
    9d34:	62d8 011e 	lod	AL, 0x11e <.LASF2011>
    9d38:	94fc      	and	AL, #-4
    9d3a:	8401      	or	AL, #1
    9d3c:	42d8 011e 	mov	0x11e <.LASF2011>, AL

00009d40 <.LBB149>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    9d40:	7ee3      	lod	X, M

00009d42 <.LBB152>:
    return 1;
}

STATIC INLINE uint16_t mlx16_di_enter_system_mode(void)
{
    __asm__ __volatile__ (".word OPCODE_CALL_FP_ENTER_SYSTEM_MODE_PRIO_0");
    9d42:	5049      	call	fp2:0x48

00009d44 <.LBB154>:
    IO_SET(MLX16, CTIMER0_2_ITC, 1u);
}

STATIC INLINE void CTimer0_Int3_Enable(void)
{
    IO_SET(MLX16, CTIMER0_3_PEND, 1u);
    9d44:	6080      	lod	AL, #-128
    9d46:	42d8 0052 	mov	0x52 <.LASF1528+0x5>, AL

00009d4a <.LM11>:
    IO_SET(MLX16, CTIMER0_3_ITC, 1u);
    9d4a:	62d8 006e 	lod	AL, 0x6e <__mlx4_cst_tables_ram_size+0x10>
    9d4e:	8480      	or	AL, #-128
    9d50:	42d8 006e 	mov	0x6e <__mlx4_cst_tables_ram_size+0x10>, AL

00009d54 <.LBB156>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    9d54:	5ee3      	mov	M, X

00009d56 <.LBE149>:
{
	CTimer0_AutoloadInit(eTimerCPUClockDivisionBy16, period);
	ENTER_SECTION(ATOMIC_SYSTEM_MODE);
	CTimer0_Int3_Enable();
	EXIT_SECTION();
}
    9d56:	5401      	ret

00009d58 <_ctimer0_start>:
#endif /* CTIMER1 */


STATIC INLINE void CTimer0_Start(void)
{
    IO_SET(CTIMER0, START, 1u);
    9d58:	62d8 011e 	lod	AL, 0x11e <.LASF2011>
    9d5c:	94fc      	and	AL, #-4
    9d5e:	8401      	or	AL, #1
    9d60:	42d8 011e 	mov	0x11e <.LASF2011>, AL

00009d64 <.LBE160>:

void ctimer0_start(void)
{
	CTimer0_Start();
}
    9d64:	5401      	ret

00009d66 <_uart_Start>:



STATIC INLINE void UART_RxEnable(void)
{
    IO_SET(UART, REE, 1u);
    9d66:	72d8 0256 	lod	A, 0x256 <.LASF1355+0x2>
    9d6a:	8404      	or	AL, #4
    9d6c:	52d8 0256 	mov	0x256 <.LASF1355+0x2>, A

00009d70 <.LBB677>:
/*********************** Function from lm_uart, Mulan2/3 ******************************************/


STATIC INLINE void UART_TxEnable(void)
{
    IO_SET(UART, TRE, 1u);
    9d70:	72d8 0256 	lod	A, 0x256 <.LASF1355+0x2>
    9d74:	8402      	or	AL, #2
    9d76:	52d8 0256 	mov	0x256 <.LASF1355+0x2>, A

00009d7a <.LBE677>:
STATIC void uart_Start(void)
{
#ifndef HAS_TWO_UARTS
    UART_RxEnable();
    UART_TxEnable();
    IO_SET(PORT_UDMA_CTRL, UDMA_TXSTART, 1, UDMA_EN, 1);  /* Enable & Start UART DMA */
    9d7a:	62d8 024c 	lod	AL, 0x24c <_PORT_UDMA_CTRL>
    9d7e:	8403      	or	AL, #3
    9d80:	42d8 024c 	mov	0x24c <_PORT_UDMA_CTRL>, AL

00009d84 <.LM5>:
#else
    UART0_RxEnable();
    UART0_TxEnable();
    IO_SET(PORT_UDMA0_CTRL, UDMA0_TXSTART, 1, UDMA0_EN, 1);  /* Enable & Start UART DMA */
#endif
}
    9d84:	5401      	ret

00009d86 <_uart_Stop>:



STATIC INLINE void UART_RxDisable(void)
{
    IO_SET(UART, REE, 0u);
    9d86:	72d8 0256 	lod	A, 0x256 <.LASF1355+0x2>
    9d8a:	94fb      	and	AL, #-5
    9d8c:	52d8 0256 	mov	0x256 <.LASF1355+0x2>, A

00009d90 <.LBB681>:



STATIC INLINE void UART_TxDisable(void)
{
    IO_SET(UART, TRE, 0u);
    9d90:	72d8 0256 	lod	A, 0x256 <.LASF1355+0x2>
    9d94:	94fd      	and	AL, #-3
    9d96:	52d8 0256 	mov	0x256 <.LASF1355+0x2>, A

00009d9a <.LBE681>:
    UART_TxDisable();
#else
    UART0_RxDisable();
    UART0_TxDisable();
#endif
}
    9d9a:	5401      	ret

00009d9c <__UDFR_INT>:
#ifndef HAS_TWO_UARTS
INTERRUPT void _UDFR_INT(void)
#else
INTERRUPT void _UDFR0_INT(void)
#endif
{
    9d9c:	5edf      	push	X

00009d9e <.LCFI4>:
    9d9e:	5adf      	push	Y

00009da0 <.LCFI5>:
    9da0:	52df      	push	A

00009da2 <.LCFI6>:
    9da2:	4c83      	push	D

00009da4 <.LCFI7>:
    9da4:	5807      	inc	S, #8

00009da6 <.LCFI8>:
    uint8_t * pu8UartRxBuf;

#ifndef HAS_TWO_UARTS
    if (IO_GET(PORT_UDMA_STATUS, UDMA_RD_BUFFER_VALID) == 0u)
    9da6:	72d8 025a 	lod	A, 0x25a <_PORT_UDMA_STATUS>
    9daa:	9401      	and	AL, #1
    9dac:	1901      	je	0x9db0 <.LM73>
    9dae:	0046      	jmp	0x9e3c <.L13>

00009db0 <.LM73>:
#else
    if (IO_GET(PORT_UDMA0_STATUS, UDMA0_RD_BUFFER_VALID) == 0u)
#endif
    {
        pu8UartRxBuf = (uint8_t *)&l_au8UartRdBufB;
    9db0:	7eda 11cc 	lod	X, #4556

00009db4 <.L23>:
    }
    else
    {
        pu8UartRxBuf = (uint8_t *)&l_au8UartRdBufA;
    9db4:	62f8      	lod	AL, [X]

00009db6 <.LM75>:
    }

    if ((pu8UartRxBuf[0] == C_SERIAL_PLOT_HEADER_BYTE0))
    9db6:	8caa      	cmp	AL, #-86
    9db8:	1901      	je	0x9dbc <.LASF1179+0x1>
    9dba:	0046      	jmp	0x9e48 <.L15>
    9dbc:	7aee      	lod	Y, X
    9dbe:	e001      	add	Y, #1
    9dc0:	2009      	add	X, #9
    9dc2:	5e07      	mov	[S-8], X
    9dc4:	5a05      	mov	[S-6], Y

00009dc6 <.LBB1061>:
    {
        uint8_t checksum = 0u;
    9dc6:	7000      	lod	A, #0
    9dc8:	5203      	mov	[S-4], A
    9dca:	7c08      	lod	X, #8
    9dcc:	5e01      	mov	[S-2], X

00009dce <.L16>:
        for (uint8_t index = 0u; index < C_UART_PLOT_DATA_LENGTH; index++)
        {
            checksum += pu8UartRxBuf[1u + index];
    9dce:	7e05      	lod	X, [S-6]
    9dd0:	62de      	lod	AL, [X++]
    9dd2:	5e05      	mov	[S-6], X
    9dd4:	8203      	add	AL, [S-4]
    9dd6:	5cf2      	usex	A
    9dd8:	5203      	mov	[S-4], A

00009dda <.LM78>:
    }

    if ((pu8UartRxBuf[0] == C_SERIAL_PLOT_HEADER_BYTE0))
    {
        uint8_t checksum = 0u;
        for (uint8_t index = 0u; index < C_UART_PLOT_DATA_LENGTH; index++)
    9dda:	7201      	lod	A, [S-2]
    9ddc:	a0ff      	add	A, #-1
    9dde:	5201      	mov	[S-2], A
    9de0:	1d76      	jne	0x9dce <.L16>

00009de2 <.LBE1062>:
        {
            checksum += pu8UartRxBuf[1u + index];
        }

        if (checksum == pu8UartRxBuf[C_UART_PLOT_CRC_POS])
    9de2:	7e07      	lod	X, [S-8]
    9de4:	62f8      	lod	AL, [X]
    9de6:	5cf2      	usex	A
    9de8:	ae03      	cmp	A, [S-4]
    9dea:	1d21      	jne	0x9e2e <.L12>
    9dec:	7001      	lod	A, #1
    9dee:	5205      	mov	[S-6], A
    9df0:	7c04      	lod	X, #4
    9df2:	5e03      	mov	[S-4], X

00009df4 <.L20>:
        {
            for (uint8_t index = 0u; index < C_UART_PLOT_DATA_LENGTH / 2; index++)
            {
                uint16_t addr = (pu8UartRxBuf[1u + (index * 2u) + 1u] << 8) | pu8UartRxBuf[1u + (index * 2u)];
    9df4:	6af1      	lod	AH, [Y+1]
    9df6:	62f0      	lod	AL, [Y]
    9df8:	5207      	mov	[S-8], A

00009dfa <.LVL33>:
    9dfa:	7205      	lod	A, [S-6]

00009dfc <.LVL34>:
    9dfc:	4422      	asl	A
    9dfe:	7ee2      	lod	X, A

00009e00 <.LM81>:
                if (addr != 0)
    9e00:	7207      	lod	A, [S-8]

00009e02 <.LM82>:
                {
                    l_u16Payload[index] = addr;
    9e02:	22da 11c2 	add	X, #4546

00009e06 <.LM83>:
        if (checksum == pu8UartRxBuf[C_UART_PLOT_CRC_POS])
        {
            for (uint8_t index = 0u; index < C_UART_PLOT_DATA_LENGTH / 2; index++)
            {
                uint16_t addr = (pu8UartRxBuf[1u + (index * 2u) + 1u] << 8) | pu8UartRxBuf[1u + (index * 2u)];
                if (addr != 0)
    9e06:	ac00      	cmp	A, #0
    9e08:	191c      	je	0x9e42 <.L18>

00009e0a <.L24>:
                {
                    l_u16Payload[index] = addr;
                }
                else
                {
                    l_u16Payload[index] = (uint16_t)&l_uart_plot_dummy;
    9e0a:	52f8      	mov	[X], A

00009e0c <.LVL35>:
    9e0c:	7205      	lod	A, [S-6]
    9e0e:	a001      	add	A, #1
    9e10:	5205      	mov	[S-6], A

00009e12 <.LVL36>:
    9e12:	e002      	add	Y, #2

00009e14 <.LBE1064>:
            checksum += pu8UartRxBuf[1u + index];
        }

        if (checksum == pu8UartRxBuf[C_UART_PLOT_CRC_POS])
        {
            for (uint8_t index = 0u; index < C_UART_PLOT_DATA_LENGTH / 2; index++)
    9e14:	7e03      	lod	X, [S-4]
    9e16:	20ff      	add	X, #-1
    9e18:	5e03      	mov	[S-4], X
    9e1a:	1d6c      	jne	0x9df4 <.L20>

00009e1c <.LBE1063>:
            }

            l_bCommandReady = true;
            if (l_bCommandReady)
            {
                memcpy(g_u16TxAddress, l_u16Payload, C_UART_PLOT_DATA_LENGTH);
    9e1c:	7eda 1012 	lod	X, #4114
    9e20:	7ada 11c4 	lod	Y, #4548
    9e24:	0ea7      	lod	C, ML.7
    9e26:	54c6      	movsw	[X++], [Y++]
    9e28:	54c6      	movsw	[X++], [Y++]
    9e2a:	54c6      	movsw	[X++], [Y++]
    9e2c:	54c6      	movsw	[X++], [Y++]

00009e2e <.L12>:
    {
        /* we lost synchronization, repair */
        uart_Stop();
        uart_Start();
    }
}
    9e2e:	5c07      	dec	S, #8
    9e30:	4cc3      	pop	D

00009e32 <.LCFI9>:
    9e32:	72cf      	pop	A

00009e34 <.LCFI10>:
    9e34:	7acf      	pop	Y

00009e36 <.LCFI11>:
    9e36:	7ecf      	pop	X

00009e38 <.LCFI12>:
    9e38:	72cb      	pop	M
    9e3a:	5401      	ret

00009e3c <.L13>:
    {
        pu8UartRxBuf = (uint8_t *)&l_au8UartRdBufB;
    }
    else
    {
        pu8UartRxBuf = (uint8_t *)&l_au8UartRdBufA;
    9e3c:	7eda 11d6 	lod	X, #4566
    9e40:	07b9      	jmp	0x9db4 <.L23>

00009e42 <.L18>:
                {
                    l_u16Payload[index] = addr;
                }
                else
                {
                    l_u16Payload[index] = (uint16_t)&l_uart_plot_dummy;
    9e42:	72da 10a8 	lod	A, #4264

00009e46 <.LVL40>:
    9e46:	07e1      	jmp	0x9e0a <.L24>

00009e48 <.L15>:
        }
    }
    else
    {
        /* we lost synchronization, repair */
        uart_Stop();
    9e48:	179e      	call	0x9d86 <_uart_Stop>

00009e4a <.LM91>:
        uart_Start();
    9e4a:	178d      	call	0x9d66 <_uart_Start>

00009e4c <.LM92>:
    }
}
    9e4c:	07f0      	jmp	0x9e2e <.L12>

00009e4e <__updateCRC8>:
/**
 * @brief Calculate and update CRC8 on one page
 * @param[in]  config  page data
 */
static void _updateCRC8(page_t * config)
{
    9e4e:	5801      	inc	S, #2

00009e50 <.LCFI0>:
    9e50:	7ae2      	lod	Y, A

00009e52 <.LM2>:
    uint16_t u16CRC;

    config->crc8 = (uint16_t)0x00;
    9e52:	6000      	lod	AL, #0

00009e54 <.LVL1>:
    9e54:	42f0      	mov	[Y], AL

00009e56 <.LM3>:

    u16CRC = nvram_CalcCRC((void *)config, sizeof(page_t) / sizeof(uint16_t));
    9e56:	54ca 0004 	pushw	#4

00009e5a <.LCFI1>:
    9e5a:	72e6      	lod	A, Y
    9e5c:	5a03      	mov	[S-4], Y
    9e5e:	82db 1511 	callf	0x2a22 <_nvram_CalcCRC>

00009e62 <.LM4>:

    config->crc8 = (uint16_t)(0xFFU - u16CRC);
    9e62:	bcff      	xor	A, #-1

00009e64 <.LVL3>:
    9e64:	7a03      	lod	Y, [S-4]
    9e66:	42f0      	mov	[Y], AL

00009e68 <.LCFI2>:
}
    9e68:	5405      	ret	#6

00009e6a <_unirom_Init>:
/* ---------------------------------------------
 * Public Functions Implementation
 * --------------------------------------------- */

void unirom_Init(void)
{}
    9e6a:	5401      	ret

00009e6c <_unirom_LoadUserConfig>:

bool unirom_LoadUserConfig(void)
{
    9e6c:	5809      	inc	S, #10

00009e6e <.LCFI3>:
    9e6e:	7ada 0840 	lod	Y, #2112
    9e72:	5a03      	mov	[S-4], Y

00009e74 <.LM10>:
    bool retVal = true;
    9e74:	7001      	lod	A, #1
    9e76:	5207      	mov	[S-8], A

00009e78 <.L6>:
}

#ifndef UNITTEST
STATIC INLINE void EEPROM_ClearErrorFlags(void)
{
    IO_SET(EEPROM_FLASH,
    9e78:	600f      	lod	AL, #15
    9e7a:	42d8 0188 	mov	0x188 <.LASF1351+0x7>, AL

00009e7e <.LVL6>:
    9e7e:	7a03      	lod	Y, [S-4]
    9e80:	e2da 09a0 	add	Y, #2464
    9e84:	5a01      	mov	[S-2], Y

00009e86 <.LBE92>:
        EEPROM_ClearErrorFlags();

        uint16_t eeprom_address = NV_ADDR_PATTERN + (page * sizeof(page_t) / sizeof(uint8_t));

        /* copy one page from EEPROM to RAM */
        memcpy((void*)&l_ramCopy.page[page], (void*)eeprom_address, sizeof(page_t) / sizeof(uint8_t));
    9e86:	5a09      	mov	[S-10], Y
    9e88:	7203      	lod	A, [S-4]
    9e8a:	7ee6      	lod	X, Y
    9e8c:	7ae2      	lod	Y, A
    9e8e:	54e8      	mov	Cx, #8
    9e90:	54c4      	movsb	[X++], [Y++]
    9e92:	1ffe      	djnz	Cx, 0x9e90 <.LASF1192+0x5>

00009e94 <.LBB94>:
}
#endif /* UNITTEST */

STATIC INLINE bool EEPROM_GetErrorFlags(void)
{
    return (IO_GET(EEPROM_FLASH, EE_DATA_CORRUPTED_1) != 0u) || (IO_GET(EEPROM_FLASH, EE_DATA_CORRUPTED_2) != 0u);
    9e94:	72d8 0188 	lod	A, 0x188 <.LASF1351+0x7>
    9e98:	9402      	and	AL, #2
    9e9a:	1d0d      	jne	0x9eb6 <.L4>
    9e9c:	72d8 0188 	lod	A, 0x188 <.LASF1351+0x7>

00009ea0 <.LBE94>:

        if (EEPROM_GetErrorFlags())
    9ea0:	9408      	and	AL, #8
    9ea2:	1d09      	jne	0x9eb6 <.L4>

00009ea4 <.LM15>:
        {
            retVal = false;  /* ECC error */
        }
        else
        {
            if (nvram_CalcCRC((void *)&l_ramCopy.page[page], sizeof(page_t) / sizeof(uint16_t)) != 0xFF)
    9ea4:	54ca 0004 	pushw	#4

00009ea8 <.LCFI4>:
    9ea8:	7203      	lod	A, [S-4]
    9eaa:	82db 1511 	callf	0x2a22 <_nvram_CalcCRC>
    9eae:	5c01      	dec	S, #2

00009eb0 <.LCFI5>:
    9eb0:	aeda 00ff 	cmp	A, #255
    9eb4:	1902      	je	0x9eba <.L5>

00009eb6 <.L4>:
            {
                retVal = false;  /* CRC error */
    9eb6:	7000      	lod	A, #0
    9eb8:	5207      	mov	[S-8], A

00009eba <.L5>:

bool unirom_LoadUserConfig(void)
{
    bool retVal = true;

    for (uint8_t page = 0; page < sizeof(user_pattern_t) / sizeof(page_t); page++)
    9eba:	7a03      	lod	Y, [S-4]
    9ebc:	e008      	add	Y, #8
    9ebe:	5a03      	mov	[S-4], Y
    9ec0:	eeda 0858 	cmp	Y, #2136
    9ec4:	1d59      	jne	0x9e78 <.L6>

00009ec6 <.LBE90>:
            }
        }
    }

    return retVal;
}
    9ec6:	7207      	lod	A, [S-8]
    9ec8:	540b      	ret	#12

00009eca <_unirom_StoreUserConfig>:
    /* store RAM to eeprom */
    return unirom_StoreUserConfig();
}

bool unirom_StoreUserConfig(void)
{
    9eca:	5809      	inc	S, #10

00009ecc <.LCFI6>:
    9ecc:	7ada 0840 	lod	Y, #2112
    9ed0:	5a01      	mov	[S-2], Y

00009ed2 <.L15>:
    9ed2:	7a01      	lod	Y, [S-2]
    9ed4:	e2da 09a0 	add	Y, #2464
    9ed8:	5a03      	mov	[S-4], Y

00009eda <.LBB131>:
 * @param[in]  address  page data in EEPROM
 * @retval  true  in case of success
 */
static bool _pageVerify(page_t * config, uint16_t * address)
{
    return (memcmp((void *)config, (void *)address, sizeof(page_t) / sizeof(uint8_t)) == 0);
    9eda:	5a07      	mov	[S-8], Y
    9edc:	7e01      	lod	X, [S-2]
    9ede:	5e09      	mov	[S-10], X
    9ee0:	7ee6      	lod	X, Y
    9ee2:	7a09      	lod	Y, [S-10]

00009ee4 <.LVL15>:
    9ee4:	7000      	lod	A, #0
    9ee6:	54e8      	mov	Cx, #8
    9ee8:	6ade      	lod	AH, [X++]
    9eea:	cad6      	sub	AH, [Y++]
    9eec:	1d02      	jne	0x9ef2 <.L18>
    9eee:	1ffc      	djnz	Cx, 0x9ee8 <.LVL15+0x4>
    9ef0:	0001      	jmp	0x9ef4 <.L19>

00009ef2 <.L18>:
    9ef2:	4412      	rrc	A

00009ef4 <.L19>:
    for (uint8_t page = 0u; page < sizeof(user_pattern_t) / sizeof(page_t); page++)
    {
        uint16_t eeprom_address = NV_ADDR_PATTERN + (page * sizeof(page_t) / sizeof(uint8_t));

        /* Check if EEPROM and RAM copy are not the same */
        if (!_pageVerify(&l_ramCopy.page[page], (uint16_t *)eeprom_address))
    9ef4:	ac00      	cmp	A, #0
    9ef6:	190f      	je	0x9f16 <.L13>

00009ef8 <.LBB135>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    9ef8:	7ae3      	lod	Y, M

00009efa <.LBB138>:
    9efa:	5049      	call	fp2:0x48

00009efc <.LBE138>:
        {
            /* write to eeprom page */
            ENTER_SECTION(ATOMIC_SYSTEM_MODE);
            EEPROM_WriteWord64_blocking(eeprom_address, (void *)&l_ramCopy.page[page], EE_WRITE_KEY);
    9efc:	54ca 0007 	pushw	#7

00009f00 <.LCFI7>:
    9f00:	7e05      	lod	X, [S-6]
    9f02:	5edf      	push	X

00009f04 <.LCFI8>:
    9f04:	7205      	lod	A, [S-6]
    9f06:	5a09      	mov	[S-10], Y
    9f08:	111e      	call	0xa146 <_EEPROM_WriteWord64_blocking>

00009f0a <.LBB140>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    9f0a:	7a09      	lod	Y, [S-10]
    9f0c:	5ae3      	mov	M, Y

00009f0e <.LBB144>:
    9f0e:	0f7f      	lod	C, io:0x0f.7

00009f10 <.LBE146>:
}

/** WDG_conditionalAwdRefresh acknowledges the AWD timer if its window is opened */
STATIC INLINE void WDG_conditionalAwdRefresh(void)
{
    if (IO_GET(AWD, WIN_OPEN) != 0u) {
    9f10:	5c03      	dec	S, #4

00009f12 <.LCFI9>:
    9f12:	1c01      	jnc	0x9f16 <.L13>

00009f14 <.LM29>:
        IO_SET(AWD, ACK, 1u);
    9f14:	0b76      	setb	io:0x0e.6

00009f16 <.L13>:
    return unirom_StoreUserConfig();
}

bool unirom_StoreUserConfig(void)
{
    for (uint8_t page = 0u; page < sizeof(user_pattern_t) / sizeof(page_t); page++)
    9f16:	7a01      	lod	Y, [S-2]
    9f18:	e008      	add	Y, #8
    9f1a:	5a01      	mov	[S-2], Y
    9f1c:	eeda 0858 	cmp	Y, #2136
    9f20:	1d58      	jne	0x9ed2 <.L15>

00009f22 <.LBE131>:
            WDG_conditionalAwdRefresh();  /* Restart watchdog */
        }
    }

    return true;
}
    9f22:	7001      	lod	A, #1
    9f24:	540b      	ret	#12

00009f26 <_unirom_ResetUserConfig>:

    return retVal;
}

bool unirom_ResetUserConfig(const user_pattern_t * def_config)
{
    9f26:	5801      	inc	S, #2

00009f28 <.LCFI10>:
    /* restore ram copy  */
    memcpy((void*)&l_ramCopy, (void*)def_config, sizeof(user_pattern_t) / sizeof(uint8_t));
    9f28:	7ada 11e0 	lod	Y, #4576
    9f2c:	5a01      	mov	[S-2], Y
    9f2e:	7ee2      	lod	X, A
    9f30:	a018      	add	A, #24

00009f32 <.LVL25>:
    9f32:	0ea7      	lod	C, ML.7

00009f34 <.L21>:
    9f34:	54cc      	movsb	[Y++], [X++]
    9f36:	2ee2      	cmp	X, A
    9f38:	1d7d      	jne	0x9f34 <.L21>

00009f3a <.LBB148>:

    /* restore CRC8 of all pages */
    for (uint8_t page = 0u; page < sizeof(user_pattern_t) / sizeof(page_t); page++)
    {
        _updateCRC8(&l_ramCopy.page[page]);
    9f3a:	72da 11e0 	lod	A, #4576
    9f3e:	1787      	call	0x9e4e <__updateCRC8>
    9f40:	72da 11e8 	lod	A, #4584
    9f44:	1784      	call	0x9e4e <__updateCRC8>
    9f46:	72da 11f0 	lod	A, #4592
    9f4a:	1781      	call	0x9e4e <__updateCRC8>

00009f4c <.LBE148>:
    }

    /* store RAM to eeprom */
    return unirom_StoreUserConfig();
    9f4c:	17be      	call	0x9eca <_unirom_StoreUserConfig>

00009f4e <.LM36>:
}
    9f4e:	5403      	ret	#4

00009f50 <_unirom_StorePage>:

    return true;
}

bool unirom_StorePage(uint8_t page)
{
    9f50:	5807      	inc	S, #8

00009f52 <.LCFI11>:
    uint16_t eeprom_address = NV_ADDR_PATTERN + (page * sizeof(page_t) / sizeof(uint8_t));
    9f52:	a2da 0108 	add	A, #264

00009f56 <.LVL32>:
    9f56:	44a2      	asl	A, #2
    9f58:	4422      	asl	A
    9f5a:	5205      	mov	[S-6], A

00009f5c <.LM39>:

    /* Check if EEPROM and RAM copy are not the same */
    if (!_pageVerify(&l_ramCopy.page[page], (uint16_t *)eeprom_address))
    9f5c:	a2da 09a0 	add	A, #2464

00009f60 <.LVL34>:
    9f60:	5201      	mov	[S-2], A

00009f62 <.LBB160>:
 * @param[in]  address  page data in EEPROM
 * @retval  true  in case of success
 */
static bool _pageVerify(page_t * config, uint16_t * address)
{
    return (memcmp((void *)config, (void *)address, sizeof(page_t) / sizeof(uint8_t)) == 0);
    9f62:	5207      	mov	[S-8], A
    9f64:	7a05      	lod	Y, [S-6]
    9f66:	7ee2      	lod	X, A
    9f68:	7000      	lod	A, #0
    9f6a:	54e8      	mov	Cx, #8
    9f6c:	6ade      	lod	AH, [X++]
    9f6e:	cad6      	sub	AH, [Y++]
    9f70:	1d02      	jne	0x9f76 <.L28>
    9f72:	1ffc      	djnz	Cx, 0x9f6c <.LASF1559+0x2>
    9f74:	0001      	jmp	0x9f78 <.L29>

00009f76 <.L28>:
    9f76:	4412      	rrc	A

00009f78 <.L29>:
bool unirom_StorePage(uint8_t page)
{
    uint16_t eeprom_address = NV_ADDR_PATTERN + (page * sizeof(page_t) / sizeof(uint8_t));

    /* Check if EEPROM and RAM copy are not the same */
    if (!_pageVerify(&l_ramCopy.page[page], (uint16_t *)eeprom_address))
    9f78:	ac00      	cmp	A, #0
    9f7a:	190c      	je	0x9f94 <.L23>

00009f7c <.LBB162>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    9f7c:	7ae3      	lod	Y, M

00009f7e <.LBB165>:
    9f7e:	5049      	call	fp2:0x48

00009f80 <.LBE165>:
    {
        /* write to eeprom page */
        ENTER_SECTION(ATOMIC_SYSTEM_MODE);
        EEPROM_WriteWord64_blocking(eeprom_address, (void*)&l_ramCopy.page[page], EE_WRITE_KEY);
    9f80:	54ca 0007 	pushw	#7

00009f84 <.LCFI12>:
    9f84:	7e03      	lod	X, [S-4]
    9f86:	5edf      	push	X

00009f88 <.LCFI13>:
    9f88:	7209      	lod	A, [S-10]
    9f8a:	5a07      	mov	[S-8], Y
    9f8c:	10dc      	call	0xa146 <_EEPROM_WriteWord64_blocking>

00009f8e <.LBB167>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    9f8e:	7a07      	lod	Y, [S-8]
    9f90:	5ae3      	mov	M, Y

00009f92 <.LVL39>:
    9f92:	5c03      	dec	S, #4

00009f94 <.L23>:
        EXIT_SECTION();
    }

    return true;
}
    9f94:	7001      	lod	A, #1
    9f96:	5409      	ret	#10

00009f98 <_unirom_WritePage>:
    }
    return retVal;
}

bool unirom_WritePage(uint8_t page, uint8_t* data, uint8_t len)
{
    9f98:	5809      	inc	S, #10

00009f9a <.LCFI19>:
    9f9a:	660f      	lod	YL, [S-16]
    9f9c:	5cf6      	usex	Y
    9f9e:	5a01      	mov	[S-2], Y

00009fa0 <.LM63>:
    bool retVal = false;

    if (len <= 7u)
    9fa0:	ec07      	cmp	Y, #7
    9fa2:	1a01      	jule	0x9fa6 <.LASF1250+0x3>
    9fa4:	0031      	jmp	0xa008 <.L42>
    9fa6:	44a2      	asl	A, #2
    9fa8:	4422      	asl	A

00009faa <.LVL55>:
    9faa:	5209      	mov	[S-10], A

00009fac <.LM64>:
    {
        if (memcmp((void *)l_ramCopy.page[page].payload, (void *)data, len) != 0)  /* are the new data different ? */
    9fac:	a2da 11e1 	add	A, #4577
    9fb0:	5205      	mov	[S-6], A
    9fb2:	5207      	mov	[S-8], A

00009fb4 <.LM65>:
    }
    return retVal;
}

bool unirom_WritePage(uint8_t page, uint8_t* data, uint8_t len)
{
    9fb4:	7e0d      	lod	X, [S-14]

00009fb6 <.LM66>:
    bool retVal = false;

    if (len <= 7u)
    {
        if (memcmp((void *)l_ramCopy.page[page].payload, (void *)data, len) != 0)  /* are the new data different ? */
    9fb6:	ec00      	cmp	Y, #0
    9fb8:	1927      	je	0xa008 <.L42>
    9fba:	7ae2      	lod	Y, A
    9fbc:	7201      	lod	A, [S-2]

00009fbe <.L54>:
    9fbe:	52df      	push	A
    9fc0:	6ad6      	lod	AH, [Y++]
    9fc2:	cade      	sub	AH, [X++]
    9fc4:	1d04      	jne	0x9fce <.L55>
    9fc6:	72cf      	pop	A
    9fc8:	a801      	sub	A, #1
    9fca:	1d79      	jne	0x9fbe <.L54>
    9fcc:	0002      	jmp	0x9fd2 <.L56>

00009fce <.L55>:
    9fce:	5c01      	dec	S, #2
    9fd0:	4412      	rrc	A

00009fd2 <.L56>:
    9fd2:	ac00      	cmp	A, #0
    9fd4:	1919      	je	0xa008 <.L42>

00009fd6 <.LM67>:
        {
            memcpy((void*)&l_ramCopy.page[page].payload[0], (void *)data, len);  /* write the data to the ram copy */
    9fd6:	7e0d      	lod	X, [S-14]
    9fd8:	72ee      	lod	A, X
    9fda:	a201      	add	A, [S-2]
    9fdc:	7a05      	lod	Y, [S-6]
    9fde:	0ea7      	lod	C, ML.7

00009fe0 <.L57>:
    9fe0:	54cc      	movsb	[Y++], [X++]
    9fe2:	2ee2      	cmp	X, A
    9fe4:	1d7d      	jne	0x9fe0 <.L57>

00009fe6 <.LM68>:
            memset((void*)&l_ramCopy.page[page].payload[len], 0, 7u - len);  /* clear non-used data with 0 */
    9fe6:	7c07      	lod	X, #7
    9fe8:	2a01      	sub	X, [S-2]
    9fea:	7a01      	lod	Y, [S-2]
    9fec:	e209      	add	Y, [S-10]
    9fee:	e2da 11e1 	add	Y, #4577
    9ff2:	2c00      	cmp	X, #0
    9ff4:	1903      	je	0x9ffc <.L40>
    9ff6:	6000      	lod	AL, #0
    9ff8:	42d6      	mov	[Y++], AL

00009ffa <L0>:
    9ffa:	1bfe      	djnz	X, 0x9ff8 <.LASF1149+0x6>

00009ffc <.L40>:

            _updateCRC8(&l_ramCopy.page[page]);  /* update CRC8 of that page */
    9ffc:	7209      	lod	A, [S-10]
    9ffe:	a2da 11e0 	add	A, #4576
    a002:	1725      	call	0x9e4e <__updateCRC8>

0000a004 <.LM70>:

            retVal = true;
    a004:	7001      	lod	A, #1
    a006:	540b      	ret	#12

0000a008 <.L42>:
    return retVal;
}

bool unirom_WritePage(uint8_t page, uint8_t* data, uint8_t len)
{
    bool retVal = false;
    a008:	7000      	lod	A, #0

0000a00a <.LM72>:
            retVal = true;
        }
    }

    return retVal;
}
    a00a:	540b      	ret	#12

0000a00c <_unirom_ReadPage>:

bool unirom_ReadPage(uint8_t page, uint8_t* data, uint8_t len)
{
    a00c:	5805      	inc	S, #6

0000a00e <.LCFI20>:
    a00e:	660b      	lod	YL, [S-12]
    a010:	5cf6      	usex	Y

0000a012 <.LM74>:
    bool retVal = false;

    if (len <= 7u)
    a012:	ec07      	cmp	Y, #7
    a014:	1a02      	jule	0xa01a <.L59>

0000a016 <.L61>:
    return retVal;
}

bool unirom_ReadPage(uint8_t page, uint8_t* data, uint8_t len)
{
    bool retVal = false;
    a016:	7000      	lod	A, #0
    a018:	5407      	ret	#8

0000a01a <.L59>:
    a01a:	44a2      	asl	A, #2
    a01c:	4422      	asl	A

0000a01e <.LVL63>:
    a01e:	5205      	mov	[S-6], A

0000a020 <.LM76>:

    if (len <= 7u)
    {
        if (nvram_CalcCRC((void*)&l_ramCopy.page[page], sizeof(page_t) / sizeof(uint16_t)) == 0xFF)  /* check crc of the page */
    a020:	a2da 11e0 	add	A, #4576
    a024:	54ca 0004 	pushw	#4

0000a028 <.LCFI21>:
    a028:	5a05      	mov	[S-6], Y
    a02a:	82db 1511 	callf	0x2a22 <_nvram_CalcCRC>
    a02e:	5c01      	dec	S, #2

0000a030 <.LCFI22>:
    a030:	7a03      	lod	Y, [S-4]
    a032:	aeda 00ff 	cmp	A, #255
    a036:	1d6f      	jne	0xa016 <.L61>

0000a038 <.LM77>:
        {
            memcpy((void*)data, (void *)l_ramCopy.page[page].payload, len);  /* read from ram copy */
    a038:	7205      	lod	A, [S-6]
    a03a:	a2da 11e1 	add	A, #4577
    a03e:	ec00      	cmp	Y, #0
    a040:	190a      	je	0xa056 <.L62>
    a042:	7e09      	lod	X, [S-10]
    a044:	5e05      	mov	[S-6], X
    a046:	7ee2      	lod	X, A
    a048:	e2e2      	add	Y, A
    a04a:	72e6      	lod	A, Y
    a04c:	7a05      	lod	Y, [S-6]
    a04e:	0ea7      	lod	C, ML.7

0000a050 <.L66>:
    a050:	54cc      	movsb	[Y++], [X++]
    a052:	2ee2      	cmp	X, A
    a054:	1d7d      	jne	0xa050 <.L66>

0000a056 <.L62>:

            retVal = true;
    a056:	7001      	lod	A, #1

0000a058 <.LM79>:
        }
    }
    return retVal;
}
    a058:	5407      	ret	#8

0000a05a <_CalculateTemperature3pLinearize>:
    a05a:	7ed8 09b0 	lod	X, 0x9b0 <.LASF1599+0x4>
    a05e:	54e4      	mov	Cx, #4
    a060:	44fe      	asr	X, #2
    a062:	1ffe      	djnz	Cx, 0xa060 <_CalculateTemperature3pLinearize+0x6>

0000a064 <.LM3>:
    a064:	7ad8 09b4 	lod	Y, 0x9b4 <.LASF1599+0x8>
    a068:	eae2      	sub	Y, A
    a06a:	72e6      	lod	A, Y

0000a06c <.LVL2>:
    a06c:	7ad8 09b8 	lod	Y, 0x9b8 <.LASF1599+0xc>

0000a070 <.LM4>:
    a070:	ac00      	cmp	A, #0
    a072:	1e93      	jsge	0xa09a <.L2>

0000a074 <.LBB6>:
    a074:	5cf6      	usex	Y

0000a076 <.L8>:
    a076:	4831      	muls	YA, A, Y

0000a078 <.LBE8>:
    a078:	4cb2 0000 	cmp	YA, #0
    a07c:	0000 
    a07e:	1e84      	jsge	0xa088 <.L5>
    a080:	4cc0      	mov	D, YA
    a082:	4c0a 007f 	addu	D, #127
    a086:	4c80      	mov	YA, D

0000a088 <.L5>:
    a088:	48b6      	asr	YA, #7

0000a08a <.LM8>:
    a08a:	2c00      	cmp	X, #0
    a08c:	1d04      	jne	0xa096 <.L6>

0000a08e <.LM9>:
    a08e:	66d8 09b6 	lod	YL, 0x9b6 <.LASF1599+0xa>
    a092:	5ce6      	ssex	Y
    a094:	7ee6      	lod	X, Y

0000a096 <.L6>:
    a096:	a2ee      	add	A, X

0000a098 <.LM11>:
    a098:	5401      	ret

0000a09a <.L2>:
    a09a:	6400      	lod	YL, #0
    a09c:	7ae8      	swap	Y

0000a09e <.LVL10>:
    a09e:	07eb      	jmp	0xa076 <.L8>

0000a0a0 <_SetSystemSpeed>:
    a0a0:	5801      	inc	S, #2

0000a0a2 <.LCFI0>:
    a0a2:	7ee2      	lod	X, A

0000a0a4 <.LM2>:
    a0a4:	62d8 0180 	lod	AL, 0x180 <.LASF1350+0x7>

0000a0a8 <.LVL1>:
    a0a8:	8407      	or	AL, #7
    a0aa:	42d8 0180 	mov	0x180 <.LASF1350+0x7>, AL

0000a0ae <.LM3>:
    a0ae:	62d8 0191 	lod	AL, 0x191 <.LASF1557+0x8>
    a0b2:	840f      	or	AL, #15
    a0b4:	42d8 0191 	mov	0x191 <.LASF1557+0x8>, AL

0000a0b8 <.LBB118>:
    a0b8:	7ad8 01cc 	lod	Y, 0x1cc <_TRIM_RCO32M>

0000a0bc <.LBE118>:
    a0bc:	72ee      	lod	A, X
    a0be:	b6da 03ff 	and	A, #1023

0000a0c2 <.LM6>:
    a0c2:	f6da fc00 	and	Y, #64512
    a0c6:	a6e6      	or	A, Y
    a0c8:	52d8 01cc 	mov	0x1cc <_TRIM_RCO32M>, A

0000a0cc <.LM7>:
    a0cc:	6205      	lod	AL, [S-6]
    a0ce:	42d8 0200 	mov	0x200 <_PORT_CLOCK_CTRL>, AL

0000a0d2 <.LM8>:
    a0d2:	7aee      	lod	Y, X
    a0d4:	7ae8      	swap	Y
    a0d6:	44b6      	lsr	Y, #2
    a0d8:	f403      	and	Y, #3
    a0da:	e004      	add	Y, #4

0000a0dc <.LM9>:
    a0dc:	5cf2      	usex	A
    a0de:	5201      	mov	[S-2], A
    a0e0:	6205      	lod	AL, [S-6]
    a0e2:	1904      	je	0xa0ec <.L2>

0000a0e4 <.LM10>:
    a0e4:	72ee      	lod	A, X
    a0e6:	d480      	and	AH, #-128
    a0e8:	5ca2      	sne	A
    a0ea:	eae2      	sub	Y, A

0000a0ec <.L2>:
    a0ec:	62d8 0191 	lod	AL, 0x191 <.LASF1557+0x8>
    a0f0:	94f0      	and	AL, #-16
    a0f2:	86e8      	or	AL, YL
    a0f4:	42d8 0191 	mov	0x191 <.LASF1557+0x8>, AL

0000a0f8 <.LM12>:
    a0f8:	7aee      	lod	Y, X

0000a0fa <.LVL6>:
    a0fa:	7ae8      	swap	Y
    a0fc:	44b6      	lsr	Y, #2
    a0fe:	44b6      	lsr	Y, #2
    a100:	f403      	and	Y, #3
    a102:	e001      	add	Y, #1

0000a104 <.LM13>:
    a104:	7201      	lod	A, [S-2]
    a106:	1906      	je	0xa114 <.L3>

0000a108 <.LM14>:
    a108:	36da 4000 	and	X, #16384

0000a10c <.LVL8>:
    a10c:	5cae      	sne	X
    a10e:	eaee      	sub	Y, X

0000a110 <.LM15>:
    a110:	1d01      	jne	0xa114 <.L3>

0000a112 <.LM16>:
    a112:	7801      	lod	Y, #1

0000a114 <.L3>:
    a114:	62d8 0180 	lod	AL, 0x180 <.LASF1350+0x7>
    a118:	94f8      	and	AL, #-8
    a11a:	86e8      	or	AL, YL
    a11c:	42d8 0180 	mov	0x180 <.LASF1350+0x7>, AL

0000a120 <.LM18>:
    a120:	5403      	ret	#4

0000a122 <_EEPROM_BusyChecks>:
    a122:	72d8 0186 	lod	A, 0x186 <.LASF1351+0x5>
    a126:	d440      	and	AH, #64
    a128:	1906      	je	0xa136 <.L2>

0000a12a <.LM3>:
    a12a:	62d8 0186 	lod	AL, 0x186 <.LASF1351+0x5>
    a12e:	8401      	or	AL, #1

0000a130 <.L7>:
    a130:	42d8 0186 	mov	0x186 <.LASF1351+0x5>, AL

0000a134 <.L1>:
    a134:	5401      	ret

0000a136 <.L2>:
    a136:	72d8 0186 	lod	A, 0x186 <.LASF1351+0x5>
    a13a:	d410      	and	AH, #16
    a13c:	197b      	je	0xa134 <.L1>

0000a13e <.LM7>:
    a13e:	62d8 0186 	lod	AL, 0x186 <.LASF1351+0x5>
    a142:	940f      	and	AL, #15
    a144:	07f5      	jmp	0xa130 <.L7>

0000a146 <_EEPROM_WriteWord64_blocking>:
    a146:	5801      	inc	S, #2

0000a148 <.LCFI1>:
    a148:	7ed8 0186 	lod	X, 0x186 <.LASF1351+0x5>

0000a14c <.L24>:
    a14c:	2c00      	cmp	X, #0
    a14e:	1e86      	jsge	0xa15c <.L19>

0000a150 <.LM42>:
    a150:	5201      	mov	[S-2], A
    a152:	17e7      	call	0xa122 <_EEPROM_BusyChecks>

0000a154 <.LM43>:
    a154:	7ed8 0186 	lod	X, 0x186 <.LASF1351+0x5>
    a158:	7201      	lod	A, [S-2]
    a15a:	07f8      	jmp	0xa14c <.L24>

0000a15c <.L19>:
    a15c:	7e07      	lod	X, [S-8]

0000a15e <.LM45>:
    a15e:	5edf      	push	X

0000a160 <.LCFI2>:
    a160:	7e07      	lod	X, [S-8]

0000a162 <.LM47>:
    a162:	5edf      	push	X

0000a164 <.LCFI3>:
    a164:	82db 1328 	callf	0x2650 <_EEPROM_WriteWord64_non_blocking>

0000a168 <.LM48>:
    a168:	5c03      	dec	S, #4

0000a16a <.L21>:
    a16a:	72d8 0186 	lod	A, 0x186 <.LASF1351+0x5>
    a16e:	d420      	and	AH, #32
    a170:	1d7c      	jne	0xa16a <.L21>

0000a172 <.LM50>:
    a172:	5403      	ret	#4

0000a174 <_VERSION_getFwAppVersion>:
    a174:	72d8 d7ee 	lod	A, 0xd7ee <__fw_app_version_start+0x2>
    a178:	72e4      	swap	A

0000a17a <.LVL1>:
    a17a:	7ad8 d7ec 	lod	Y, 0xd7ec <__fw_app_version_start>
    a17e:	7ae8      	swap	Y

0000a180 <.LM3>:
    a180:	5401      	ret

0000a182 <_atan2_helper>:
    a182:	5801      	inc	S, #2

0000a184 <.LCFI0>:
    a184:	7ee6      	lod	X, Y

0000a186 <.LM2>:
    a186:	7ae2      	lod	Y, A
    a188:	7000      	lod	A, #0
    a18a:	4c63      	divu	YA, X
    a18c:	4c63      	divu	YA, X
    a18e:	66e4      	lod	YL, AH
    a190:	6c00      	lod	YH, #0
    a192:	4426      	asl	Y
    a194:	e2da 5d92 	add	Y, #23954
    a198:	7ef2      	lod	X, [Y+2]
    a19a:	2af0      	sub	X, [Y]
    a19c:	5cf2      	usex	A
    a19e:	4873      	muls	A, A, X
    a1a0:	62e4      	lod	AL, AH
    a1a2:	6800      	lod	AH, #0
    a1a4:	a2f0      	add	A, [Y]
    a1a6:	44b2      	lsr	A, #2

0000a1a8 <.LM3>:
    a1a8:	5403      	ret	#4

0000a1aa <_atan2_lookup>:
    a1aa:	5801      	inc	S, #2

0000a1ac <.LCFI1>:
    a1ac:	7ee2      	lod	X, A

0000a1ae <.LVL3>:
    a1ae:	5a01      	mov	[S-2], Y
    a1b0:	7ae2      	lod	Y, A
    a1b2:	7201      	lod	A, [S-2]

0000a1b4 <.LM5>:
    a1b4:	2ee2      	cmp	X, A
    a1b6:	1a06      	jule	0xa1c4 <.L3>

0000a1b8 <.LBB2>:
    a1b8:	17e4      	call	0xa182 <_atan2_helper>
    a1ba:	7ee2      	lod	X, A

0000a1bc <.LM7>:
    a1bc:	72da 4000 	lod	A, #16384

0000a1c0 <.LVL6>:
    a1c0:	aaee      	sub	A, X

0000a1c2 <.LBE2>:
    a1c2:	5403      	ret	#4

0000a1c4 <.L3>:
    a1c4:	ac00      	cmp	A, #0
    a1c6:	1908      	je	0xa1d8 <.L2>

0000a1c8 <.LM9>:
    a1c8:	2ee2      	cmp	X, A
    a1ca:	1904      	je	0xa1d4 <.L6>

0000a1cc <.LM10>:
    a1cc:	72ee      	lod	A, X
    a1ce:	7a01      	lod	Y, [S-2]
    a1d0:	17d8      	call	0xa182 <_atan2_helper>

0000a1d2 <.LVL9>:
    a1d2:	5403      	ret	#4

0000a1d4 <.L6>:
    a1d4:	72da 2000 	lod	A, #8192

0000a1d8 <.L2>:
    a1d8:	5403      	ret	#4

0000a1da <_atan2I16>:
    a1da:	ac00      	cmp	A, #0
    a1dc:	1e8c      	jsge	0xa1f6 <.L9>
    a1de:	5cc2      	neg	A

0000a1e0 <.LM18>:
    a1e0:	7a03      	lod	Y, [S-4]
    a1e2:	1d85      	jnn	0xa1ee <.L10>

0000a1e4 <.LBB3>:
    a1e4:	5cc6      	neg	Y
    a1e6:	17e1      	call	0xa1aa <_atan2_lookup>
    a1e8:	a2da 8000 	add	A, #32768

0000a1ec <.LBE3>:
    a1ec:	5401      	ret

0000a1ee <.L10>:
    a1ee:	7a03      	lod	Y, [S-4]
    a1f0:	17dc      	call	0xa1aa <_atan2_lookup>
    a1f2:	5cc2      	neg	A

0000a1f4 <.LVL20>:
    a1f4:	5401      	ret

0000a1f6 <.L9>:
    a1f6:	7a03      	lod	Y, [S-4]
    a1f8:	1d87      	jnn	0xa208 <.L12>

0000a1fa <.LBB4>:
    a1fa:	5cc6      	neg	Y
    a1fc:	17d6      	call	0xa1aa <_atan2_lookup>

0000a1fe <.LVL22>:
    a1fe:	7eda 8000 	lod	X, #32768
    a202:	2ae2      	sub	X, A

0000a204 <.LVL23>:
    a204:	72ee      	lod	A, X

0000a206 <.LBE4>:
    a206:	5401      	ret

0000a208 <.L12>:
    a208:	7a03      	lod	Y, [S-4]
    a20a:	07cf      	jmp	0xa1aa <_atan2_lookup>

0000a20c <_ldt_Tick>:
    a20c:	5809      	inc	S, #10

0000a20e <.LCFI35>:
    a20e:	5207      	mov	[S-8], A
    a210:	620d      	lod	AL, [S-14]

0000a212 <.LVL114>:
    a212:	5cf2      	usex	A
    a214:	5209      	mov	[S-10], A

0000a216 <.LBB60>:
    a216:	7ad8 1000 	lod	Y, 0x1000 <_ldtMe>
    a21a:	7ee6      	lod	X, Y
    a21c:	200c      	add	X, #12
    a21e:	5e03      	mov	[S-4], X
    a220:	62f8      	lod	AL, [X]
    a222:	1906      	je	0xa230 <.L86>

0000a224 <.LM190>:
    a224:	6064      	lod	AL, #100
    a226:	20fd      	add	X, #-3
    a228:	42f8      	mov	[X], AL

0000a22a <.LM191>:
    a22a:	6000      	lod	AL, #0
    a22c:	7e03      	lod	X, [S-4]
    a22e:	42f8      	mov	[X], AL

0000a230 <.L86>:
    a230:	7ee6      	lod	X, Y
    a232:	2009      	add	X, #9
    a234:	62f8      	lod	AL, [X]
    a236:	4203      	mov	[S-4], AL
    a238:	5cf2      	usex	A
    a23a:	5205      	mov	[S-6], A
    a23c:	7207      	lod	A, [S-8]
    a23e:	ae05      	cmp	A, [S-6]
    a240:	1c17      	jnc	0xa270 <.L87>

0000a242 <.LM193>:
    a242:	6203      	lod	AL, [S-4]
    a244:	8a07      	sub	AL, [S-8]

0000a246 <.L98>:
    a246:	42f8      	mov	[X], AL

0000a248 <.LBB63>:
    a248:	7ee6      	lod	X, Y
    a24a:	200d      	add	X, #13
    a24c:	e00a      	add	Y, #10
    a24e:	62f8      	lod	AL, [X]
    a250:	1904      	je	0xa25a <.L89>

0000a252 <.LM196>:
    a252:	6064      	lod	AL, #100
    a254:	42f0      	mov	[Y], AL

0000a256 <.LM197>:
    a256:	6000      	lod	AL, #0
    a258:	42f8      	mov	[X], AL

0000a25a <.L89>:
    a25a:	62f0      	lod	AL, [Y]
    a25c:	4205      	mov	[S-6], AL
    a25e:	5cf2      	usex	A
    a260:	7ee2      	lod	X, A
    a262:	7209      	lod	A, [S-10]
    a264:	aeee      	cmp	A, X
    a266:	1c06      	jnc	0xa274 <.L90>

0000a268 <.LM199>:
    a268:	6205      	lod	AL, [S-6]
    a26a:	8a0d      	sub	AL, [S-14]

0000a26c <.L99>:
    a26c:	42f0      	mov	[Y], AL

0000a26e <.LBE63>:
    a26e:	540b      	ret	#12

0000a270 <.L87>:
    a270:	6000      	lod	AL, #0
    a272:	07e9      	jmp	0xa246 <.L98>

0000a274 <.L90>:
    a274:	6000      	lod	AL, #0
    a276:	07fa      	jmp	0xa26c <.L99>

0000a278 <_ml_GetProtectedID>:
    a278:	62d8 0e47 	lod	AL, 0xe47 <_LinProtectedID>
    a27c:	5cf2      	usex	A

0000a27e <.LM11>:
    a27e:	5401      	ret

0000a280 <_ml_SetFixedBaudRate>:
    a280:	5801      	inc	S, #2

0000a282 <.LCFI1>:
    a282:	7ee2      	lod	X, A

0000a284 <.LM24>:
    a284:	a2da fc18 	add	A, #64536

0000a288 <.LVL18>:
    a288:	aeda 4a38 	cmp	A, #19000
    a28c:	1e22      	jug	0xa2d2 <.L16>

0000a28e <.LM25>:
    a28e:	7205      	lod	A, [S-6]

0000a290 <.LBB36>:
    a290:	4822 2710 	mulu	YA, A, #10000

0000a294 <.LVL21>:
    a294:	442e      	asl	X

0000a296 <.LBB38>:
    a296:	4c63      	divu	YA, X
    a298:	4c63      	divu	YA, X
    a29a:	7ae2      	lod	Y, A

0000a29c <.LBE38>:
    a29c:	7000      	lod	A, #0

0000a29e <.LVL24>:
    a29e:	5201      	mov	[S-2], A
    a2a0:	7c0c      	lod	X, #12

0000a2a2 <.L15>:
    a2a2:	72e6      	lod	A, Y
    a2a4:	a2da fc27 	add	A, #64551
    a2a8:	aeda 03fb 	cmp	A, #1019
    a2ac:	1e0c      	jug	0xa2c6 <.L14>

0000a2ae <.LM30>:
    a2ae:	a2da 03de 	add	A, #990
    a2b2:	4cf2      	usex	YA

0000a2b4 <.LBB40>:
    a2b4:	7c0a      	lod	X, #10
    a2b6:	4c63      	divu	YA, X
    a2b8:	4c63      	divu	YA, X

0000a2ba <.LBE40>:
    a2ba:	5cf2      	usex	A

0000a2bc <.LVL28>:
    a2bc:	52df      	push	A

0000a2be <.LCFI2>:
    a2be:	7203      	lod	A, [S-4]
    a2c0:	82db 11e4 	callf	0x23c8 <_ml_SetBaudRate>

0000a2c4 <.LCFI3>:
    a2c4:	5405      	ret	#6

0000a2c6 <.L14>:
    a2c6:	4436      	lsr	Y

0000a2c8 <.LM34>:
    a2c8:	6201      	lod	AL, [S-2]
    a2ca:	8001      	add	AL, #1
    a2cc:	5cf2      	usex	A
    a2ce:	5201      	mov	[S-2], A

0000a2d0 <.LVL34>:
    a2d0:	1be8      	djnz	X, 0xa2a2 <.L15>

0000a2d2 <.L16>:
    a2d2:	7001      	lod	A, #1

0000a2d4 <.LM36>:
    a2d4:	5403      	ret	#4

0000a2d6 <_ml_Init>:
    a2d6:	5801      	inc	S, #2

0000a2d8 <.LCFI4>:
    a2d8:	5201      	mov	[S-2], A
    a2da:	82db 20bb 	callf	0x4176 <_ml_InitLinModule>

0000a2de <.LM39>:
    a2de:	7a01      	lod	Y, [S-2]
    a2e0:	ac00      	cmp	A, #0
    a2e2:	1d29      	jne	0xa336 <.L18>

0000a2e4 <.LM40>:
    a2e4:	7e07      	lod	X, [S-8]

0000a2e6 <.LM41>:
    a2e6:	5edf      	push	X

0000a2e8 <.LCFI5>:
    a2e8:	52df      	push	A

0000a2ea <.LCFI6>:
    a2ea:	54ca 0001 	pushw	#1

0000a2ee <.LCFI7>:
    a2ee:	52df      	push	A

0000a2f0 <.LCFI8>:
    a2f0:	7001      	lod	A, #1

0000a2f2 <.LVL38>:
    a2f2:	5a09      	mov	[S-10], Y
    a2f4:	82db 118d 	callf	0x231a <_ml_SetOptions>

0000a2f8 <.LM42>:
    a2f8:	5c07      	dec	S, #8

0000a2fa <.LCFI9>:
    a2fa:	7a01      	lod	Y, [S-2]
    a2fc:	ac00      	cmp	A, #0
    a2fe:	1d1b      	jne	0xa336 <.L18>

0000a300 <.LM43>:
    a300:	ec01      	cmp	Y, #1
    a302:	1d0c      	jne	0xa31c <.L20>

0000a304 <.L26>:
    a304:	82db 11ea 	callf	0x23d4 <_ml_SetAutoBaudRateMode>

0000a308 <.L21>:
    a308:	ac00      	cmp	A, #0
    a30a:	1d15      	jne	0xa336 <.L18>

0000a30c <.LM46>:
    a30c:	7205      	lod	A, [S-6]

0000a30e <.LM47>:
    a30e:	aeda 3a98 	cmp	A, #15000
    a312:	5c80      	sc	A
    a314:	4422      	asl	A
    a316:	82db 1181 	callf	0x2302 <_ml_SetSlewRate>

0000a31a <.LVL43>:
    a31a:	5403      	ret	#4

0000a31c <.L20>:
    a31c:	ec02      	cmp	Y, #2
    a31e:	1d02      	jne	0xa324 <.L22>

0000a320 <.LM49>:
    a320:	7001      	lod	A, #1

0000a322 <.LVL44>:
    a322:	07f0      	jmp	0xa304 <.L26>

0000a324 <.L22>:
    a324:	ec00      	cmp	Y, #0
    a326:	1d06      	jne	0xa334 <.L24>

0000a328 <.LM51>:
    a328:	7209      	lod	A, [S-10]

0000a32a <.LM52>:
    a32a:	52df      	push	A

0000a32c <.LCFI10>:
    a32c:	7207      	lod	A, [S-8]
    a32e:	17a8      	call	0xa280 <_ml_SetFixedBaudRate>

0000a330 <.LVL47>:
    a330:	5c01      	dec	S, #2

0000a332 <.LCFI11>:
    a332:	07ea      	jmp	0xa308 <.L21>

0000a334 <.L24>:
    a334:	7001      	lod	A, #1

0000a336 <.L18>:
    a336:	5403      	ret	#4
